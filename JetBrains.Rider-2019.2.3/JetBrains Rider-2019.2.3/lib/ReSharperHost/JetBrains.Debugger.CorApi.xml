<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.Debugger.CorApi</name>
    </assembly>
    <members>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.CodeChunkInfo">
            <summary>
            
            </summary>
            <example><code>
            from: &lt;cordebug.idl&gt;
                   typedef struct _CodeChunkInfo
                   {
                       CORDB_ADDRESS startAddr;
                       ULONG32 length;
                   } CodeChunkInfo;
            </code></example>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.CorDebugBlockingObject">
             <summary>
             
             </summary>
             <example><code>
             typedef struct CorDebugBlockingObject {
                ICorDebugValue         *pBlockingObject;
                DWORD                   dwTimeout;
                CorDebugBlockingReason  blockingReason;
            } CorDebugBlockingObject;
             </code></example>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.CorDebugBlockingReason">
             <summary>
             
             </summary>
             <example><code>
             typedef enum CorDebugBlockingReason {
                BLOCKING_NONE                     = 0x0,
                BLOCKING_MONITOR_CRITICAL_SECTION = 0x1,
                BLOCKING_MONITOR_EVENT            = 0x2
            } CorDebugBlockingReason;
             </code></example>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.CorDebugChainReason">
            <summary>
            
            </summary>
            <example><code>
            from: &lt;cordebug.idl&gt;
                   typedef enum CorDebugChainReason
                   {
                       // Note that the first five line up with CorDebugIntercept
                       CHAIN_NONE              = 0x000,
                       CHAIN_CLASS_INIT        = 0x001,
                       CHAIN_EXCEPTION_FILTER  = 0x002,
                       CHAIN_SECURITY          = 0x004,
                       CHAIN_CONTEXT_POLICY    = 0x008,
                       CHAIN_INTERCEPTION      = 0x010,
                       CHAIN_PROCESS_START     = 0x020,
                       CHAIN_THREAD_START      = 0x040,
                       CHAIN_ENTER_MANAGED     = 0x080,
                       CHAIN_ENTER_UNMANAGED   = 0x100,
                       CHAIN_DEBUGGER_EVAL     = 0x200,
                       CHAIN_CONTEXT_SWITCH    = 0x400,
                       CHAIN_FUNC_EVAL         = 0x800,
                    } CorDebugChainReason;
            </code></example>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.CorDebugExceptionCallbackType">
            <summary>
            
            </summary>
            <example><code>
            from: &lt;cordebug.idl&gt;
                   typedef enum CorDebugExceptionCallbackType
                   {
                       DEBUG_EXCEPTION_FIRST_CHANCE = 1,        /* Fired when exception thrown * /
                       DEBUG_EXCEPTION_USER_FIRST_CHANCE = 2,   /* Fired when search reaches first user code * /
                       DEBUG_EXCEPTION_CATCH_HANDLER_FOUND = 3, /* Fired if &amp; when search finds a handler * /
                       DEBUG_EXCEPTION_UNHANDLED = 4            /* Fired if search doesnt find a handler * /
                   } CorDebugExceptionCallbackType;
            </code></example>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorDebugExceptionCallbackType.DEBUG_EXCEPTION_FIRST_CHANCE">
            <summary>
            Fired when exception thrown
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorDebugExceptionCallbackType.DEBUG_EXCEPTION_USER_FIRST_CHANCE">
            <summary>
            Fired when search reaches first user code
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:JetBrains.Debugger.CorApi.ComInterop.CorDebugExceptionCallbackType.DEBUG_EXCEPTION_CATCH_HANDLER_FOUND" -->
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorDebugExceptionCallbackType.DEBUG_EXCEPTION_UNHANDLED">
            <summary>
            Fired if search doesnt find a handler
            </summary>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.CorDebugExceptionUnwindCallbackType">
            <summary>
            
            </summary>
            <example><code>
            from: &lt;cordebug.idl&gt;
                    typedef enum CorDebugExceptionUnwindCallbackType
                    {
                        DEBUG_EXCEPTION_UNWIND_BEGIN = 1, /* Fired at the beginning of the unwind * /
                        DEBUG_EXCEPTION_INTERCEPTED = 2   /* Fired after an exception has been intercepted * /
                    } CorDebugExceptionUnwindCallbackType;
            </code></example>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorDebugExceptionUnwindCallbackType.DEBUG_EXCEPTION_UNWIND_BEGIN">
            <summary>
            Fired at the beginning of the unwind
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorDebugExceptionUnwindCallbackType.DEBUG_EXCEPTION_INTERCEPTED">
            <summary>
            Fired after an exception has been intercepted
            </summary>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.CorDebugGuidToTypeMapping">
            <summary>
            </summary>
            <example><code>
            typedef struct CorDebugGuidToTypeMapping
            {
                GUID iid;
                ICorDebugType * pType;
            } CorDebugGuidToTypeMapping; </code></example>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.CorDebugHandleType">
            <summary>
            ICorDebugHeapValue::CreateHandle takes a handle flavor.
                   A strong handle will keep an object alive while a weak track resurrection
                   will not.
            </summary>
            <example><code>
            from: &lt;cordebug.idl&gt;
                   /* ICorDebugHeapValue::CreateHandle takes a handle flavor.
                   * A strong handle will keep an object alive while a weak track resurrection
                   * will not.
                   * /
                   typedef enum CorDebugHandleType
                   {
                       HANDLE_STRONG = 1,
                       HANDLE_WEAK_TRACK_RESURRECTION = 2
                   } CorDebugHandleType;
            </code></example>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.CorDebugIntercept">
            <summary>
            
            </summary>
            <example><code>
            from: &lt;cordebug.idl&gt;
                   typedef enum CorDebugIntercept
                   {
                       INTERCEPT_NONE                = 0x0 ,
                       INTERCEPT_CLASS_INIT          = 0x01,
                       INTERCEPT_EXCEPTION_FILTER    = 0x02,
                       INTERCEPT_SECURITY            = 0x04,
                       INTERCEPT_CONTEXT_POLICY      = 0x08,
                       INTERCEPT_INTERCEPTION        = 0x10,
                       INTERCEPT_ALL                 = 0xffff
                   } CorDebugIntercept;
            </code></example>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.CorDebugInternalFrameType">
             <summary>
             
             </summary>
             <example><code>
             from: &lt;cordebug.idl&gt;
                    typedef enum CorDebugInternalFrameType
                    {
                        // This is a 'null' value for GetFrameType and is included for completeness sake.
                        // ICorDebugInternalFrame::GetFrameType() should never actually return this.
                        STUBFRAME_NONE = 0x00000000,
            
                        // This frame is a M2U stub-frame. This could include both PInvoke
                        // and COM-interop calls.
                        STUBFRAME_M2U = 0x0000001,
            
                        // This is a U2M stub frame.
                        STUBFRAME_U2M = 0x0000002,
            
                        // AppDomain transition.
                        STUBFRAME_APPDOMAIN_TRANSITION = 0x00000003,
            
                        // LightWeight method calls.
                        STUBFRAME_LIGHTWEIGHT_FUNCTION = 0x00000004,
            
                        // Start of Func-eval. This is included for CHF callbacks.
                        // Funcevals also have a chain CHAIN_FUNC_EVAL (legacy from v1.0)
                        STUBFRAME_FUNC_EVAL = 0x00000005,
            
                        // Start of an internal call into the CLR.
                        STUBFRAME_INTERNALCALL = 0x00000006,
            
                        // start of a class initialization; corresponds to CHAIN_CLASS_INIT
                        STUBFRAME_CLASS_INIT = 0x00000007,
            
                        // an exception is thrown; corresponds to CHAIN_EXCEPTION_FILTER
                        STUBFRAME_EXCEPTION = 0x00000008,
            
                        // a frame used for code-access security purposes; corresponds to CHAIN_SECURITY
                        STUBFRAME_SECURITY = 0x00000009,
            
                        // a frame used to mark that the runtime is jitting a managed method
                        STUBFRAME_JIT_COMPILATION = 0x0000000a,
                    } CorDebugInternalFrameType;
             </code></example>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorDebugInternalFrameType.STUBFRAME_NONE">
            <summary>
            This is a 'null' value for GetFrameType and is included for completeness sake.
            ICorDebugInternalFrame::GetFrameType() should never actually return this.
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorDebugInternalFrameType.STUBFRAME_M2U">
            <summary>
            This frame is a M2U stub-frame. This could include both PInvoke and COM-interop calls.
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorDebugInternalFrameType.STUBFRAME_U2M">
            <summary>
            This is a U2M stub frame.
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorDebugInternalFrameType.STUBFRAME_APPDOMAIN_TRANSITION">
            <summary>
            AppDomain transition.
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorDebugInternalFrameType.STUBFRAME_LIGHTWEIGHT_FUNCTION">
            <summary>
            LightWeight method calls.
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorDebugInternalFrameType.STUBFRAME_FUNC_EVAL">
            <summary>
            Start of Func-eval. This is included for CHF callbacks.
            Funcevals also have a chain CHAIN_FUNC_EVAL (legacy from v1.0)
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorDebugInternalFrameType.STUBFRAME_INTERNALCALL">
            <summary>
            Start of an internal call into the CLR.
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorDebugInternalFrameType.STUBFRAME_CLASS_INIT">
            <summary>
            start of a class initialization; corresponds to CHAIN_CLASS_INIT
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorDebugInternalFrameType.STUBFRAME_EXCEPTION">
            <summary>
            an exception is thrown; corresponds to CHAIN_EXCEPTION_FILTER
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorDebugInternalFrameType.STUBFRAME_SECURITY">
            <summary>
            a frame used for code-access security purposes; corresponds to CHAIN_SECURITY
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorDebugInternalFrameType.STUBFRAME_JIT_COMPILATION">
            <summary>
            a frame used to mark that the runtime is jitting a managed method
            </summary>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.CorDebugJITCompilerFlags">
             <summary>
             
             </summary>
             <example><code>
             typedef enum CorDebugJITCompilerFlags
            {
               CORDEBUG_JIT_DEFAULT = 0x1,                  // Track info, enable optimizations
               CORDEBUG_JIT_DISABLE_OPTIMIZATION = 0x3,     // Includes track info, disable opts,
               CORDEBUG_JIT_ENABLE_ENC = 0x7                // Includes track &amp; disable opt &amp; Edit and Continue.
            } CorDebugJITCompilerFlags;
            
             </code></example>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorDebugJITCompilerFlags.CORDEBUG_JIT_DEFAULT">
            <summary>
            Track info, enable optimizations
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorDebugJITCompilerFlags.CORDEBUG_JIT_DISABLE_OPTIMIZATION">
            <summary>
            Includes track info, disable opts,
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorDebugJITCompilerFlags.CORDEBUG_JIT_ENABLE_ENC">
            <summary>
            Includes track &amp; disable opt &amp; Edit and Continue.
            </summary>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.CorDebugMappingResult">
            <summary>
            
            </summary>
            <example><code>
            from: &lt;cordebug.idl&gt;
                   typedef enum CorDebugMappingResult
                   {
                       MAPPING_PROLOG              = 0x1,
                       MAPPING_EPILOG              = 0x2,
                       MAPPING_NO_INFO             = 0x4,
                       MAPPING_UNMAPPED_ADDRESS    = 0x8,
                       MAPPING_EXACT               = 0x10,
                       MAPPING_APPROXIMATE         = 0x20,
                   } CorDebugMappingResult;
            </code></example>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.CorDebugMDAFlags">
            <summary>
            
            </summary>
            <example><code>
            from: &lt;cordebug.idl&gt;
                   typedef enum CorDebugMDAFlags
                   {
                       // If this flag is high, then the thread may have slipped since the MDA was fired.
                       MDA_FLAG_SLIP = 0x2
                   } CorDebugMDAFlags;
            </code></example>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorDebugMDAFlags.MDA_FLAG_SLIP">
            <summary>
            If this flag is high, then the thread may have slipped since the MDA was fired.
            </summary>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.CorDebugSetContextFlag">
            <summary>
            
            
            </summary>
            <example><code>
            from: &lt;cordebug.idl&gt;
                   typedef enum CorDebugSetContextFlag
                   {
                       SET_CONTEXT_FLAG_ACTIVE_FRAME = 0x1,
                       SET_CONTEXT_FLAG_UNWIND_FRAME = 0x2,
                   } CorDebugSetContextFlag;
            </code></example>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.CorDebugStepReason">
            <summary>
            
             </summary>
            <example><code>
            from: &lt;cordebug.idl&gt;
                   typedef enum CorDebugStepReason
                   {
                       STEP_NORMAL,
                       STEP_RETURN,
                       STEP_CALL,
                       STEP_EXCEPTION_FILTER,
                       STEP_EXCEPTION_HANDLER,
                       STEP_INTERCEPT,
                       STEP_EXIT
                   } CorDebugStepReason;
            </code></example>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.CorDebugThreadState">
             <summary>
             A thread's DebugState determines whether the debugger lets a thread
             run or not.  Possible states are:
             
             THREAD_RUN - thread runs freely, unless a debug event occurs
             THREAD_SUSPEND - thread cannot run.
             
             NOTE: We allow for message pumping via a callback provided to the Hosting
                  API, thus we don't need an 'interrupted' state here.
             </summary>
             <example><code>
             from: &lt;cordebug.idl&gt;
                    /*
                    * A thread's DebugState determines whether the debugger lets a thread
                    * run or not.  Possible states are:
                    *
                    * THREAD_RUN - thread runs freely, unless a debug event occurs
                    * THREAD_SUSPEND - thread cannot run.
                    *
                    * NOTE: We allow for message pumping via a callback provided to the Hosting
                    *      API, thus we don't need an 'interrupted' state here.
                    * /
            
                    typedef enum CorDebugThreadState
                    {
                        THREAD_RUN,
                        THREAD_SUSPEND
                    } CorDebugThreadState;
             </code></example>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorDebugThreadState.THREAD_RUN">
            <summary>
            thread runs freely, unless a debug event occurs
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorDebugThreadState.THREAD_SUSPEND">
            <summary>
            thread cannot run
            </summary>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.CorDebugUnmappedStop">
             <summary>
             
             </summary>
             <example><code>
             from: &lt;cordebug.idl&gt;
                    typedef enum CorDebugUnmappedStop
                    {
                        STOP_NONE               = 0x0,
                        STOP_PROLOG             = 0x01,
                        STOP_EPILOG             = 0x02,
                        STOP_NO_MAPPING_INFO    = 0x04,
                        STOP_OTHER_UNMAPPED     = 0x08,
                        STOP_UNMANAGED          = 0x10,
            
                        STOP_ALL                = 0xffff,
            
                    } CorDebugUnmappedStop;
             </code></example>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.CorDebugUserState">
             <summary>
             GetUserState returns the user state of the thread, that is, the state
             which it has when the program being debugged examines it.
             A thread may have multiple state bits set.
             </summary>
             <example><code>
             from: &lt;cordebug.idl&gt;
                    typedef enum CorDebugUserState
                    {
                        USER_STOP_REQUESTED     = 0x01,
                        USER_SUSPEND_REQUESTED  = 0x02,
                        USER_BACKGROUND         = 0x04,
                        USER_UNSTARTED          = 0x08,
                        USER_STOPPED            = 0x10,
                        USER_WAIT_SLEEP_JOIN    = 0x20,
                        USER_SUSPENDED          = 0x40,
            
                        // An "unsafe point" is a place where the thread may block a Garbage Collection (GC).
                        // Debug events may be dispatched from unsafe points, but suspending a thread at
                        // an unsafe spot will very likely cause a deadlock (until the thread is resumed).
                        // This is a function of the thread's IP and the available GC info. The exact details
                        // of what is safe and unsafe is unspecified and highly determined by jit/gc implementation details.
                        USER_UNSAFE_POINT       = 0x80,
            
                        // indicates that this thread is a threadpool thread
                        USER_THREADPOOL         = 0x100,
                    } CorDebugUserState;
             </code></example>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorDebugUserState.USER_UNSAFE_POINT">
            <summary>
            An "unsafe point" is a place where the thread may block a Garbage Collection (GC).
            Debug events may be dispatched from unsafe points, but suspending a thread at
            an unsafe spot will very likely cause a deadlock (until the thread is resumed).
            This is a function of the thread's IP and the available GC info. The exact details
            of what is safe and unsafe is unspecified and highly determined by jit/gc implementation details.
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorDebugUserState.USER_THREADPOOL">
            <summary>
            indicates that this thread is a threadpool thread
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorElementType.ELEMENT_TYPE_PTR">
            <summary>
            PTR &lt;type&gt;
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorElementType.ELEMENT_TYPE_BYREF">
            <summary>
            BYREF &lt;type&gt;
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorElementType.ELEMENT_TYPE_VALUETYPE">
            <summary>
            VALUETYPE &lt;class Token&gt;
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorElementType.ELEMENT_TYPE_CLASS">
            <summary>
            CLASS &lt;class Token&gt;
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorElementType.ELEMENT_TYPE_VAR">
            <summary>
            a class type variable VAR &lt;number&gt;
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorElementType.ELEMENT_TYPE_ARRAY">
            <summary>
            MDARRAY &lt;type&gt; &lt;rank&gt; &lt;bcount&gt; &lt;bound1&gt; ... &lt;lbcount&gt; &lt;lb1&gt; ...
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorElementType.ELEMENT_TYPE_GENERICINST">
            <summary>
            GENERICINST &lt;generic type&gt; &lt;argCnt&gt; &lt;arg1&gt; ... &lt;argn&gt;
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorElementType.ELEMENT_TYPE_TYPEDBYREF">
            <summary>
            TYPEDREF  (it takes no args) a typed referece to some other type
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorElementType.ELEMENT_TYPE_I">
            <summary>
            native integer size
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorElementType.ELEMENT_TYPE_U">
            <summary>
            native unsigned integer size
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorElementType.ELEMENT_TYPE_FNPTR">
            <summary>
            FNPTR &lt;complete sig for the function including calling convention&gt;
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorElementType.ELEMENT_TYPE_OBJECT">
            <summary>
            Shortcut for System.Object
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorElementType.ELEMENT_TYPE_SZARRAY">
            <summary>
            Shortcut for single dimension zero lower bound array
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorElementType.ELEMENT_TYPE_MVAR">
            <summary>
            SZARRAY &lt;type&gt; a method type variable MVAR &lt;number&gt;
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorElementType.ELEMENT_TYPE_CMOD_REQD">
            <summary>
            This is only for binding required C modifier : E_T_CMOD_REQD &lt;mdTypeRef/mdTypeDef&gt;
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorElementType.ELEMENT_TYPE_CMOD_OPT">
            <summary>
            This is only for binding optional C modifier : E_T_CMOD_OPT &lt;mdTypeRef/mdTypeDef&gt;
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorElementType.ELEMENT_TYPE_INTERNAL">
            <summary>
            This is for signatures generated internally (which will not be persisted in any way). INTERNAL &lt;typehandle&gt;
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorElementType.ELEMENT_TYPE_MAX">
            <summary>
            first invalid element type
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorElementType.ELEMENT_TYPE_SENTINEL">
            <summary>
            sentinel for varargs
            </summary>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.CorElementTypeZapSig">
            <summary>
             enum CorElementTypeZapSig defines some additional internal ELEMENT_TYPE's
             values that are only used by ZapSig signatures.
            </summary>
            <example><code>
             //////////////////////////////////////////////////////////////////////////////
             // enum CorElementTypeZapSig defines some additional internal ELEMENT_TYPE's
             // values that are only used by ZapSig signatures.
             //////////////////////////////////////////////////////////////////////////////
            typedef enum CorElementTypeZapSig
            {
                // ZapSig encoding for ELEMENT_TYPE_VAR and ELEMENT_TYPE_MVAR. It is always followed
                // by the RID of a GenericParam token, encoded as a compressed integer.
                ELEMENT_TYPE_VAR_ZAPSIG = 0x3b,
            
                // ZapSig encoding for an array MethodTable to allow it to remain such after decoding
                // (rather than being transformed into the TypeHandle representing that array)
                //
                // The element is always followed by ELEMENT_TYPE_SZARRAY or ELEMENT_TYPE_ARRAY
                ELEMENT_TYPE_NATIVE_ARRAY_TEMPLATE_ZAPSIG = 0x3c,
            
                // ZapSig encoding for native value types in IL stubs. IL stub signatures may contain
                // ELEMENT_TYPE_INTERNAL followed by ParamTypeDesc with ELEMENT_TYPE_VALUETYPE element
                // type. It acts like a modifier to the underlying structure making it look like its
                // unmanaged view (size determined by unmanaged layout, blittable, no GC pointers).
                // 
                // ELEMENT_TYPE_NATIVE_VALUETYPE_ZAPSIG is used when encoding such types to NGEN images.
                // The signature looks like this: ET_NATIVE_VALUETYPE_ZAPSIG ET_VALUETYPE &lt;token&gt;.
                // See code:ZapSig.GetSignatureForTypeHandle and code:SigPointer.GetTypeHandleThrowing
                // where the encoding/decoding takes place.
                ELEMENT_TYPE_NATIVE_VALUETYPE_ZAPSIG = 0x3d,
                
                ELEMENT_TYPE_CANON_ZAPSIG            = 0x3e,     // zapsig encoding for [mscorlib]System.__Canon
                ELEMENT_TYPE_MODULE_ZAPSIG           = 0x3f,     // zapsig encoding for external module id#
            
            } CorElementTypeZapSig;
            
             </code></example>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorElementTypeZapSig.ELEMENT_TYPE_VAR_ZAPSIG">
            <summary>
            ZapSig encoding for ELEMENT_TYPE_VAR and ELEMENT_TYPE_MVAR. It is always followed
            by the RID of a GenericParam token, encoded as a compressed integer.
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorElementTypeZapSig.ELEMENT_TYPE_NATIVE_ARRAY_TEMPLATE_ZAPSIG">
            <summary>
            ZapSig encoding for an array MethodTable to allow it to remain such after decoding
            (rather than being transformed into the TypeHandle representing that array)
            The element is always followed by ELEMENT_TYPE_SZARRAY or ELEMENT_TYPE_ARRAY
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:JetBrains.Debugger.CorApi.ComInterop.CorElementTypeZapSig.ELEMENT_TYPE_NATIVE_VALUETYPE_ZAPSIG" -->
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorElementTypeZapSig.ELEMENT_TYPE_CANON_ZAPSIG">
            <summary>
            zapsig encoding for [mscorlib]System.__Canon
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.CorElementTypeZapSig.ELEMENT_TYPE_MODULE_ZAPSIG">
            <summary>
            zapsig encoding for external module id#
            </summary>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.CorTokenType">
             <summary>
             Token tags.
             </summary>
             <example><code>
             //
             // Token tags.
             //
            typedef enum CorTokenType
            {
                mdtModule               = 0x00000000,       //
                mdtTypeRef              = 0x01000000,       //
                mdtTypeDef              = 0x02000000,       //
                mdtFieldDef             = 0x04000000,       //
                mdtMethodDef            = 0x06000000,       //
                mdtParamDef             = 0x08000000,       //
                mdtInterfaceImpl        = 0x09000000,       //
                mdtMemberRef            = 0x0a000000,       //
                mdtCustomAttribute      = 0x0c000000,       //
                mdtPermission           = 0x0e000000,       //
                mdtSignature            = 0x11000000,       //
                mdtEvent                = 0x14000000,       //
                mdtProperty             = 0x17000000,       //
                mdtMethodImpl           = 0x19000000,       //
                mdtModuleRef            = 0x1a000000,       //
                mdtTypeSpec             = 0x1b000000,       //
                mdtAssembly             = 0x20000000,       //
                mdtAssemblyRef          = 0x23000000,       //
                mdtFile                 = 0x26000000,       //
                mdtExportedType         = 0x27000000,       //
                mdtManifestResource     = 0x28000000,       //
                mdtGenericParam         = 0x2a000000,       //
                mdtMethodSpec           = 0x2b000000,       //
                mdtGenericParamConstraint = 0x2c000000,
            
                mdtString               = 0x70000000,       //
                mdtName                 = 0x71000000,       //
                mdtBaseType             = 0x72000000,       // Leave this on the high end value. This does not correspond to metadata table
            } CorTokenType;
            
             </code></example>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.COR_ACTIVE_FUNCTION">
            <summary>
            
            </summary>
            <example><code>
            cordebug.idl:
               typedef struct _COR_ACTIVE_FUNCTION
               {
                   ICorDebugAppDomain *pAppDomain;   // Pointer to the owning AppDomain of the below IL Offset.
                   ICorDebugModule *pModule;         // Pointer to the owning Module of the below IL Offset.
                   ICorDebugFunction2 *pFunction;    // Pointer to the owning Function of the below IL Offset.
                   ULONG32 ilOffset;                 // IL Offset of the frame.
                   ULONG32 flags;                    // Bit mask of flags, currently unused.  Reserved.
               } COR_ACTIVE_FUNCTION;
            </code></example>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_ACTIVE_FUNCTION.pAppDomain">
            <summary>
            Pointer to the owning AppDomain of the below IL Offset.
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_ACTIVE_FUNCTION.pModule">
            <summary>
            Pointer to the owning Module of the below IL Offset.
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_ACTIVE_FUNCTION.pFunction">
            <summary>
            Pointer to the owning Function of the below IL Offset.
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_ACTIVE_FUNCTION.ilOffset">
            <summary>
            IL Offset of the frame.
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_ACTIVE_FUNCTION.Flags">
            <summary>
            Bit mask of flags, currently unused.  Reserved.
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_ARRAY_LAYOUT.componentID">
            <summary>
            The type of objects the array contains
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_ARRAY_LAYOUT.componentType">
            <summary>
            Whether the component itself is a GC reference, value class, or primitive
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_ARRAY_LAYOUT.firstElementOffset">
            <summary>
            The offset to the first element
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_ARRAY_LAYOUT.elementSize">
            <summary>
            The size of each element
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_ARRAY_LAYOUT.countOffset">
            <summary>
            The offset to the number of elements in the array
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_ARRAY_LAYOUT.rankSize">
            <summary>
            The size of the rank
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_ARRAY_LAYOUT.numRanks">
            <summary>
            The number of ranks in the array (1 for array, N for multidimensional array)
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_ARRAY_LAYOUT.rankOffset">
            <summary>
            The offset at which the ranks start
            </summary>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.COR_DEBUG_IL_TO_NATIVE_MAP">
            <summary>
            </summary>
            <example><code>
             typedef struct COR_DEBUG_IL_TO_NATIVE_MAP
            {
                ULONG32 ilOffset;
                ULONG32 nativeStartOffset;
                ULONG32 nativeEndOffset;
            } COR_DEBUG_IL_TO_NATIVE_MAP;
             </code></example>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.COR_DEBUG_STEP_RANGE">
            <summary>
            
            </summary>
            <example><code>
            from: &lt;cordebug.idl&gt;
                   typedef struct COR_DEBUG_STEP_RANGE
                   {
                       ULONG32 startOffset, endOffset;
                   } COR_DEBUG_STEP_RANGE;
            </code></example>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_FIELD.token">
            <summary>
            FieldDef token to get the field info
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_FIELD.offset">
            <summary>
            Offset in object of data
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_FIELD.id">
            <summary>
            TYPEID of the field
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_HEAPINFO.areGCStructuresValid">
            <summary>
            TRUE if it's ok to walk the heap, FALSE otherwise.
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_HEAPINFO.pointerSize">
            <summary>
            The size of pointers on the target architecture in bytes
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_HEAPINFO.numHeaps">
            <summary>
            The number of logical GC heaps in the process
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_HEAPINFO.concurrent">
            <summary>
            Is the GC concurrent?
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_HEAPINFO.gcType">
            <summary>
            Workstation or Server?
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_HEAPOBJECT.address">
            <summary>
            The address (in heap) of the object
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_HEAPOBJECT.size">
            <summary>
            The total size of the object
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_HEAPOBJECT.type">
            <summary>
            The fully instantiated type of the object
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_IL_MAP.oldOffset">
            <summary>
            Old IL offset relative to beginning of function
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_IL_MAP.newOffset">
            <summary>
            New IL offset relative to beginning of function
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_IL_MAP.fAccurate">
            <summary>
            TRUE if mapping is known to be good, FALSE otherwise
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_SEGMENT.start">
            <summary>
            The start address of the segment
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_SEGMENT.end">
            <summary>
            The end address of the segment
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_SEGMENT.type">
            <summary>
            The generation of the segment
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.COR_SEGMENT.heap">
            <summary>
            The heap the segment resides in
            </summary>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.COR_VERSION">
            <summary>
            
            </summary>
            <example><code>
            from: &lt;cordebug.idl&gt;
                   typedef struct _COR_VERSION
                   {
                       DWORD dwMajor;
                       DWORD dwMinor;
                       DWORD dwBuild;
                       DWORD dwSubBuild;
                   } COR_VERSION;
            </code></example>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.CorDebugFactory">
            <summary>
            Knows how to create <see cref="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebug" /> for various environments.
            </summary>
        </member>
        <member name="P:JetBrains.Debugger.CorApi.ComInterop.Eventing.CorAppDomainEventArgs.AppDomain">
            The AppDomain that generated the event. 
        </member>
        <member name="P:JetBrains.Debugger.CorApi.ComInterop.Eventing.CorAssemblyEventArgs.Assembly">
            <summary>
            The Assembly of interest.
            </summary>
        </member>
        <member name="P:JetBrains.Debugger.CorApi.ComInterop.Eventing.CorBreakpointEventArgs.Breakpoint">
            The breakpoint involved. 
        </member>
        <member name="P:JetBrains.Debugger.CorApi.ComInterop.Eventing.CorEvalEventArgs.Eval">
            The object being evaluated. 
        </member>
        <member name="P:JetBrains.Debugger.CorApi.ComInterop.Eventing.CorEventArgs.Controller">
            <summary>
            The Controller of the current event.
            </summary>
        </member>
        <member name="P:JetBrains.Debugger.CorApi.ComInterop.Eventing.CorEventArgs.Continue">
            <summary>
            The default behavior after an event is to Continue processing
            after the event has been handled.  This can be changed by
            setting this property to false.
            </summary>
        </member>
        <member name="P:JetBrains.Debugger.CorApi.ComInterop.Eventing.CorEventArgs.CallbackType">
            <summary>
            The type of callback that returned this CorEventArgs object.
            </summary>
        </member>
        <member name="P:JetBrains.Debugger.CorApi.ComInterop.Eventing.CorEventArgs.Thread">
            <summary>
            The CorThread associated with the callback event that returned
            this CorEventArgs object. If here is no such thread, Thread is null.
            </summary>
        </member>
        <member name="P:JetBrains.Debugger.CorApi.ComInterop.Eventing.CorExceptionEventArgs.Unhandled">
            Has the exception been handled yet? 
        </member>
        <member name="P:JetBrains.Debugger.CorApi.ComInterop.Eventing.CorProcessEventArgs.Process">
            The process that generated the event. 
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomainEx.GetProcess(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain.GetProcess(JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess@)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode2Ex.GetEntireCode(JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode2,JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess,System.Byte[]@)">
            <summary>
            Not tested properly
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode2Ex.GetCodeChunks(JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode2)">
            <summary>
            Not tested properly
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugCodeEx.GetEntireCode(JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode,System.UInt32)">
            <summary>
            Get all code from `@this` from `from` offset to the end of code.
            Use only for IL code, for native code use <see cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode2Ex.GetEntireCode(JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode2,JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess,System.Byte[]@)"/> 
            </summary>
            <param name="this"></param>
            <param name="from"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrameEx.GetTypeParamEnumWithSkip(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame,System.Int32)">
            <summary>
                      'TypeParameters' returns an enumerator that goes yields generic args from
                    both the class and the method. To enumerate just the generic args on the
                    method, we need to skip past the class args. We have to get that skip value
                    from the metadata. This is a helper function to efficiently get an enumerator that skips
                    to a given spot (likely past the class generic args).
            </summary>
            <param name="frame"></param>
            <param name="skip"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrameEx.GetFunction(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame.GetFunction(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction@)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrameEx.TryGetFunctionToken(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame,System.UInt32@)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame.GetFunctionToken(System.UInt32*)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrameEx.GetFunctionSafe(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame.GetFunction(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction@)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrameEx.GetCaller(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame.GetCaller(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame@)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrameEx.GetCallerSafe(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame.GetCaller(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame@)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrameEx.GetCalleeSafe(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame.GetCallee(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame@)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunctionBreakpointEx.Activate(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunctionBreakpoint,System.Boolean)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunctionBreakpoint.Activate(System.Int32)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunctionBreakpointEx.GetFunction(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunctionBreakpoint)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunctionBreakpoint.GetFunction(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction@)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunctionEx.GetModule(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction.GetModule(JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule@)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunctionEx.GetClass(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction.GetClass(JetBrains.Debugger.CorApi.ComInterop.ICorDebugClass@)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunctionEx.IsJMC(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction2.GetJMCStatus(System.Int32*)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunctionEx.GetILCode(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction.GetILCode(JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode@)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunctionEx.GetNativeCode(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction.GetNativeCode(JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode@)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunctionEx.GetCurrentVersionNumber(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction.GetCurrentVersionNumber(System.UInt32*)"/>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValueEx.ElementTypesPrimitiveGetSetValue">
            <summary>
            What <see cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValueEx.GetValue(JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValue)" /> / <see cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValueEx.SetValue(JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValue,System.Object)" /> can do as primitive objects (e.g. not a Value Type returned as an array of bytes, which is useless e.g. from a ToString point of view).
            </summary>
        </member>
        <member name="F:JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValueEx.ElementTypesSupportedByGetSetValue">
            <summary>
            On what <see cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValueEx.GetValue(JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValue)" /> / <see cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValueEx.SetValue(JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValue,System.Object)" /> won't throw.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValueEx.SetValue(JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValue,System.Object)">
            <summary>
            Convert the supplied value to the type of this CorGenericValue using System.IConvertable.
            Then store the value into this CorGenericValue.  Any compatible type can be supplied.
            For example, if you supply a string and the underlying type is ELEMENT_TYPE_BOOLEAN,
            Convert.ToBoolean will attempt to match the string against "true" and "false".
            </summary>
            <param name="corvalue"></param>
            <param name="value"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValueEx.CopyTo(JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValue,JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValue)">
            <summary>
            Copies value from source to dest 
            </summary>
            <param name="dest">dest value</param>
            <param name="source">source value</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValueEx.CopyPossibleBytes(JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValue,JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValue)">
            <summary>
            Copies as much as possible bytes from <paramref name="source"/> to <paramref name="dest"/> 
            </summary>
            <param name="source"></param>
            <param name="dest"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValueEx.IsZeros(JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValue)">
            <summary>
            Checks if the value's binary representations contains only zeros 
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValueEx.FillZeros(JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValue)">
            <summary>
            Fills the value blob with zeros 
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrameEx.GetFunctionToken(JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame.GetFunctionToken(System.UInt32*)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrameEx.GetIPAndMappingResult(JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame.GetIP(System.UInt32*,JetBrains.Debugger.CorApi.ComInterop.CorDebugMappingResult*)"/> 
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcessEx.GetAppDomains(JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.EnumerateAppDomains(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomainEnum@)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcessEx.GetThreads(JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.EnumerateThreads(JetBrains.Debugger.CorApi.ComInterop.ICorDebugThreadEnum@)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcessEx.HasQueuedCallbacks(JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.HasQueuedCallbacks(JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread,System.Int32*)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugReferenceValueEx.SetValueTo(JetBrains.Debugger.CorApi.ComInterop.ICorDebugReferenceValue,JetBrains.Debugger.CorApi.ComInterop.ICorDebugReferenceValue)">
            <summary>
            Sets the value of <paramref name="dest"/> that it points to object on <paramref name="source"/>
            </summary>
            <param name="dest"></param>
            <param name="source"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepperEx.IsActive(JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper.IsActive(System.Int32*)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepperEx.Deactivate_(JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper.Deactivate"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepperEx.SetJMC(JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper2,System.Boolean)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper2.SetJMC(System.Int32)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepperEx.StepOut_(JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper.StepOut"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepperEx.Step(JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper,System.Boolean)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper.Step(System.Int32)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepperEx.StepRange(JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper,System.Boolean,JetBrains.Debugger.CorApi.ComInterop.COR_DEBUG_STEP_RANGE[])">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper.StepRange(System.Int32,JetBrains.Debugger.CorApi.ComInterop.COR_DEBUG_STEP_RANGE*,System.UInt32)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThreadEx.GetChains(JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread.EnumerateChains(JetBrains.Debugger.CorApi.ComInterop.ICorDebugChainEnum@)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThreadEx.GetThreadId(JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread.GetID(System.UInt32*)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThreadEx.GetActiveFrame(JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread.GetActiveFrame(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame@)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThreadEx.GetProcess(JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread.GetProcess(JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess@)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThreadEx.CreateStepper(JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread.CreateStepper(JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper@)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThreadEx.GetAppDomain(JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread.GetAppDomain(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain@)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.CorDebugProcessFactory.CorDebugCreateProcess(JetBrains.Lifetimes.Lifetime,JetBrains.Util.ILogger,JetBrains.Debugger.CorApi.ComInterop.ICorDebug,JetBrains.Util.FileSystemPath,JetBrains.Util.CommandLineBuilderJet,JetBrains.Util.FileSystemPath,JetBrains.Util.InvokeChildProcess.PumpStreamHighLevelDelegate,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Launch a process under the control of the debugger.
            Parameters are the same as the Win32 CreateProcess call.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugValueEx.AssignTo(JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue,JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue,JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess,System.Boolean)">
            <summary>
            In the case when both are BYREFs it assigns the managed pointers. In the case of ordinary references it just assigns them. In other cases it unwraps the underlying values and makes binary copy 
            </summary>
            <param name="source"></param>
            <param name="dest"></param>
            <param name="corDebugProcess"></param>
            <param name="ignoreSizeMismatch"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugValueEx.SetByRefTo(JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue,System.UInt64,JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess)">
            <summary>
            Sets the pointer of BYREF reference <paramref name="referenceValue"/> to point to <paramref name="newAddress"/>
            </summary>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICLRMetaHost">
            <summary>
             ICLRMetaHost
             Activated using mscoree!CLRCreateInstance. Does not do any policy decisions, get
             ICLRMetaHostPolicy if you need that.
            </summary>
            <example><code>
             /**************************************************************************************
             ** ICLRMetaHost                                                                     **
             ** Activated using mscoree!CLRCreateInstance. Does not do any policy decisions, get **
             ** ICLRMetaHostPolicy if you need that.                                             **
             **************************************************************************************/
            [
                uuid(D332DB9E-B9B3-4125-8207-A14884F53216),
                version(1.0),
                helpstring("CLR meta hosting interface"),
                local
            ]
            interface ICLRMetaHost : IUnknown
            {
                /**********************************************************************************
                 ** Returns installed runtime with the specific version. Fails if not found.     **
                 ** NULL or any other wildcard is not accepted as pwzVersion                     **
                 ** Supersedes: CorBindToRuntimeEx with STARTUP_LOADER_SAFEMODE                  **
                 **********************************************************************************/
                HRESULT GetRuntime(
                    [in]  LPCWSTR pwzVersion,
                    [in]  REFIID  riid,   // IID_ICLRRuntimeInfo
                    [out, iid_is(riid), retval] LPVOID *ppRuntime);
            
                /**********************************************************************************
                 ** Returns runtime version burned into a file's metadata.                       **
                 ** Supersedes: GetFileVersion                                                   **
                 **********************************************************************************/
                HRESULT GetVersionFromFile(
                    [in]      LPCWSTR pwzFilePath,
                    [out, size_is(*pcchBuffer), annotation("_Out_writes_all_(*pcchBuffer)")] 
                              LPWSTR pwzBuffer, 
                    [in, out] DWORD *pcchBuffer);
            
                /**********************************************************************************
                 ** Returns an enumerator of runtimes installed on the machine.                  **
                 ** Supersedes: (none)                                                           **
                 **********************************************************************************/
                HRESULT EnumerateInstalledRuntimes(
                    [out, retval] IEnumUnknown **ppEnumerator);
            
                /**********************************************************************************
                 ** Provides an enumerator of runtimes loaded into the given process.            **
                 ** Supersedes: GetVersionFromProcess                                            **
                 **********************************************************************************/
                HRESULT EnumerateLoadedRuntimes(
                    [in]  HANDLE hndProcess,
                    [out, retval] IEnumUnknown **ppEnumerator);
            
                /**********************************************************************************
                 ** Provides a callback when a new runtime version has just been loaded, but not **
                 ** started.                                                                     **
                 **                                                                              **
                 ** The callback works in the following way:                                     **
                 **   - the callback is invoked only when a runtime is loaded for the first time **
                 **   - the callback will not be invoked for reentrant loads of the same runtime **
                 **   - the callback will be for reentrant loads of other runtimes               **
                 **   - it is guaranteed that no other thread may load the runtime until the     **
                 **     callback returns; any thread that does so blocks until this time.        **
                 **   - for non-reentrant multi-threaded runtime loads, callbacks are serialized **
                 **   - if the host intends to load (or cause to be loaded) another runtime in a **
                 **     reentrant fashion, or intends to perform any operations on the runtime   **
                 **     corresponding to the callback instance, the pfnCallbackThreadSet and     **
                 **     pfnCallbackThreadUnset arguments provided in the callback must be used   **
                 **     in the following way:                                                    **
                 **     - pfnCallbackThreadSet must be called by the thread that might cause a   **
                 **       runtime load before such a load is attempted                           **
                 **     - pfnCallbackThreadUnset must be called when the thread will no longer   **
                 **       cause such a runtime load (and before returning from the initial       **
                 **       callback)                                                              **
                 **     - pfnCallbackThreadSet and pfnCallbackThreadUnset are non-reentrant.     **
                 **                                                                              **
                 **   pCallbackFunction: This function is invoked when a new runtime has just    **
                 **                      been loaded. A value of NULL results in a failure       **
                 **                      return value of E_POINTER.                              **
                 **                                                                              **
                 ** Supersedes: LockClrVersion                                                   **
                 **********************************************************************************/
                HRESULT RequestRuntimeLoadedNotification(
                    [in] RuntimeLoadedCallbackFnPtr pCallbackFunction);
            
                /**********************************************************************************
                 ** Returns interface representing the runtime to which the legacy activation    **
                 ** policy has been bound (for example, by a useLegacyV2RuntimeActivationPolicy  **
                 ** config entry or by a call to ICLRRuntimeInfo::BindAsLegacyV2Runtime).        **
                 **********************************************************************************/
                HRESULT QueryLegacyV2RuntimeBinding(
                    [in] REFIID riid,
                    [out, iid_is(riid), retval] LPVOID *ppUnk);
            
                /**********************************************************************************
                 ** Shuts down the current process.                                              **
                 ** Supersedes: CorExitProcess                                                   **
                 **********************************************************************************/
                HRESULT ExitProcess(
                    [in] INT32 iExitCode);
            } // interface ICLRMetaHost
            
             
              </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICLRMetaHost.GetRuntime(System.UInt16*,System.Guid*,System.Void**)">
            <summary>
            Returns installed runtime with the specific version. Fails if not found.
            NULL or any other wildcard is not accepted as pwzVersion
            Supersedes: CorBindToRuntimeEx with STARTUP_LOADER_SAFEMODE
            </summary>
            <param name="pwzVersion"></param>
            <param name="riid"></param>
            <param name="ppRuntime"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICLRMetaHost.GetVersionFromFile(System.UInt16*,System.UInt16*,System.UInt32*)">
            <summary>
            Returns runtime version burned into a file's metadata.
            Supersedes: GetFileVersion
            </summary>
            <param name="pwzFilePath"></param>
            <param name="pwzBuffer"></param>
            <param name="pcchBuffer"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICLRMetaHost.EnumerateInstalledRuntimes(System.Void**)">
            <summary>
            Returns an enumerator of runtimes installed on the machine.
            Supersedes: (none)
            </summary>
            <param name="ppEnumerator"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICLRMetaHost.EnumerateLoadedRuntimes(System.Void*,System.Void**)">
            <summary>
            Provides an enumerator of runtimes loaded into the given process.
            Supersedes: GetVersionFromProcess
            </summary>
            <param name="hndProcess"></param>
            <param name="ppEnumerator"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICLRMetaHost.RequestRuntimeLoadedNotification(System.Void*)">
            <summary>
            Provides a callback when a new runtime version has just been loaded, but not
            started.
            The callback works in the following way:
              - the callback is invoked only when a runtime is loaded for the first time
              - the callback will not be invoked for reentrant loads of the same runtime
              - the callback will be for reentrant loads of other runtimes
              - it is guaranteed that no other thread may load the runtime until the
                callback returns; any thread that does so blocks until this time.
              - for non-reentrant multi-threaded runtime loads, callbacks are serialized
              - if the host intends to load (or cause to be loaded) another runtime in a
                reentrant fashion, or intends to perform any operations on the runtime
                corresponding to the callback instance, the pfnCallbackThreadSet and
                pfnCallbackThreadUnset arguments provided in the callback must be used
                in the following way:
                - pfnCallbackThreadSet must be called by the thread that might cause a
                  runtime load before such a load is attempted
                - pfnCallbackThreadUnset must be called when the thread will no longer
                  cause such a runtime load (and before returning from the initial
                  callback)
                - pfnCallbackThreadSet and pfnCallbackThreadUnset are non-reentrant.
              pCallbackFunction: This function is invoked when a new runtime has just
                                 been loaded. A value of NULL results in a failure
                                 return value of E_POINTER.
            Supersedes: LockClrVersion
            </summary>
            <param name="pCallbackFunction"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICLRMetaHost.QueryLegacyV2RuntimeBinding(System.Guid*,System.Void**)">
            <summary>
            Returns interface representing the runtime to which the legacy activation
            policy has been bound (for example, by a useLegacyV2RuntimeActivationPolicy
            config entry or by a call to ICLRRuntimeInfo::BindAsLegacyV2Runtime).
            </summary>
            <param name="riid"></param>
            <param name="ppUnk"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICLRMetaHost.ExitProcess(System.Int32)">
            <summary>
            Shuts down the current process.
            Supersedes: CorExitProcess
            </summary>
            <param name="iExitCode"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICLRRuntimeInfo">
            <summary>
              ICLRRuntimeInfo
              Represents a runtime - installed on the machine and/or loaded into a process.
              Includes functionality for obtaining various properties and for loading the
              runtime into the current process. The same installed runtime can be loaded
              multiple times in the same process (may not be supported in Dev10).
            </summary>
            <example><code>
              /**************************************************************************************
             ** ICLRRuntimeInfo                                                                  **
             ** Represents a runtime - installed on the machine and/or loaded into a process.    **
             ** Includes functionality for obtaining various properties and for loading the      **
             ** runtime into the current process. The same installed runtime can be loaded       **
             ** multiple times in the same process (may not be supported in Dev10).              **
             **************************************************************************************/
            [
                uuid(BD39D1D2-BA2F-486a-89B0-B4B0CB466891),
                version(1.0),
                helpstring("CLR runtime instance"),
                local
            ]
            interface ICLRRuntimeInfo : IUnknown
            {
                // Methods that query information:
            
                /**********************************************************************************
                 ** Returns the version of this runtime in the usual v-prefixed dotted form.     **
                 ** Supersedes: GetRequestedRuntimeInfo, GetRequestedRuntimeVersion,             **
                 **     GetCORVersion                                                            **
                 **********************************************************************************/
                HRESULT GetVersionString(
                    [out, size_is(*pcchBuffer), annotation("_Out_writes_all_opt_(*pcchBuffer)")] 
                               LPWSTR pwzBuffer, 
                    [in, out]  DWORD *pcchBuffer);
            
                /**********************************************************************************
                 ** Returns the directory where this runtime is installed.                       **
                 ** Supersedes: GetCORSystemDirectory                                            **
                 **********************************************************************************/
                HRESULT GetRuntimeDirectory(
                    [out, size_is(*pcchBuffer), annotation("_Out_writes_all_(*pcchBuffer)")] 
                               LPWSTR pwzBuffer, 
                    [in, out]  DWORD *pcchBuffer);
            
                /**********************************************************************************
                 ** Returns TRUE if this runtime is loaded into the specified process.           **
                 ** Supersedes: GetCORSystemDirectory                                            **
                 **********************************************************************************/
                HRESULT IsLoaded(
                    [in]  HANDLE hndProcess,
                    [out, retval] BOOL *pbLoaded);
            
                // Methods that may load the runtime:
            
                /**********************************************************************************
                 ** Translates an HRESULT value into an error message. Use iLocaleID -1 for the  **
                 ** default culture of the current thread.                                       **
                 ** Supersedes: LoadStringRC, LoadStringRCEx                                     **
                 **********************************************************************************/
                HRESULT LoadErrorString(
                    [in]       UINT iResourceID, 
                    [out, size_is(*pcchBuffer), annotation("_Out_writes_all_(*pcchBuffer)")] 
                               LPWSTR pwzBuffer, 
                    [in, out]  DWORD *pcchBuffer,
                    [in, lcid] LONG iLocaleID);
            
                /**********************************************************************************
                 ** Loads a library located alongside this runtime.                              **
                 ** Supersedes: LoadLibraryShim                                                  **
                 **********************************************************************************/
                HRESULT LoadLibrary(
                    [in]  LPCWSTR pwzDllName, 
                    [out, retval] HMODULE *phndModule);
            
                /**********************************************************************************
                 ** Gets the address of the specified function exported from this runtime.       **
                 ** It should NOT be documented what module the function lives in. We may want   **
                 ** to implement some forwarding policy here. The reason for exposing            **
                 ** GetProcAddress are functions like mscorwks!GetCLRIdentityManager.            **
                 ** Supersedes: GetRealProcAddress                                               **
                 **********************************************************************************/
                HRESULT GetProcAddress(
                    [in]  LPCSTR pszProcName, 
                    [out, retval] LPVOID *ppProc);
            
                /**********************************************************************************
                 ** Loads the runtime into the current process and returns an interface through  **
                 ** which runtime functionality is provided.                                     **
                 **                                                                              **
                 ** Supported CLSIDs/IIDs:                                                       **
                 ** CLSID_CorMetaDataDispenser   IID_IMetaDataDispenser,IID_IMetaDataDispenserEx **
                 ** CLSID_CorMetaDataDispenserRuntime  dtto                                      **
                 ** CLSID_CorRuntimeHost         IID_ICorRuntimeHost                             **
                 ** CLSID_CLRRuntimeHost         IID_ICLRRuntimeHost                             **
                 ** CLSID_TypeNameFactory        IID_ITypeNameFactory                            **
                 ** CLSID_CLRStrongName          IID_ICLRStrongName                              **
                 ** CLSID_CLRDebuggingLegacy     IID_ICorDebug                                   **
                 ** CLSID_CLRProfiling           IID_ICLRProfiling                               **
                 **                                                                              **
                 ** Supersedes: CorBindTo* and others                                            **
                 **********************************************************************************/
                HRESULT GetInterface(
                    [in]  REFCLSID rclsid,
                    [in]  REFIID   riid,
                    [out, iid_is(riid), retval] LPVOID *ppUnk);
            
                // Does not load runtime
            
                /**********************************************************************************
                 ** Returns TRUE if this runtime could be loaded into the current process. Note  **
                 ** that this method is side-effect free, and thus does not represent a			 **
                 ** commitment to be able to load this runtime if it sets *pbLoadable to be TRUE.**
                 ** Supersedes: none                                                             **
                 **********************************************************************************/
                HRESULT IsLoadable(
                    [out, retval] BOOL *pbLoadable);
            
                /**********************************************************************************
                 ** Sets startup flags and host config file that will be used at startup.        **
                 ** Supersedes: The startupFlags parameter in CorBindToRuntimeEx/Host            **
                 **********************************************************************************/
                HRESULT SetDefaultStartupFlags(
                    [in]  DWORD dwStartupFlags,
                    [in]  LPCWSTR pwzHostConfigFile);
            
                /**********************************************************************************
                 ** Gets startup flags and host config file that will be used at startup.        **
                 ** Supersedes: GetStartupFlags, GetHostConfigurationFile                        **
                 **********************************************************************************/
                HRESULT GetDefaultStartupFlags(
                    [out]      DWORD *pdwStartupFlags,
                    [out, size_is(*pcchHostConfigFile), annotation("_Out_writes_all_opt_(*pcchHostConfigFile)")]
                               LPWSTR pwzHostConfigFile, 
                    [in, out]  DWORD *pcchHostConfigFile);
            
                /**********************************************************************************
                 ** If not already bound (for example, with a useLegacyV2RuntimeActivationPolicy **
                 ** config setting), binds this runtime for all legacy V2 activation policy      **
                 ** decisions. If a different runtime was already bound to the legacy V2         **
                 ** activation policy, returns CLR_E_SHIM_LEGACYRUNTIMEALREADYBOUND. If this     **
                 ** runtime was already bound as the legacy V2 activation policy runtime,        **
                 ** returns S_OK.                                                                **
                 **********************************************************************************/
                HRESULT BindAsLegacyV2Runtime();
            
                /**********************************************************************************
                 ** Returns TRUE if the runtime has been started, i.e. Start() has been called.  **
                 ** If it has been started, its STARTUP_FLAGS are returned.                      **
                 **                                                                              **
                 ** IMPORTANT: This method is valid only for v4+ runtimes. This method will      **
                 ** return E_NOTIMPL for all pre-v4 runtimes.                                    **
                 **********************************************************************************/
                HRESULT IsStarted(
                    [out] BOOL *pbStarted,
                    [out] DWORD *pdwStartupFlags);
            };
            
              </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICLRRuntimeInfo.GetVersionString(System.Text.StringBuilder,System.UInt32@)">
            <summary>
            Returns the version of this runtime in the usual v-prefixed dotted form.
            Supersedes: GetRequestedRuntimeInfo, GetRequestedRuntimeVersion,
                GetCORVersion
            </summary>
            <param name="pwzBuffer"></param>
            <param name="pcchBuffer"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICLRRuntimeInfo.GetRuntimeDirectory(System.Text.StringBuilder,System.UInt32@)">
            <summary>
            Returns the directory where this runtime is installed.
            Supersedes: GetCORSystemDirectory
            </summary>
            <param name="pwzBuffer"></param>
            <param name="pcchBuffer"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICLRRuntimeInfo.IsLoaded(System.Void*,System.Int32*)">
            <summary>
            Returns TRUE if this runtime is loaded into the specified process.
            Supersedes: GetCORSystemDirectory
            </summary>
            <param name="hndProcess"></param>
            <param name="pbLoaded"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICLRRuntimeInfo.LoadErrorString(System.UInt32,System.UInt16*,System.UInt32*,System.Int32)">
            <summary>
            Translates an HRESULT value into an error message. Use iLocaleID -1 for the
            default culture of the current thread.
            Supersedes: LoadStringRC, LoadStringRCEx
            </summary>
            <param name="iResourceID"></param>
            <param name="pwzBuffer"></param>
            <param name="pcchBuffer"></param>
            <param name="iLocaleID"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICLRRuntimeInfo.LoadLibrary(System.UInt16*,System.Void**)">
            <summary>
            Loads a library located alongside this runtime.
            Supersedes: LoadLibraryShim
            </summary>
            <param name="pwzDllName"></param>
            <param name="phndModule"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICLRRuntimeInfo.GetProcAddress(System.Byte*,System.Void**)">
            <summary>
            Gets the address of the specified function exported from this runtime.
            It should NOT be documented what module the function lives in. We may want
            to implement some forwarding policy here. The reason for exposing
            GetProcAddress are functions like mscorwks!GetCLRIdentityManager.
            Supersedes: GetRealProcAddress
            </summary>
            <param name="pszProcName"></param>
            <param name="ppProc"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICLRRuntimeInfo.GetInterface(System.Guid*,System.Guid*,System.Void**)">
            <summary>
            Loads the runtime into the current process and returns an interface through
            which runtime functionality is provided.
            Supported CLSIDs/IIDs:
            CLSID_CorMetaDataDispenser   IID_IMetaDataDispenser,IID_IMetaDataDispenserEx
            CLSID_CorMetaDataDispenserRuntime  dtto
            CLSID_CorRuntimeHost         IID_ICorRuntimeHost
            CLSID_CLRRuntimeHost         IID_ICLRRuntimeHost
            CLSID_TypeNameFactory        IID_ITypeNameFactory
            CLSID_CLRStrongName          IID_ICLRStrongName
            CLSID_CLRDebuggingLegacy     IID_ICorDebug
            CLSID_CLRProfiling           IID_ICLRProfiling
            Supersedes: CorBindTo* and others
            </summary>
            <param name="rclsid"></param>
            <param name="riid"></param>
            <param name="ppUnk"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICLRRuntimeInfo.IsLoadable(System.Int32*)">
            <summary>
            Returns TRUE if this runtime could be loaded into the current process. Note
            that this method is side-effect free, and thus does not represent a
            commitment to be able to load this runtime if it sets *pbLoadable to be TRUE.
            Supersedes: none
            </summary>
            <param name="pbLoadable"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICLRRuntimeInfo.SetDefaultStartupFlags(System.UInt32,System.UInt16*)">
            <summary>
            Sets startup flags and host config file that will be used at startup.
            Supersedes: The startupFlags parameter in CorBindToRuntimeEx/Host
            </summary>
            <param name="dwStartupFlags"></param>
            <param name="pwzHostConfigFile"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICLRRuntimeInfo.GetDefaultStartupFlags(System.UInt32*,System.UInt16*,System.UInt32*)">
            <summary>
            Gets startup flags and host config file that will be used at startup.
            Supersedes: GetStartupFlags, GetHostConfigurationFile
            </summary>
            <param name="pdwStartupFlags"></param>
            <param name="pwzHostConfigFile"></param>
            <param name="pcchHostConfigFile"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICLRRuntimeInfo.BindAsLegacyV2Runtime">
            <summary>
            If not already bound (for example, with a useLegacyV2RuntimeActivationPolicy
            config setting), binds this runtime for all legacy V2 activation policy
            decisions. If a different runtime was already bound to the legacy V2
            activation policy, returns CLR_E_SHIM_LEGACYRUNTIMEALREADYBOUND. If this
            runtime was already bound as the legacy V2 activation policy runtime,
            returns S_OK.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICLRRuntimeInfo.IsStarted(System.Int32*,System.UInt32*)">
            <summary>
            Returns TRUE if the runtime has been started, i.e. Start() has been called.
            If it has been started, its STARTUP_FLAGS are returned.
            IMPORTANT: This method is valid only for v4+ runtimes. This method will
            return E_NOTIMPL for all pre-v4 runtimes.
            </summary>
            <param name="pbStarted"></param>
            <param name="pdwStartupFlags"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebug">
             <summary>
             ICorDebug represents an event processing loop for a debugger process.
            
             The debugger must wait for the ExitProcess callback from all
             processes being debugged before releasing this interface.
            
             The ICorDebug object is the initial object to control all further managed debugging.
             In v1.0 + v1.1, this object was a CoClass created from COM.
             In v2.0, this object is no longer a CoClass and must be created from the function:
                 CreateDebuggingInterfaceFromVersion(
                     int iDebuggerVersion, // &lt;--- CorDebugVersion_2_0 if Debugger is V2.0
                     LPCWSTR szDebuggeeVersion, // &lt;--- version string of debuggee. Eg, "v1.1.4322"
                     IUnknown ** ppCordb
                 )
             declared in mscoree.idl.
             This new creation function is more version-aware. It allows clients to get a
             specific implementation (as specified by szDebuggeeVersion) of ICorDebug, which
             also emulates a specific version of the debugging API (as specified by iDebuggerVersion).
             </summary>
             <example><code>[
                 object,
                 local,
                 uuid(3d6f5f61-7538-11d3-8d5b-00104b35e7ef),
                 pointer_default(unique)
             ]</code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebug.Initialize">
            <summary>
            The debugger calls this method at creation time to initialize the debugging
            services, and  must be called at creation time before any other method on ICorDebug is called.
            </summary>
            <example><code>HRESULT Initialize();</code></example>989875
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebug.Terminate">
             <summary>
             Terminate must be called when the ICorDebug is no longer needed.
            
             NOTE: Terminate should not be called until an ExitProcess callback has
             been received for all processes being debugged.
             
             This shuts down ICorDebug.
             All CordbProcess objects owned by this Cordb object must have either:
             - returned for a Detach() call
             - returned from dispatching the ExitProcess() callback.
             In both cases, CordbProcess::NeuterChildren has been called, although the Process object itself
             may not yet be neutered.  This condition will ensure that the CordbProcess objects don't need
             any resources that we're about to release.
             </summary>
             <example><code>HRESULT Terminate();</code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebug.SetManagedHandler(JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback)">
             <summary>
             SetManagedHandler should be called at creation time to specify the
             event handler object for managed events.
            
             Returns:
             S_OK on success.
             E_NOINTERFACE - if pCallback does not implement sufficient interfaces
                 to receive debug events for the version of the API it requested.
                 Eg, if debugging a V2.0 app, pCallback must implement ICorDebugManagedCallback2.
             </summary>
             <param name="pCallback"></param>
             <example><code>HRESULT SetManagedHandler([in] ICorDebugManagedCallback *pCallback);</code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebug.SetUnmanagedHandler(JetBrains.Debugger.CorApi.ComInterop.ICorDebugUnmanagedCallback)">
             <summary>
             SetUnmanagedHandler should be called at creation time to specify the
             event handler object for unmanaged events.
            
             This should be set after Initialize and before any calls to CreateProcess or DebugActiveProcess.
            
             However, for legacy purposes, it is not absolutely required to set this until
             before the first native debug event is fired. Specifically, if CreateProcess has the
             CREATE_SUSPENDED flag, native debug events will not be dispatched until the main thread
             is resumed.
             DebugActiveProcess will dispatch native debug events immediately, and so the unmanaged callback
             must be set before DebugActiveProcess is called.
            
             Returns:
                S_OK if callback pointer is successfully updated.
                failure on any failure.
             </summary>
             <param name="pCallback"></param>
             <example><code>HRESULT SetUnmanagedHandler([in] ICorDebugUnmanagedCallback *pCallback);</code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebug.CreateProcess(System.UInt16*,System.UInt16*,JetBrains.Interop.WinApi.SECURITY_ATTRIBUTES*,JetBrains.Interop.WinApi.SECURITY_ATTRIBUTES*,System.Int32,System.UInt32,System.Void*,System.UInt16*,JetBrains.Interop.WinApi.Declarations.Structures.STARTUPINFO*,JetBrains.Interop.WinApi.Declarations.Structures.PROCESS_INFORMATION*,JetBrains.Debugger.CorApi.ComInterop.CorDebugCreateProcessFlags,JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess@)">
             <summary>
             CreateProcess launches a process under the control of the debugger
             All parameters are the same as the win32 CreateProcess call.
            
             To enable unmanaged (mixed-mode) debugging, pass
             DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS to dwCreationFlags. DEBUG_PROCESS
             alone is not supported. If only managed debugging is desired, do not set
             these flags.
            
             The debugger and debuggee share a single console, then it's possible for
             the debuggee to hold "console locks" and then get stopped at a debug event.
             The debugger will then block trying to use the console. This is only an issue
             when interop debugging and if debugger + debuggee share the console.
             It is recommended to use the CREATE_NEW_CONSOLE flag to avoid this problem.
             </summary>
             <param name="lpApplicationName"></param>
             <param name="lpCommandLine"></param>
             <param name="lpProcessAttributes"></param>
             <param name="lpThreadAttributes"></param>
             <param name="bInheritHandles"></param>
             <param name="dwCreationFlags"></param>
             <param name="lpEnvironment"></param>
             <param name="lpCurrentDirectory"></param>
             <param name="lpStartupInfo"></param>
             <param name="lpProcessInformation"></param>
             <param name="debuggingFlags"></param>
             <param name="ppProcess"></param>
             <example><code>HRESULT CreateProcess([in] LPCWSTR lpApplicationName,
                                                  [in] LPWSTR lpCommandLine,
                                                  [in] LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                                  [in] LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                                  [in] BOOL bInheritHandles,
                                                  [in] DWORD dwCreationFlags,
                                                  [in] PVOID lpEnvironment,
                                                  [in] LPCWSTR lpCurrentDirectory,
                                                  [in] LPSTARTUPINFOW lpStartupInfo,
                                                  [in] LPPROCESS_INFORMATION lpProcessInformation,
                                                  [in] CorDebugCreateProcessFlags debuggingFlags,
                                                  [out] ICorDebugProcess **ppProcess);</code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebug.DebugActiveProcess(System.UInt32,System.Int32,JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess@)">
             <summary>
             DebugActiveProcess is used to attach to an existing process.
            
             If win32Attach is TRUE, then the debugger becomes the Win32
             debugger for the process and will begin dispatching the
             unmanaged callbacks.
             </summary>
             <param name="id"></param>
             <param name="win32Attach"></param>
             <param name="ppProcess"></param>
             <example>
             <code>HRESULT DebugActiveProcess([in] DWORD id,
                                              [in] BOOL win32Attach,
                                              [out] ICorDebugProcess **ppProcess);</code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebug.EnumerateProcesses(JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcessEnum@)">
            <summary>
            EnumerateProcesses returns an enum of processes being debugged.
            </summary>
            <param name="ppProcess"></param>
            <example><code>HRESULT EnumerateProcesses([out] ICorDebugProcessEnum **ppProcess);</code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebug.GetProcess(System.UInt32,JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess@)">
            <summary>
            GetProcess returns the ICorDebugProcess with the given OS Id.
            </summary>
            <param name="dwProcessId"></param>
            <param name="ppProcess"></param>
            <example>
            <code>HRESULT GetProcess([in] DWORD dwProcessId, [out] ICorDebugProcess **ppProcess);</code>
            </example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebug.CanLaunchOrAttach(System.UInt32,System.Int32)">
             <summary>
             CanLaunchOrAttach returns S_OK if the debugging services believe that
             launching a new process or attaching to the given process is possible
             given what it knows about the current machine and runtime configuration.
            
             If you plan to launch with win32 debugging enabled, or to attach with
             win32 debugging enabled then pass in TRUE for win32DebuggineEnabled.
             The answer may be different if this option will be used.
            
             Note: the rest of the API will not stop you from launching or attaching
             to a process anyway. This function is purely informational.
            
             Possible HRESULTs: S_OK, CORDBG_E_DEBUGGING_NOT_POSSIBLE,
             CORDBG_E_KERNEL_DEBUGGER_PRESENT, CORDBG_E_KERNEL_DEBUGGER_ENABLED
             </summary>
             <param name="dwProcessId"></param>
             <param name="win32DebuggingEnabled"></param>
             <example>
             <code>HRESULT CanLaunchOrAttach([in] DWORD dwProcessId, [in] BOOL win32DebuggingEnabled);</code>
             </example>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain">
            <summary>
            AppDomain interface
            </summary>
            <example><code>[
                object,
                local,
                uuid(3d6f5f63-7538-11d3-8d5b-00104b35e7ef),
                pointer_default(unique)
            ]</code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain.Stop(System.UInt32)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.Stop(System.UInt32)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain.Continue(System.Int32)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.Continue(System.Int32)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain.IsRunning(System.Int32*)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.IsRunning(System.Int32*)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain.HasQueuedCallbacks(JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread,System.Int32*)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.HasQueuedCallbacks(JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread,System.Int32*)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain.EnumerateThreads(JetBrains.Debugger.CorApi.ComInterop.ICorDebugThreadEnum@)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.EnumerateThreads(JetBrains.Debugger.CorApi.ComInterop.ICorDebugThreadEnum@)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain.SetAllThreadsDebugState(JetBrains.Debugger.CorApi.ComInterop.CorDebugThreadState,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.SetAllThreadsDebugState(JetBrains.Debugger.CorApi.ComInterop.CorDebugThreadState,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain.Detach">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.Detach"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain.Terminate(System.UInt32)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.Terminate(System.UInt32)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain.CanCommitChanges(System.UInt32,System.Void**,System.Void**)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.CanCommitChanges(System.UInt32,System.Void**,System.Void**)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain.CommitChanges(System.UInt32,System.Void**,System.Void**)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.CommitChanges(System.UInt32,System.Void**,System.Void**)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain.GetProcess(JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess@)">
            <summary>
            GetProcess returns the process containing the app domain
            </summary>
            <param name="ppProcess"></param>
            <example><code>HRESULT GetProcess([out] ICorDebugProcess **ppProcess);</code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain.EnumerateAssemblies(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAssemblyEnum@)">
            <summary>
            EnumerateAssemblies enumerates all assemblies in the app domain
            </summary>
            <param name="ppAssemblies"></param>
            <example><code>HRESULT EnumerateAssemblies([out] ICorDebugAssemblyEnum **ppAssemblies);</code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain.GetModuleFromMetaDataInterface(System.Object,JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule@)">
            <summary>
            GetModuleFromMetaDataInterface returns the ICorDebugModule with
            the given metadata interface.
            </summary>
            <param name="pIMetaData"></param>
            <param name="ppModule"></param>
            <example>
                <code>
                    HRESULT GetModuleFromMetaDataInterface([in] IUnknown *pIMetaData, [out] ICorDebugModule **ppModule);
                </code>
            </example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain.EnumerateBreakpoints(JetBrains.Debugger.CorApi.ComInterop.ICorDebugBreakpointEnum@)">
            <summary>
            EnumerateBreakpoints returns an enum (ICorDebugBreakpointEnum) of all active
            breakpoints in the app domain.  This includes all types of breakpoints :
            function breakpoints, data breakpoints, etc.
            </summary>
            <param name="ppBreakpoints"></param>
            <example><code>HRESULT EnumerateBreakpoints([out] ICorDebugBreakpointEnum **ppBreakpoints);</code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain.EnumerateSteppers(JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepperEnum@)">
            <summary>
            EnumerateSteppers returns an enum of all active steppers in the app domain.
            </summary>
            <param name="ppSteppers"></param>
            <example><code>HRESULT EnumerateSteppers([out] ICorDebugStepperEnum **ppSteppers);</code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain.IsAttached(System.Int32*)">
            <summary>
            DEPRECATED.  Always returns TRUE in V3 (attaching is process-wide).
            </summary>
            <param name="pbAttached"></param>
            <example><code>HRESULT IsAttached([out] BOOL *pbAttached);</code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain.GetName(System.UInt32,System.UInt32*,System.UInt16*)">
             <summary>
             GetName returns the name of the app domain.
            
             Usage pattern:
             *pcchName is always set to the length of pInputString (including NULL) in characters. This lets
               callers know the full size of buffer they'd need to allocate to get the full string.
            
             if (cchName == 0) then we're in "query" mode:
                 This fails if szName is non-null or pcchName is null
                 Else this function will set pcchName to let the caller know how large of a buffer to allocate
                 and return S_OK.
            
             if (cchName != 0) then
                 This fails if szName is null.
                 Else this copies as much as can fit into szName (it will always null terminate szName) and returns S_OK.
                 pcchName can be null. If it's non-null, we set it.
            
             The expected usage pattern is that a client will call once to get the size of a buffer needed for the name,
              allocate the buffer, and then call a 2nd time to fill in the buffer.
            
             The rest of the GetName() functions have the same semantics for the parameters unless otherwise noted.
             </summary>
             <param name="cchName"></param>
             <param name="pcchName"></param>
             <param name="szName"></param>
             <example>
                 <code>
             HRESULT GetName([in] ULONG32 cchName,
                            [out] ULONG32 *pcchName,
                            [out, size_is(cchName), length_is(*pcchName)] WCHAR szName[]);
                 </code>
             </example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain.GetObject(JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
             <summary>
             GetObject returns a reference to the System.AppDomain object which represents this AppDomain
             from within the runtime.
            
             Note: this object is lazily initialized within the runtime and may return NULL if the object
                   does not yet exist. This case will return S_FALSE and is not considered a failure.
             </summary>
             <param name="ppObject"></param>
             <example><code>HRESULT GetObject([out] ICorDebugValue **ppObject);</code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain.Attach">
            <summary>
            DEPRECATED.  This does nothing in V3.  Attaching is process-wide.
            </summary>
            <example><code>HRESULT Attach();</code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain.GetID(System.UInt32*)">
            <summary>
            Get the ID of this app domain. The ID will be unique within the
            containing process.
            </summary>
            <param name="pId"></param>
            <example><code>HRESULT GetID([out] ULONG32 *pId);</code></example>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain2">
            <summary>
            ICorDebugAppDomain2
            </summary>
            <example>
            <code>[
                object,
                local,
                uuid(096E81D5-ECDA-4202-83F5-C65980A9EF75),
                pointer_default(unique)
            ]</code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain2.GetArrayOrPointerType(JetBrains.Debugger.CorApi.ComInterop.CorElementType,System.UInt32,JetBrains.Debugger.CorApi.ComInterop.ICorDebugType,JetBrains.Debugger.CorApi.ComInterop.ICorDebugType@)">
            <summary>
            GetArrayOrPointerType returns an array, pointer, byref or function pointer type.
            elementType indicated the kind of type to be created and
            must be one of ELEMENT_TYPE_PTR, ELEMENT_TYPE_BYREF,
            ELEMENT_TYPE_ARRAY or ELEMENT_TYPE_SZARRAY.  If used with
            ELEMENT_TYPE_PTR or ELEMENT_TYPE_BYREF then nRank must be zero.
            </summary>
            <param name="elementType"></param>
            <param name="nRank"></param>
            <param name="pTypeArg"></param>
            <param name="ppType"></param>
            <example><code>HRESULT GetArrayOrPointerType([in] CorElementType elementType,
                                                         [in] ULONG32 nRank,
                                                         [in] ICorDebugType *pTypeArg,
                                                         [out] ICorDebugType **ppType);</code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain2.GetFunctionPointerType(System.UInt32,JetBrains.Debugger.CorApi.ComInterop.ICorDebugType[],JetBrains.Debugger.CorApi.ComInterop.ICorDebugType@)">
            <summary>
            GetFunctionPointerType returns a function pointer type.
            This corresponds to ELEMENT_TYPE_FNPTR.  The first type in the type arguments
            must be the return type and the remainder the argument types.
            </summary>
            <param name="nTypeArgs"></param>
            <param name="ppTypeArgs"></param>
            <param name="ppType"></param>
            <example><code>HRESULT GetFunctionPointerType([in] ULONG32 nTypeArgs,
                                                          [in, size_is(nTypeArgs)] ICorDebugType *ppTypeArgs[],
                                                          [out] ICorDebugType **ppType);</code></example>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain3">
            <summary>
            ICorDebugAppDomain3
            </summary>
            <example><code>[
                object,
                local,
                uuid(8CB96A16-B588-42E2-B71C-DD849FC2ECCC),
                pointer_default(unique)
            ]</code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain3.GetCachedWinRTTypesForIIDs(System.UInt32,System.Guid*,JetBrains.Debugger.CorApi.ComInterop.ICorDebugTypeEnum@)">
            <summary>
            Returns an enumeration of types corresponding to the IIDs passed in
            guidsToResolve. The enumeration will have the same cReqTypes elements
            with NULL values corresponding to unknown IIDs.
            </summary>
            <param name="cReqTypes"></param>
            <param name="iidsToResolve"></param>
            <param name="ppTypesEnum"></param>
            <example><code>
            HRESULT GetCachedWinRTTypesForIIDs(
                 [in]                      ULONG32              cReqTypes,
                 [in, size_is(cReqTypes)]  GUID               * iidsToResolve,
                 [out]                     ICorDebugTypeEnum ** ppTypesEnum);</code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain3.GetCachedWinRTTypes(JetBrains.Debugger.CorApi.ComInterop.ICorDebugGuidToTypeEnum@)">
            <summary>
            Returns an enumeration of IID / Type pairs. This is the exhaustive
            list of pairs as they were cached in the current app domain.
            </summary>
            <param name="ppGuidToTypeEnum"></param>
            <example><code>
            HRESULT GetCachedWinRTTypes(
                 [out] ICorDebugGuidToTypeEnum ** ppGuidToTypeEnum);</code></example>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain4">
            <summary>
            
            </summary>
            <example><code>
            [
                object,
                local,
                uuid(FB99CC40-83BE-4724-AB3B-768E796EBAC2),
                pointer_default(unique)
            ]
            interface ICorDebugAppDomain4 : IUnknown
            {
                /*
                 * gives back the managed object for a given CCW pointer
                 */
                HRESULT GetObjectForCCW([in]CORDB_ADDRESS ccwPointer, [out]ICorDebugValue **ppManagedObject);
            };
            </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain4.GetObjectForCCW(System.UInt64,JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            gives back the managed object for a given CCW pointer
            </summary>
            <param name="ccwPointer"></param>
            <param name="ppManagedObject"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomainEnum">
            <summary>
            </summary>
            <example><code>
             * AppDomainEnum interface
             * ------------------------------------------------------------------------- */
            
            [
                object,
                local,
                uuid(63ca1b24-4359-4883-bd57-13f815f58744),
                pointer_default(unique)
            ]
            
            interface ICorDebugAppDomainEnum : ICorDebugEnum
            {
                /*
                 * Gets the next "celt" app domains in the enumeration
                 */
                HRESULT Next([in] ULONG celt,
                             [out, size_is(celt), length_is(*pceltFetched)]
                                ICorDebugAppDomain *values[],
                             [out] ULONG *pceltFetched);
            
            }; </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomainEnum.Skip(System.UInt32)">
            <summary>
            Moves the current position forward the given number of elements.
            </summary>
            <param name="celt">the given number of elements</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomainEnum.Reset">
            <summary>
            Sets the position of the enumerator to the beginning of the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomainEnum.Clone(JetBrains.Debugger.CorApi.ComInterop.ICorDebugEnum@)">
            <summary>
            Creates another enumerator with the same current position as this one.
            </summary>
            <param name="ppEnum">another enumerator</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomainEnum.GetCount(System.UInt32*)">
            <summary>
            Gets the number of elements in the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomainEnum.Next(System.UInt32,System.Void**,System.UInt32*)">
            <summary>
            Gets the next "celt" app domains in the enumeration
            </summary>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugArrayValue">
             <summary>
             ICorDebugArrayValue is a subclass of ICorDebugValue which applies
             to values which contain an array. This interface supports both
             single and multidimension arrays.
             </summary>
             <example><code>
             /*
             * ICorDebugArrayValue is a subclass of ICorDebugValue which applies
             * to values which contain an array. This interface supports both
             * single and multidimension arrays.
             */
            
            [
                object,
                local,
                uuid(0405B0DF-A660-11d2-BD02-0000F80849BD),
                pointer_default(unique)
            ]
            interface ICorDebugArrayValue : ICorDebugHeapValue
            {
                /*
                 * GetElementType returns the simple type of the elements in the
                 * array.
                 */
            
                HRESULT GetElementType([out] CorElementType *pType);
            
                /*
                 * GetRank returns the number of dimensions in the array.
                 */
            
                HRESULT GetRank([out] ULONG32 *pnRank);
            
                /*
                 * GetCount returns the total number of elements in the array.
                 */
            
                HRESULT GetCount([out] ULONG32 *pnCount);
            
                /*
                 * GetDimensions returns the dimensions of the array.
                 */
            
                HRESULT GetDimensions([in] ULONG32 cdim,
                                      [out, size_is(cdim),
                                       length_is(cdim)] ULONG32 dims[]);
            
                /*
                 * HasBaseIndicies returns whether or not the array has base indicies.
                 * If the answer is no, then all dimensions have a base index of 0.
                 */
            
                HRESULT HasBaseIndicies([out] BOOL *pbHasBaseIndicies);
            
                /*
                 * GetBaseIndicies returns the base index of each dimension in
                 * the array
                 */
            
                HRESULT GetBaseIndicies([in] ULONG32 cdim,
                                        [out, size_is(cdim),
                                        length_is(cdim)] ULONG32 indicies[]);
            
                /*
                 * GetElement returns a value representing the given element in the array.
                 * The indices array must not be null.
                 */
            
                HRESULT GetElement([in] ULONG32 cdim,
                                   [in, size_is(cdim),
                                    length_is(cdim)] ULONG32 indices[],
                                   [out] ICorDebugValue **ppValue);
                /*
                 * GetElementAtPosition returns the element at the given position,
                 * treating the array as a zero-based, single-dimensional array.
                 *
                 * Multidimensional array layout follows the C++ style of array layout.
                 */
            
                HRESULT GetElementAtPosition([in] ULONG32 nPosition,
                                             [out] ICorDebugValue **ppValue);
            };
            
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugArrayValue.GetType(JetBrains.Debugger.CorApi.ComInterop.CorElementType*)">
            <summary>
            GetType returns the simple type of the value.  If the object
            has a more complex runtime type, that type may be examined through the
            appropriate subclasses (e.g. ICorDebugObjectValue can get the class of
            an object.)
            </summary>
            <param name="elementType"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugArrayValue.GetSize(System.UInt32*)">
            <summary>
            GetSize returns the size of the value in bytes. Note that for reference
            types this will be the size of the pointer rather than the size of
            the object.
            </summary>
            <param name="pSize"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugArrayValue.GetAddress(System.UInt64*)">
            <summary>
            GetAddress returns the address of the value in the debugee
            process.  This might be useful information for the debugger to
            show.
            If the value is unavailable, 0 is returned. This could happen if
            it is at least partly in registers or stored in a GC Handle.
            </summary>
            <param name="pAddress"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugArrayValue.CreateBreakpoint(JetBrains.Debugger.CorApi.ComInterop.ICorDebugValueBreakpoint@)">
            <summary>
            NOT YET IMPLEMENTED
            </summary>
            <param name="ppBreakpoint"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugArrayValue.IsValid(System.Int32*)">
            <summary>
            DEPRECATED.
                * All objects are only valid until Continue is called, at which time they are neutered.
            </summary>
            <param name="pbValid"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugArrayValue.GetElementType(JetBrains.Debugger.CorApi.ComInterop.CorElementType*)">
            <summary>
            GetElementType returns the simple type of the elements in the
            array.
            </summary>
            <param name="elementType"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugArrayValue.GetRank(System.UInt32*)">
            <summary>
            GetRank returns the number of dimensions in the array.
            </summary>
            <param name="pnRank"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugArrayValue.GetCount(System.UInt32*)">
            <summary>
            GetCount returns the total number of elements in the array.
            </summary>
            <param name="pnCount"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugArrayValue.GetDimensions(System.UInt32,System.UInt32*)">
            <summary>
            GetDimensions returns the dimensions of the array.
            </summary>
            <param name="cdim"></param>
            <param name="dims"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugArrayValue.HasBaseIndicies(System.Int32*)">
            <summary>
            HasBaseIndicies returns whether or not the array has base indicies.
            If the answer is no, then all dimensions have a base index of 0.
            </summary>
            <param name="pbHasBaseIndicies"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugArrayValue.GetBaseIndicies(System.UInt32,System.UInt32*)">
            <summary>
            GetBaseIndicies returns the base index of each dimension in
            the array
            </summary>
            <param name="cdim"></param>
            <param name="indicies"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugArrayValue.GetElement(System.UInt32,System.UInt32*,JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            GetElement returns a value representing the given element in the array.
            The indices array must not be null.
            </summary>
            <param name="cdim"></param>
            <param name="indices"></param>
            <param name="ppValue"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugArrayValue.GetElementAtPosition(System.UInt32,JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            GetElementAtPosition returns the element at the given position,
            treating the array as a zero-based, single-dimensional array.
            Multidimensional array layout follows the C++ style of array layout.
            </summary>
            <param name="nPosition"></param>
            <param name="ppValue"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAssembly">
            <summary>
             Assembly interface
             An ICorDebugAssembly instance corresponds to a a managed assembly loaded
             into a specific AppDomain in the CLR.  For assemblies shared between multiple
             AppDomains (eg. mscorlib), there will be a separate ICorDebugAssembly instance
             per AppDomain in which it is used.
            </summary>
            <example><code>
             * ------------------------------------------------------------------------- *
             * Assembly interface
             * An ICorDebugAssembly instance corresponds to a a managed assembly loaded
             * into a specific AppDomain in the CLR.  For assemblies shared between multiple
             * AppDomains (eg. mscorlib), there will be a separate ICorDebugAssembly instance
             * per AppDomain in which it is used.
             * ------------------------------------------------------------------------- */
            [
                object,
                local,
                uuid(df59507c-d47a-459e-bce2-6427eac8fd06),
                pointer_default(unique)
            ]
            
            interface ICorDebugAssembly : IUnknown
            {
                /*
                 * GetProcess returns the process containing the assembly
                 */
            
                HRESULT GetProcess([out] ICorDebugProcess **ppProcess);
            
                /*
                 * GetAppDomain returns the app domain containing the assembly.
                 */
            
                HRESULT GetAppDomain([out] ICorDebugAppDomain **ppAppDomain);
            
                /*
                 * EnumerateModules enumerates all modules in the assembly
                 *
                 */
            
                HRESULT EnumerateModules([out] ICorDebugModuleEnum **ppModules);
            
                /*
                 * NOT YET IMPLEMENTED
                 */
            
                HRESULT GetCodeBase([in] ULONG32 cchName,
                                    [out] ULONG32 *pcchName,
                                    [out, size_is(cchName),
                                    length_is(*pcchName)] WCHAR szName[]);
            
                /*
                 * GetName returns the full path and filename of the assembly.
                 * If the assembly has no filename (i.e. it is in-memory only),
                 * S_FALSE is returned, and a fabricated string is stored into szName. 
                 */
            
                HRESULT GetName([in] ULONG32 cchName,
                                [out] ULONG32 *pcchName,
                                [out, size_is(cchName),
                                length_is(*pcchName)] WCHAR szName[]);
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAssembly.GetProcess(JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess@)">
            <summary>
            GetProcess returns the process containing the assembly.
            </summary>
            <param name="ppProcess"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAssembly.GetAppDomain(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain@)">
            <summary>
            GetAppDomain returns the app domain containing the assembly.
            </summary>
            <param name="ppAppDomain"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAssembly.EnumerateModules(JetBrains.Debugger.CorApi.ComInterop.ICorDebugModuleEnum@)">
            <summary>
            EnumerateModules enumerates all modules in the assembly.
            </summary>
            <param name="ppModules"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAssembly.GetCodeBase(System.UInt32,System.UInt32*,System.UInt16*)">
            <summary>
            NOT YET IMPLEMENTED
            </summary>
            <param name="cchName"></param>
            <param name="pcchName"></param>
            <param name="szName"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAssembly.GetName(System.UInt32,System.UInt32*,System.UInt16*)">
            <summary>
            GetName returns the full path and filename of the assembly.
            If the assembly has no filename (i.e. it is in-memory only),
            S_FALSE is returned, and a fabricated string is stored into szName.
            </summary>
            <param name="cchName"></param>
            <param name="pcchName"></param>
            <param name="szName"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAssembly2">
            <summary>
            </summary>
            <example><code>
             [
                object,
                local,
                uuid(426d1f9e-6dd4-44c8-aec7-26cdbaf4e398),
                pointer_default(unique)
            ]
            interface ICorDebugAssembly2 : IUnknown
            {
                /*
                 * IsFullyTrusted sets a flag indicating whether the assembly has
                 * been granted full trust by the runtime security system.
                 * This may return CORDBG_E_NOTREADY if the security policy for
                 * the assembly has not yet been resolved (eg. no code in the
                 * assembly has been run yet).
                 */
                HRESULT IsFullyTrusted([out] BOOL *pbFullyTrusted);
            };
            
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAssembly2.IsFullyTrusted(System.Int32*)">
            <summary>
            IsFullyTrusted sets a flag indicating whether the assembly has
            been granted full trust by the runtime security system.
            This may return CORDBG_E_NOTREADY if the security policy for
            the assembly has not yet been resolved (eg. no code in the
            assembly has been run yet).
            </summary>
            <param name="pbFullyTrusted"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAssemblyEnum">
            <summary>
            </summary>
            <example><code>
             * AssemblyEnum interface
             * ------------------------------------------------------------------------- */
            
            [
                object,
                local,
                uuid(4a2a1ec9-85ec-4bfb-9f15-a89fdfe0fe83),
                pointer_default(unique)
            ]
            
            interface ICorDebugAssemblyEnum : ICorDebugEnum
            {
                /*
                 * Gets the next "celt" assemblies in the enumeration
                 */
                HRESULT Next([in] ULONG celt,
                             [out, size_is(celt), length_is(*pceltFetched)]
                                ICorDebugAssembly *values[],
                             [out] ULONG *pceltFetched);
            
            }; </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAssemblyEnum.Skip(System.UInt32)">
            <summary>
            Moves the current position forward the given number of elements.
            </summary>
            <param name="celt">the given number of elements</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAssemblyEnum.Reset">
            <summary>
            Sets the position of the enumerator to the beginning of the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAssemblyEnum.Clone(JetBrains.Debugger.CorApi.ComInterop.ICorDebugEnum@)">
            <summary>
            Creates another enumerator with the same current position as this one.
            </summary>
            <param name="ppEnum">another enumerator</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAssemblyEnum.GetCount(System.UInt32*)">
            <summary>
            Gets the number of elements in the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugAssemblyEnum.Next(System.UInt32,System.Void**,System.UInt32*)">
            <summary>
            Gets the next "celt" app domains in the enumeration
            </summary>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugBlockingObjectEnum">
            <summary>
            </summary>
            <example><code>
              /* ------------------------------------------------------------------------- *
             * BlockingObjectEnum interface
             * ------------------------------------------------------------------------- */
            
            [
                object,
                local,
                uuid(976A6278-134A-4a81-81A3-8F277943F4C3),
                pointer_default(unique)
            ]
            
            interface ICorDebugBlockingObjectEnum : ICorDebugEnum
            {
                /*
                 * Gets the next "celt" blocking objects in the enumeration
                 */
                HRESULT Next([in] ULONG celt,
                             [out, size_is(celt), length_is(*pceltFetched)]
                             CorDebugBlockingObject values[],
                             [out] ULONG *pceltFetched);
            
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugBlockingObjectEnum.Skip(System.UInt32)">
            <summary>
            Moves the current position forward the given number of elements.
            </summary>
            <param name="celt">the given number of elements</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugBlockingObjectEnum.Reset">
            <summary>
            Sets the position of the enumerator to the beginning of the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugBlockingObjectEnum.Clone(JetBrains.Debugger.CorApi.ComInterop.ICorDebugEnum@)">
            <summary>
            Creates another enumerator with the same current position as this one.
            </summary>
            <param name="ppEnum">another enumerator</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugBlockingObjectEnum.GetCount(System.UInt32*)">
            <summary>
            Gets the number of elements in the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugBlockingObjectEnum.Next(System.UInt32,System.Void**,System.UInt32*)">
            <summary>
            Gets the next "celt" blocking objects in the enumeration
            </summary>
            <param name="celt"></param>
            <param name="values"></param>
            <param name="pceltFetched"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugBoxValue">
            <summary>
             ICorDebugBoxValue is a subclass of ICorDebugValue which represents a boxed value class object.
            </summary>
            <example><code>
             
             /*
             * ICorDebugBoxValue is a subclass of ICorDebugValue which
             * represents a boxed value class object.
             */
            
            [
                object,
                local,
                uuid(CC7BCAFC-8A68-11d2-983C-0000F808342D),
                pointer_default(unique)
            ]
            interface ICorDebugBoxValue : ICorDebugHeapValue
            {
                /*
                 * GetObject returns the value object which is in the box.
                 */
            
                HRESULT GetObject([out] ICorDebugObjectValue **ppObject);
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugBoxValue.GetType(JetBrains.Debugger.CorApi.ComInterop.CorElementType*)">
            <summary>
            GetType returns the simple type of the value.  If the object
            has a more complex runtime type, that type may be examined through the
            appropriate subclasses (e.g. ICorDebugObjectValue can get the class of
            an object.)
            </summary>
            <param name="elementType"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugBoxValue.GetSize(System.UInt32*)">
            <summary>
            GetSize returns the size of the value in bytes. Note that for reference
            types this will be the size of the pointer rather than the size of
            the object.
            </summary>
            <param name="pSize"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugBoxValue.GetAddress(System.UInt64*)">
            <summary>
            GetAddress returns the address of the value in the debugee
            process.  This might be useful information for the debugger to
            show.
            If the value is unavailable, 0 is returned. This could happen if
            it is at least partly in registers or stored in a GC Handle.
            </summary>
            <param name="pAddress"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugBoxValue.CreateBreakpoint(JetBrains.Debugger.CorApi.ComInterop.ICorDebugValueBreakpoint@)">
            <summary>
            NOT YET IMPLEMENTED
            </summary>
            <param name="ppBreakpoint"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugBoxValue.IsValid(System.Int32*)">
            <summary>
            DEPRECATED.
                * All objects are only valid until Continue is called, at which time they are neutered.
            </summary>
            <param name="pbValid"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugBoxValue.GetObject(JetBrains.Debugger.CorApi.ComInterop.ICorDebugObjectValue@)">
            <summary>
            GetObject returns the value object which is in the box.
            </summary>
            <param name="ppObject"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugBreakpoint" -->
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugBreakpoint.Activate(System.Int32)">
            <summary>
            Sets the active state of the breakpoint.
            </summary>
            <param name="bActive"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugBreakpoint.IsActive(System.Int32*)">
            <summary>
            Returns whether the breakpoint is active.
            </summary>
            <param name="pbActive"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugBreakpointEnum">
            <summary>
            </summary>
            <example><code>
            [
                object,
                local,
                uuid(CC7BCB03-8A68-11d2-983C-0000F808342D),
                pointer_default(unique)
            ]
            
            interface ICorDebugBreakpointEnum : ICorDebugEnum
            {
                /*
                 * Gets the next "celt" number of breakpoints in the enumeration.
                 * The actual number of breakpoints retrieved is returned in "pceltFetched".
                 * Returns S_FALSE if the actual number of breakpoints retrieved is smaller
                 * than the number of breakpoints requested.
                 */
                HRESULT Next([in] ULONG celt,
                             [out, size_is(celt), length_is(*pceltFetched)]
                                ICorDebugBreakpoint *breakpoints[],
                             [out] ULONG *pceltFetched);
            }; </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugBreakpointEnum.Skip(System.UInt32)">
            <summary>
            Moves the current position forward the given number of elements.
            </summary>
            <param name="celt">the given number of elements</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugBreakpointEnum.Reset">
            <summary>
            Sets the position of the enumerator to the beginning of the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugBreakpointEnum.Clone(JetBrains.Debugger.CorApi.ComInterop.ICorDebugEnum@)">
            <summary>
            Creates another enumerator with the same current position as this one.
            </summary>
            <param name="ppEnum">another enumerator</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugBreakpointEnum.GetCount(System.UInt32*)">
            <summary>
            Gets the number of elements in the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugBreakpointEnum.Next(System.UInt32,System.Void**,System.UInt32*)">
            <summary>
            Gets the next "celt" number of breakpoints in the enumeration.
            The actual number of breakpoints retrieved is returned in "pceltFetched".
            Returns S_FALSE if the actual number of breakpoints retrieved is smaller than the number of breakpoints requested.
            </summary>
            <param name="celt"></param>
            <param name="breakpoints"></param>
            <param name="pceltFetched"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugChain">
            <summary>
             ICorDebugChain represents a segment of a physical or logical call
             stack.  All frames in a chain occupy contiguous stack space, and
             they share the same thread &amp; context.  A chain may represent either
             managed or unmanaged code. Chains may be empty. Unmanaged chains are
             always empty.
            </summary>
            <example><code>
             
             * ICorDebugChain represents a segment of a physical or logical call
             * stack.  All frames in a chain occupy contiguous stack space, and
             * they share the same thread &amp; context.  A chain may represent either
             * managed or unmanaged code. Chains may be empty. Unmanaged chains are
             * always empty.
             */
            
            [
                object,
                local,
                uuid(CC7BCAEE-8A68-11d2-983C-0000F808342D),
                pointer_default(unique)
            ]
            interface ICorDebugChain : IUnknown
            {
                /*
                 * GetThread returns the physical thread which this call chain is
                 * part of.
                 */
            
                HRESULT GetThread([out] ICorDebugThread **ppThread);
            
                /*
                 * GetStackRange returns the address range of the stack segment for the
                 * call chain.  Note that you cannot make any assumptions about
                 * what is actually stored on the stack - the numeric range is to compare
                 * stack frame locations only.
                 * The start of a stack range is the leafmost boundary of the chain, and 
                 * the end of a stack range is the rootmost boundary of the chain.
                 */
            
                HRESULT GetStackRange([out] CORDB_ADDRESS *pStart, [out] CORDB_ADDRESS *pEnd);
            
                /*
                 * NOT YET IMPLEMENTED
                 */
            
                HRESULT GetContext([out] ICorDebugContext **ppContext);
            
                /*
                 * GetCaller returns a pointer to the chain which called this
                 * chain.  Note that this may be a chain on another thread in the
                 * case of cross-thread-marshalled calls. The caller will be NULL
                 * for spontaneously called chains (e.g. the ThreadProc, a
                 * debugger initiated call, etc.)
                 */
            
                HRESULT GetCaller([out] ICorDebugChain **ppChain);
            
                /*
                 * GetCallee returns a pointer to the chain which this chain is
                 * waiting on before it resumes. Note that this may be a chain on
                 * another thread in the case of cross-thread-marshalled
                 * calls. The callee will be NULL if the chain is currently
                 * actively running.
                 */
            
                HRESULT GetCallee([out] ICorDebugChain **ppChain);
            
                /*
                 * GetPrevious returns a pointer to the chain which was on this
                 * thread before the current one was pushed, if there is one.
                 */
            
                HRESULT GetPrevious([out] ICorDebugChain **ppChain);
            
                /*
                 * GetNext returns a pointer to the chain which was pushed on this
                 * thread after the current one, if there is one.
                 */
            
                HRESULT GetNext([out] ICorDebugChain **ppChain);
            
                /*
                 * IsManaged returns whether or not the chain is running managed
                 * code.
                 */
            
                HRESULT IsManaged([out] BOOL *pManaged);
            
                /*
                 * These chains represent the physical call stack for the thread.
                 * EnumerateFrames returns an iterator which will list all the stack
                 * frames in the chain, starting at the active (most recent) one. This
                 * should be called only for managed chains.
                 *
                 * NOTE: The debugging API does not provide methods for obtaining
                 * frames contained in unmanaged chains. The debugger needs to use
                 * other means to obtain this information.
                 */
            
                HRESULT EnumerateFrames([out] ICorDebugFrameEnum **ppFrames);
            
                /*
                 * GetActiveFrame is a convenience routine to return the
                 * active (most recent) frame on the chain, if any.
                 *
                 * If the active frame is not available, the call will succeed
                 * and *ppFrame will be NULL. Active frames will not be available
                 * for all CHAIN_ENTER_UNMANAGED chains, and for some
                 * CHAIN_CLASS_INIT chains.
                 */
            
                HRESULT GetActiveFrame([out] ICorDebugFrame **ppFrame);
            
                /*
                 * GetRegisterSet returns the register set for the beginnning (the leafmost end)
                 * of the chain.
                 */
            
                HRESULT GetRegisterSet([out] ICorDebugRegisterSet **ppRegisters);
            
                /*
                 * GetReason returns the reason for the genesis of this calling chain.
                 */
            
                typedef enum CorDebugChainReason
                {
                    // Note that the first five line up with CorDebugIntercept
                    CHAIN_NONE              = 0x000,
                    CHAIN_CLASS_INIT        = 0x001,
                    CHAIN_EXCEPTION_FILTER  = 0x002,
                    CHAIN_SECURITY          = 0x004,
                    CHAIN_CONTEXT_POLICY    = 0x008,
                    CHAIN_INTERCEPTION      = 0x010,
                    CHAIN_PROCESS_START     = 0x020,
                    CHAIN_THREAD_START      = 0x040,
                    CHAIN_ENTER_MANAGED     = 0x080,
                    CHAIN_ENTER_UNMANAGED   = 0x100,
                    CHAIN_DEBUGGER_EVAL     = 0x200,
                    CHAIN_CONTEXT_SWITCH    = 0x400,
                    CHAIN_FUNC_EVAL         = 0x800,
                } CorDebugChainReason;
            
                HRESULT GetReason([out] CorDebugChainReason *pReason);
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugChain.GetThread(JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread@)">
            <summary>
            GetThread returns the physical thread which this call chain is
            part of.
            </summary>
            <param name="ppThread"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugChain.GetStackRange(System.UInt64*,System.UInt64*)">
            <summary>
            GetStackRange returns the address range of the stack segment for the
            call chain.  Note that you cannot make any assumptions about
            what is actually stored on the stack - the numeric range is to compare
            stack frame locations only.
            The start of a stack range is the leafmost boundary of the chain, and
            the end of a stack range is the rootmost boundary of the chain.
            </summary>
            <param name="pStart"></param>
            <param name="pEnd"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugChain.GetContext(JetBrains.Debugger.CorApi.ComInterop.ICorDebugContext@)">
            <summary>
            NOT YET IMPLEMENTED
            </summary>
            <param name="ppContext"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugChain.GetCaller(JetBrains.Debugger.CorApi.ComInterop.ICorDebugChain@)">
            <summary>
            GetCaller returns a pointer to the chain which called this
            chain.  Note that this may be a chain on another thread in the
            case of cross-thread-marshalled calls. The caller will be NULL
            for spontaneously called chains (e.g. the ThreadProc, a
            debugger initiated call, etc.)
            </summary>
            <param name="ppChain"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugChain.GetCallee(JetBrains.Debugger.CorApi.ComInterop.ICorDebugChain@)">
            <summary>
            GetCallee returns a pointer to the chain which this chain is
            waiting on before it resumes. Note that this may be a chain on
            another thread in the case of cross-thread-marshalled
            calls. The callee will be NULL if the chain is currently
            actively running.
            </summary>
            <param name="ppChain"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugChain.GetPrevious(JetBrains.Debugger.CorApi.ComInterop.ICorDebugChain@)">
            <summary>
            GetPrevious returns a pointer to the chain which was on this
            thread before the current one was pushed, if there is one.
            </summary>
            <param name="ppChain"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugChain.GetNext(JetBrains.Debugger.CorApi.ComInterop.ICorDebugChain@)">
            <summary>
            GetNext returns a pointer to the chain which was pushed on this
            thread after the current one, if there is one.
            </summary>
            <param name="ppChain"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugChain.IsManaged(System.Int32*)">
            <summary>
            IsManaged returns whether or not the chain is running managed
            code.
            </summary>
            <param name="pManaged"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugChain.EnumerateFrames(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrameEnum@)">
            <summary>
            These chains represent the physical call stack for the thread.
            EnumerateFrames returns an iterator which will list all the stack
            frames in the chain, starting at the active (most recent) one. This
            should be called only for managed chains.
            NOTE: The debugging API does not provide methods for obtaining
            frames contained in unmanaged chains. The debugger needs to use
            other means to obtain this information.
            </summary>
            <param name="ppFrames"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugChain.GetActiveFrame(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame@)">
            <summary>
            GetActiveFrame is a convenience routine to return the
            active (most recent) frame on the chain, if any.
            If the active frame is not available, the call will succeed
            and *ppFrame will be NULL. Active frames will not be available
            for all CHAIN_ENTER_UNMANAGED chains, and for some
            CHAIN_CLASS_INIT chains.
            </summary>
            <param name="ppFrame"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugChain.GetRegisterSet(JetBrains.Debugger.CorApi.ComInterop.ICorDebugRegisterSet@)">
            <summary>
            GetRegisterSet returns the register set for the beginnning (the leafmost end)
            of the chain.
            </summary>
            <param name="ppRegisters"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugChain.GetReason(JetBrains.Debugger.CorApi.ComInterop.CorDebugChainReason*)">
            <summary>
            GetReason returns the reason for the genesis of this calling chain.
            </summary>
            <param name="pReason"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugChainEnum">
            <summary>
            </summary>
            <example><code>
            [
                object,
                local,
                uuid(CC7BCB08-8A68-11d2-983C-0000F808342D),
                pointer_default(unique)
            ]
            interface ICorDebugChainEnum : ICorDebugEnum
            {
                /*
                 * Gets the next "celt" number of chains in the enumeration.
                 * The actual number of chains retrieved is returned in "pceltFetched".
                 * Returns S_FALSE if the actual number of chains retrieved is smaller
                 * than the number of chains requested.
                 */
                HRESULT Next([in] ULONG celt,
                             [out, size_is(celt), length_is(*pceltFetched)]
                                ICorDebugChain *chains[],
                             [out] ULONG *pceltFetched);
            }; </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugChainEnum.Skip(System.UInt32)">
            <summary>
            Moves the current position forward the given number of elements.
            </summary>
            <param name="celt">the given number of elements</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugChainEnum.Reset">
            <summary>
            Sets the position of the enumerator to the beginning of the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugChainEnum.Clone(JetBrains.Debugger.CorApi.ComInterop.ICorDebugEnum@)">
            <summary>
            Creates another enumerator with the same current position as this one.
            </summary>
            <param name="ppEnum">another enumerator</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugChainEnum.GetCount(System.UInt32*)">
            <summary>
            Gets the number of elements in the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugChainEnum.Next(System.UInt32,System.Void**,System.UInt32*)">
            <summary>
            Gets the next "celt" number of chains in the enumeration.
            The actual number of chains retrieved is returned in "pceltFetched".
            Returns S_FALSE if the actual number of chains retrieved is smaller than the number of chains requested.
            </summary>
            <param name="celt"></param>
            <param name="chains"></param>
            <param name="pceltFetched"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugClass">
            <summary>
             ICorDebugClass represents a Class (mdTypeDef) in the IL image.
             For generic types, it represents the generic type definition (eg. List&lt;T&gt;) not any of
             the specific instantiations (eg. List&lt;int&gt;).
             Use ICorDebugClass2::GetParameterizedType to build an ICorDebugType from an
             ICorDebugClass and type parameters.
             Classes live in a module and are uniquely identified by a mdTypeDef.
             In other words, you can round-trip a class like so:
                ICorDebugClass * pClass1 = ...; // some initial class
                ICorDebugModule * pModule = NULL;
                pClass1-&gt;GetModule(&amp;pModule);
                mdTypeDef token;
                pClass1-&gt;GetToken(&amp;token);
                ICorDebugClass * pClass2;
                pModule-&gt;GetClassFromToken(token, &amp;pClass2);
                // Now: pClass1 == pClass2
            </summary>
            <example><code>
             
             ICorDebugClass represents a Class (mdTypeDef) in the IL image.
             For generic types, it represents the generic type definition (eg. List&lt;T&gt;) not any of 
             the specific instantiations (eg. List&lt;int&gt;). 
             
             Use ICorDebugClass2::GetParameterizedType to build an ICorDebugType from an
             ICorDebugClass and type parameters.
            
             Classes live in a module and are uniquely identified by a mdTypeDef. 
             In other words, you can round-trip a class like so:
                ICorDebugClass * pClass1 = ...; // some initial class
                
                ICorDebugModule * pModule = NULL;    
                pClass1-&gt;GetModule(&amp;pModule);
            
                mdTypeDef token;
                pClass1-&gt;GetToken(&amp;token);
                
                ICorDebugClass * pClass2;
                pModule-&gt;GetClassFromToken(token, &amp;pClass2); 
                // Now: pClass1 == pClass2 
            
            */
            [
                object,
                local,
                uuid(CC7BCAF5-8A68-11d2-983C-0000F808342D),
                pointer_default(unique)
            ]
            interface ICorDebugClass : IUnknown
            {
                /*
                 * GetModule returns the module for the class.
                 */
            
                HRESULT GetModule([out] ICorDebugModule **pModule);
            
                /*
                 * GetTypeDefToken returns the metadata typedef token for the class.
                 */
            
                HRESULT GetToken([out] mdTypeDef *pTypeDef);
            
                /*
                 * GetStaticFieldValue returns a value object (ICorDebugValue) for the given static field
                 * variable. If the static field could possibly be relative to either
                 * a thread, context, or appdomain, then pFrame will help the debugger
                 * determine the proper value.
                 *
                 * Note that if the class accepts type parameters, then you should
                 * use GetStaticField on an appropriate ICorDebugType rather than on the
                 * ICorDebugClass.
                 * 
                 * Returns:
                 *  S_OK on success.
                 *  CORDBG_E_FIELD_NOT_STATIC if the field is not static.
                 *  CORDBG_E_STATIC_VAR_NOT_AVAILABLE if field is not yet available (storage for statics
                 *    may be lazily allocated). 
                 *  CORDBG_E_VARIABLE_IS_ACTUALLY_LITERAL if the field is actually a metadata literal. In this
                 *    case, the debugger should get the value from the metadata.
                 *  error on other errors.
                 */
            
                HRESULT GetStaticFieldValue([in] mdFieldDef fieldDef,
                                            [in] ICorDebugFrame *pFrame,
                                            [out] ICorDebugValue **ppValue);
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugClass.GetModule(JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule@)">
            <summary>
            GetModule returns the module for the class.
            </summary>
            <param name="pModule"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugClass.GetToken(System.UInt32*)">
            <summary>
            GetTypeDefToken returns the metadata typedef token for the class.
            </summary>
            <param name="pTypeDef"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugClass.GetStaticFieldValue(System.UInt32,JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame,JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            GetStaticFieldValue returns a value object (ICorDebugValue) for the given static field
            variable. If the static field could possibly be relative to either
            a thread, context, or appdomain, then pFrame will help the debugger
            determine the proper value.
            Note that if the class accepts type parameters, then you should
            use GetStaticField on an appropriate ICorDebugType rather than on the
            ICorDebugClass.
            Returns:
             S_OK on success.
             CORDBG_E_FIELD_NOT_STATIC if the field is not static.
             CORDBG_E_STATIC_VAR_NOT_AVAILABLE if field is not yet available (storage for statics
               may be lazily allocated).
             CORDBG_E_VARIABLE_IS_ACTUALLY_LITERAL if the field is actually a metadata literal. In this
               case, the debugger should get the value from the metadata.
             error on other errors.
            </summary>
            <param name="fieldDef"></param>
            <param name="pFrame"></param>
            <param name="ppValue"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugClass2">
            <summary>
            </summary>
            <example><code>
             
            [
                object,
                local,
                uuid(B008EA8D-7AB1-43f7-BB20-FBB5A04038AE),
                pointer_default(unique)
            ]
            interface ICorDebugClass2 : IUnknown
            {
                /*
                 * GetParameterizedType returns a type that corresponds to this class.
                 *
                 * If the class is non-generic, i.e. has no type parameters, then
                 * this simply gets the type object corresponding to the class.
                 * elementType should be set to the correct element type for the
                 * class, i.e. ELEMENT_TYPE_VALUETYPE if the class is a value type
                 * otherwise ELEMENT_TYPE_CLASS.
                 *
                 * If the class accepts type parameters, e.g. ArrayList&lt;T&gt;, then
                 * this function can be used to construct a type object for an
                 * instantiated type such as ArrayList&lt;int&gt;.
                 */
                HRESULT GetParameterizedType([in] CorElementType elementType,
                                             [in] ULONG32 nTypeArgs,
                                             [in, size_is(nTypeArgs)] ICorDebugType *ppTypeArgs[],
                                             [out] ICorDebugType **ppType);
            
                /*
                 * Sets the User-code status (for JMC stepping) for all methods
                 * in this class. This is functionally equivalent to setting the
                 * JMCStatus onall methods in this class.
                 * A JMC stepper will skip non-user code.
                 * User code must be a subset of debuggable code.
                 *
                 * Returns S_OK if all methods are set succesfully.
                 * Return failure if any are not set.
                 * On failure, some may still be set.
                 */
                HRESULT SetJMCStatus([in] BOOL bIsJustMyCode);
            
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugClass2.GetParameterizedType(JetBrains.Debugger.CorApi.ComInterop.CorElementType,System.UInt32,System.Void**,System.Void**)">
            <summary>
            GetParameterizedType returns a type that corresponds to this class.
            If the class is non-generic, i.e. has no type parameters, then
            this simply gets the type object corresponding to the class.
            elementType should be set to the correct element type for the
            class, i.e. ELEMENT_TYPE_VALUETYPE if the class is a value type
            otherwise ELEMENT_TYPE_CLASS.
            If the class accepts type parameters, e.g. ArrayList&lt;T&gt;, then
            this function can be used to construct a type object for an
            instantiated type such as ArrayList&lt;int&gt;.
            </summary>
            <param name="elementType"></param>
            <param name="nTypeArgs"></param>
            <param name="ppTypeArgs"></param>
            <param name="ppType"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugClass2.SetJMCStatus(System.Int32)">
            <summary>
            Sets the User-code status (for JMC stepping) for all methods
            in this class. This is functionally equivalent to setting the
            JMCStatus onall methods in this class.
            A JMC stepper will skip non-user code.
            User code must be a subset of debuggable code.
            Returns S_OK if all methods are set succesfully.
            Return failure if any are not set.
            On failure, some may still be set.
            </summary>
            <param name="bIsJustMyCode"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode">
            <summary>
             ICorDebugCode represents an IL or native code blob.
             For methods that take offsets, the units are the same as the units on the CordbCode object.
             (eg, IL offsets for an IL code object, and native offsets for a native code object)
             V2 allows multiple code-regions. CordbCode presents an abstraction where these
             are merged together in a single linear, continuous space. So if the code is split
             with 0x5 bytes at address 0x1000, and 0x10 bytes at address 0x2000,
             then:
             - GetAddress() yields a start address of 0x1000.
             - GetSize() is the size of the merged regions = 0x5+ 0x10 = 0x15 bytes.
             - The (Offset --&gt; Address) mapping is:
                    0x0  --&gt; 0x1000
                    0x1  --&gt; 0x1001
                    0x4  --&gt; 0x1004
                    0x5  --&gt; 0x2000
                    0x6  --&gt; 0x2001
                    0x15 --&gt; 0x2010
             A caller can get the specific code regions via ICorDebugCode2.
            </summary>
            <example><code>
             
             /*
                ICorDebugCode represents an IL or native code blob.
             
                For methods that take offsets, the units are the same as the units on the CordbCode object.
                (eg, IL offsets for an IL code object, and native offsets for a native code object)
             
                V2 allows multiple code-regions. CordbCode presents an abstraction where these
                are merged together in a single linear, continuous space. So if the code is split
                with 0x5 bytes at address 0x1000, and 0x10 bytes at address 0x2000, 
                then:
                - GetAddress() yields a start address of 0x1000.
                - GetSize() is the size of the merged regions = 0x5+ 0x10 = 0x15 bytes.
                - The (Offset --&gt; Address) mapping is:
                       0x0  --&gt; 0x1000
                       0x1  --&gt; 0x1001
                       0x4  --&gt; 0x1004
                       0x5  --&gt; 0x2000
                       0x6  --&gt; 0x2001
                       0x15 --&gt; 0x2010
            
                A caller can get the specific code regions via ICorDebugCode2.
            */
            [
                object,
                local,
                uuid(CC7BCAF4-8A68-11d2-983C-0000F808342D),
                pointer_default(unique)
            ]
            interface ICorDebugCode : IUnknown
            {
                /*
                 * IsIL returns whether the code is IL (as opposed to native.)
                 */
            
                HRESULT IsIL([out] BOOL *pbIL);
            
                /*
                 * GetFunction returns the function for the code.
                 */
            
                HRESULT GetFunction([out] ICorDebugFunction **ppFunction);
            
                /*
                 * GetAddress returns the address of the code.
                 */
            
                HRESULT GetAddress([out] CORDB_ADDRESS *pStart);
            
                /*
                 * GetSize returns the size in bytes of the code.
                 */
            
                HRESULT GetSize([out] ULONG32 *pcBytes);
            
                /*
                 * CreateBreakpoint creates a breakpoint in the function at the
                 * given offset. 
                 *
                 * If this code is IL code, and there is a jitted native version
                 * of the code, the breakpoint will be applied in the jitted code
                 * as well.  (The same is true if the code is later jitted.)
                 *
                 */
            
                HRESULT CreateBreakpoint([in] ULONG32 offset,
                                         [out] ICorDebugFunctionBreakpoint **ppBreakpoint);
            
                /*
                 * GetCode returns the code of the method, suitable for disassembly.  Note
                 * that instruction boundaries aren't checked.
                 * This glues together multiple code-regions into a single binary stream.
                 * Caller must use ICorDebugCode2::GetCodeChunks to get (start,size) for
                 * code chunks to be able to properly resolve addresses embedded in the instructions.
                 */
            
                HRESULT GetCode([in] ULONG32 startOffset, [in] ULONG32 endOffset,
                                [in] ULONG32 cBufferAlloc,
                                [out, size_is(cBufferAlloc),
                                      length_is(*pcBufferSize)] BYTE buffer[],
                                [out] ULONG32 *pcBufferSize);
            
                /*
                 * GetVersionNumber returns the 1 based number identifying the
                 * version of the code that this ICorDebugCode corresponds to.  The
                 * version number is incremented each time the function is Edit-And-
                 * Continue'd.
                 */
            
                HRESULT GetVersionNumber([out] ULONG32 *nVersion);
            
                /*
                 * GetILToNativeMapping returns a map from IL offsets to native
                 * offsets for this code. An array of COR_DEBUG_IL_TO_NATIVE_MAP
                 * structs will be returned, and some of the ilOffsets in this array
                 * map be the values specified in CorDebugIlToNativeMappingTypes.
                 *
                 * Note: this method is only valid for ICorDebugCodes representing
                 * native code that was jitted from IL code.
                 * Note: There is no ordering to the array of elements returned, nor
                 * should you assume that there is or will be.
                 */
                HRESULT GetILToNativeMapping([in] ULONG32 cMap,
                                             [out] ULONG32 *pcMap,
                                             [out, size_is(cMap), length_is(*pcMap)]
                                             COR_DEBUG_IL_TO_NATIVE_MAP map[]);
            
                /*
                 * Not implemented.
                 */
                HRESULT GetEnCRemapSequencePoints([in] ULONG32 cMap,
                                                  [out] ULONG32 *pcMap,
                                                  [out, size_is(cMap), length_is(*pcMap)]
                                                  ULONG32 offsets[]);
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode.IsIL(System.Int32*)">
            <summary>
            IsIL returns whether the code is IL (as opposed to native.)
            </summary>
            <param name="pbIL"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode.GetFunction(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction@)">
            <summary>
            GetFunction returns the function for the code.
            </summary>
            <param name="ppFunction"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode.GetAddress(System.UInt64*)">
            <summary>
            GetAddress returns the address of the code.
            </summary>
            <param name="pStart"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode.GetSize(System.UInt32*)">
            <summary>
            GetSize returns the size in bytes of the code.
            </summary>
            <param name="pcBytes"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode.CreateBreakpoint(System.UInt32,JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunctionBreakpoint@)">
            <summary>
            CreateBreakpoint creates a breakpoint in the function at the
            given offset.
            If this code is IL code, and there is a jitted native version
            of the code, the breakpoint will be applied in the jitted code
            as well.  (The same is true if the code is later jitted.)
            </summary>
            <param name="offset"></param>
            <param name="ppBreakpoint"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode.GetCode(System.UInt32,System.UInt32,System.UInt32,System.Byte*,System.UInt32*)">
            <summary>
            GetCode returns the code of the method, suitable for disassembly.  Note
            that instruction boundaries aren't checked.
            This glues together multiple code-regions into a single binary stream.
            Caller must use ICorDebugCode2::GetCodeChunks to get (start,size) for
            code chunks to be able to properly resolve addresses embedded in the instructions.
            </summary>
            <param name="startOffset"></param>
            <param name="endOffset"></param>
            <param name="cBufferAlloc"></param>
            <param name="buffer"></param>
            <param name="pcBufferSize"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode.GetVersionNumber(System.UInt32*)">
            <summary>
            GetVersionNumber returns the 1 based number identifying the
            version of the code that this ICorDebugCode corresponds to.  The
            version number is incremented each time the function is Edit-And-
            Continue'd.
            </summary>
            <param name="nVersion"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode.GetILToNativeMapping(System.UInt32,System.UInt32*,JetBrains.Debugger.CorApi.ComInterop.COR_DEBUG_IL_TO_NATIVE_MAP*)">
            <summary>
            GetILToNativeMapping returns a map from IL offsets to native
            offsets for this code. An array of COR_DEBUG_IL_TO_NATIVE_MAP
            structs will be returned, and some of the ilOffsets in this array
            map be the values specified in CorDebugIlToNativeMappingTypes.
            Note: this method is only valid for ICorDebugCodes representing
            native code that was jitted from IL code.
            Note: There is no ordering to the array of elements returned, nor
            should you assume that there is or will be.
            </summary>
            <param name="cMap"></param>
            <param name="pcMap"></param>
            <param name="map"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode.GetEnCRemapSequencePoints(System.UInt32,System.UInt32*,System.UInt32*)">
            <summary>
            Not implemented.
            </summary>
            <param name="cMap"></param>
            <param name="pcMap"></param>
            <param name="offsets"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode2">
            <summary>
            </summary>
            <example><code>
             
            [
                object,
                local,
                uuid(5F696509-452F-4436-A3FE-4D11FE7E2347),
                pointer_default(unique)
            ]
            interface ICorDebugCode2 : IUnknown
            {
                typedef struct _CodeChunkInfo
                {
                    CORDB_ADDRESS startAddr;
                    ULONG32 length;
                } CodeChunkInfo;
            
                // The native code for a code object may be split up into multiple regions.
                //
                HRESULT GetCodeChunks(
                    [in] ULONG32 cbufSize,
                    [out] ULONG32 * pcnumChunks,
                    [out, size_is(cbufSize), length_is(*pcnumChunks)] CodeChunkInfo chunks[]);
            
            
               // GetCompilerFlags returns the flags under which this piece of code was JITted or NGENed.
            
               HRESULT GetCompilerFlags( [out] DWORD *pdwFlags );
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode2.GetCodeChunks(System.UInt32,System.UInt32*,JetBrains.Debugger.CorApi.ComInterop.CodeChunkInfo*)">
            <summary>
            The native code for a code object may be split up into multiple regions.
            </summary>
            <param name="cbufSize"></param>
            <param name="pcnumChunks"></param>
            <param name="chunks"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode2.GetCompilerFlags(System.UInt32*)">
            <summary>
            GetCompilerFlags returns the flags under which this piece of code was JITted or NGENed.
            </summary>
            <param name="pdwFlags"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode3">
            <summary>
            </summary>
            <example><code>
            [
                object,
                local,
                uuid(D13D3E88-E1F2-4020-AA1D-3D162DCBE966),
                pointer_default(unique)
            ]
            interface ICorDebugCode3 : IUnknown
            {
                /*
                 *  For the specified IL offset, obtains the native offset where a breakpoint should
                 *  be placed so that the debugger can obtain the return value from a function.
                 *  The provided IL offset should be at a function call site, if not the API will fail.
                 *  If the function call doesn't return a value the API will fail.
                 *
                 *  Returns:
                 *    S_OK - on success.
                 *    CORDBG_E_INVALID_OPCODE - If the given IL offset site was not a call instruction
                 *                              or if the function returns "void".
                 *    CORDBG_E_UNSUPPORTED - If the given IL offset is a proper call, but the return
                 *                           type is unsupported for getting return value.
                 */
                HRESULT GetReturnValueLiveOffset([in] ULONG32 ILoffset,
                                                 [in] ULONG32 bufferSize,
                                                 [out] ULONG32 *pFetched,
                                                 [out, size_is(bufferSize), length_is(*pFetched)] ULONG32 pOffsets[]);
            };
            </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode3.GetReturnValueLiveOffset(System.UInt32,System.UInt32,System.UInt32*,System.Int32*)">
             <summary>
             For the specified IL offset, obtains the native offset where a breakpoint should
             be placed so that the debugger can obtain the return value from a function.
             The provided IL offset should be at a function call site, if not the API will fail.
             If the function call doesn't return a value the API will fail.
            
             Returns:
               S_OK - on success.
               CORDBG_E_INVALID_OPCODE - If the given IL offset site was not a call instruction
                                         or if the function returns "void".
               CORDBG_E_UNSUPPORTED - If the given IL offset is a proper call, but the return
                                      type is unsupported for getting return value.
             </summary>
             <param name="ILoffset"></param>
             <param name="bufferSize"></param>
             <param name="pFetched"></param>
             <param name="pOffsets"></param>
             <returns></returns>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugCodeEnum">
            <summary>
            </summary>
            <example><code>
            [
                object,
                local,
                uuid(55E96461-9645-45e4-A2FF-0367877ABCDE),
                pointer_default(unique)
            ]
            interface ICorDebugCodeEnum : ICorDebugEnum
            {
                /*
                 * Gets the next "celt" number of code objects in the enumeration.
                 * The actual number of code objects retrieved is returned in "pceltFetched".
                 * Returns S_FALSE if the actual number of code objects retrieved is smaller
                 * than the number of code objects requested.
                 */
                HRESULT Next([in] ULONG celt,
                             [out, size_is(celt), length_is(*pceltFetched)]
                                ICorDebugCode *values[],
                             [out] ULONG *pceltFetched);
            }; </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugCodeEnum.Skip(System.UInt32)">
            <summary>
            Moves the current position forward the given number of elements.
            </summary>
            <param name="celt">the given number of elements</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugCodeEnum.Reset">
            <summary>
            Sets the position of the enumerator to the beginning of the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugCodeEnum.Clone(JetBrains.Debugger.CorApi.ComInterop.ICorDebugEnum@)">
            <summary>
            Creates another enumerator with the same current position as this one.
            </summary>
            <param name="ppEnum">another enumerator</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugCodeEnum.GetCount(System.UInt32*)">
            <summary>
            Gets the number of elements in the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugCodeEnum.Next(System.UInt32,System.Void**,System.UInt32*)">
            <summary>
            Gets the next "celt" number of code objects in the enumeration.
            The actual number of code objects retrieved is returned in "pceltFetched".
            Returns S_FALSE if the actual number of code objects retrieved is smaller than the number of code objects requested. .
            </summary>
            <param name="celt"></param>
            <param name="values"></param>
            <param name="pceltFetched"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugComObjectValue">
            <summary>
             ICorDebugComObjectValue applies to values which contain a COM object.
             An ICorDebugComObjectValue becomes invalid after the debuggee is continued.
            </summary>
            <example><code>
             
             /*
             * ICorDebugComObjectValue applies to values which contain a COM object.
             * An ICorDebugComObjectValue becomes invalid after the debuggee is continued.
             */
            
            [
                object,
                local,
                uuid(5F69C5E5-3E12-42DF-B371-F9D761D6EE24),
                pointer_default(unique)
            ]
            interface ICorDebugComObjectValue : IUnknown
            {
                /*
                 * GetCachedInterfaceTypes returns an enum of the types of all interfaces
                 * that are cached by the COM object.
                 */
                HRESULT GetCachedInterfaceTypes(
                                    [in] BOOL bIInspectableOnly, 
                                    [out] ICorDebugTypeEnum **ppInterfacesEnum);
            
                /*
                 * GetCachedInterfacePointers returns at most celt values of the
                 * interface pointer values cached by the COM object. It fills
                 * pcEltFetched with the actual number of fetched elements. 
                 * When called with NULL for ptrs, and 0 for celt, it simply returns
                 * the number of elements it needs.
                 */
                HRESULT GetCachedInterfacePointers(
                                    [in] BOOL bIInspectableOnly, 
                                    [in] ULONG32 celt,
                                    [out] ULONG32 *pcEltFetched,
                                    [out, size_is(celt), length_is(*pcEltFetched)] CORDB_ADDRESS * ptrs);
            };
            
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugComObjectValue.GetCachedInterfaceTypes(System.Int32,JetBrains.Debugger.CorApi.ComInterop.ICorDebugTypeEnum@)">
            <summary>
            GetCachedInterfaceTypes returns an enum of the types of all interfaces
            that are cached by the COM object.
            </summary>
            <param name="bIInspectableOnly"></param>
            <param name="ppInterfacesEnum"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugComObjectValue.GetCachedInterfacePointers(System.Int32,System.UInt32,System.UInt32*,System.UInt64*)">
            <summary>
            GetCachedInterfacePointers returns at most celt values of the
            interface pointer values cached by the COM object. It fills
            pcEltFetched with the actual number of fetched elements.
            When called with NULL for ptrs, and 0 for celt, it simply returns
            the number of elements it needs.
            </summary>
            <param name="bIInspectableOnly"></param>
            <param name="celt"></param>
            <param name="pceltFetched"></param>
            <param name="ptrs"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugContext" -->
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugContext.GetType(JetBrains.Debugger.CorApi.ComInterop.CorElementType*)">
            <summary>
            GetType returns the simple type of the value.  If the object
            has a more complex runtime type, that type may be examined through the
            appropriate subclasses (e.g. ICorDebugObjectValue can get the class of
            an object.)
            </summary>
            <param name="elementType"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugContext.GetSize(System.UInt32*)">
            <summary>
            GetSize returns the size of the value in bytes. Note that for reference
            types this will be the size of the pointer rather than the size of
            the object.
            </summary>
            <param name="pSize"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugContext.GetAddress(System.UInt64*)">
            <summary>
            GetAddress returns the address of the value in the debugee
            process.  This might be useful information for the debugger to
            show.
            If the value is unavailable, 0 is returned. This could happen if
            it is at least partly in registers or stored in a GC Handle.
            </summary>
            <param name="pAddress"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugContext.CreateBreakpoint(JetBrains.Debugger.CorApi.ComInterop.ICorDebugValueBreakpoint@)">
            <summary>
            NOT YET IMPLEMENTED
            </summary>
            <param name="ppBreakpoint"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugContext.GetClass(JetBrains.Debugger.CorApi.ComInterop.ICorDebugClass@)">
            <summary>
            GetClass returns the runtime class of the object in the value.
            </summary>
            <param name="ppClass"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugContext.GetFieldValue(JetBrains.Debugger.CorApi.ComInterop.ICorDebugClass,System.UInt32,JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            GetFieldValue returns a value for the given field in the given
            class. The class must be on the class hierarchy of the object's
            class, and the field must be a field of that class.
            </summary>
            <param name="pClass"></param>
            <param name="fieldDef"></param>
            <param name="ppValue"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugContext.GetVirtualMethod(System.UInt32,JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction@)">
            <summary>
            NOT YET IMPLEMENTED
            </summary>
            <param name="memberRef"></param>
            <param name="ppFunction"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugContext.GetContext(JetBrains.Debugger.CorApi.ComInterop.ICorDebugContext@)">
            <summary>
            NOT YET IMPLEMENTED
            </summary>
            <param name="ppContext"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugContext.IsValueClass(System.Int32*)">
            <summary>
            IsValueClass returns true if the the class of this object is
            a value class.
            </summary>
            <param name="pbIsValueClass"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugContext.GetManagedCopy(System.Void**)">
            <summary>
            DEPRECATED
            </summary>
            <param name="ppObject"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugContext.SetFromManagedCopy(System.Void**)">
            <summary>
            DEPRECATED
            </summary>
            <param name="pObject"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController">
             <summary>
             ICorDebugController represents a scope at which program execution context
             can be controlled.  It represents either a process or an app domain.
            
             If this is the controller of a process, this controller affects all
             threads in the process.  Otherwise it just affects the threads of
             a particular app domain
             </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.Stop(System.UInt32)">
             <summary>
             Stop performs a cooperative stop on all threads running managed
             code in the process. When managed-only debugging, unmanaged threads may continue
             to run (but will be blocked when trying to call managed code). When-interop debugging,
             unmanaged threads will also be stopped.
             The timeout value is currently ignored and treated as INFINTE (-1).
             If the cooperative stop fails due to a deadlock, all threads are suspended (and E_TIMEOUT is returned)
            
             NOTE: This function is the one function in the debugging API
             that is synchronous. When Stop returns with S_OK, the process
             is stopped. (No callback will be given to notify of the stop.)
             The debugger must call Continue when it wishes to allow
             the process to resume running.
            
             The debugger maintains a "stop-counter". When the counter goes to zero, the
             Controller is resumed. Each call to Stop() or each dispatched callback will increment
             the counter. Each call to continue will decrement the counter.
             </summary>
             <param name="dwTimeoutIgnored"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.Continue(System.Int32)">
             <summary>
             Continue continues the process after a call to Stop.
            
             Continue continues the process. fIsOutOfBand is set to TRUE
             if continuing from an unmanaged event that was sent with the
             fOutOfBand flag in the unmanaged callback and it is set to
             FALSE if continuing from a managed event or a normal
             unmanaged event.
            
             When doing mixed-mode debugging, Continue cannot be called on
             the Win32 Event Thread unless it is continuing from an
             out-of-band event.
             </summary>
             <param name="fIsOutOfBand"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.IsRunning(System.Int32*)">
            <summary>
            IsRunning returns TRUE if the threads in the process are running freely.
            </summary>
            <param name="pbRunning"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.HasQueuedCallbacks(JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread,System.Int32*)">
             <summary>
             HasQueuedCallbacks returns TRUE if there are currently managed
             callbacks which are queued up for the given thread.  These
             callbacks will be dispatched one at a time, each time Continue
             is called.
            
             The debugger can check this flag if it wishes to report multiple
             debugging events which occur simultaneously.
            
             If NULL is given for the pThread parameter, HasQueuedCallbacks
             will return TRUE if there are currently managed callbacks
             queued for any thread.
            
             Note that once debug events have been queued, they've already occurred,
             and so the debugger must drain the entire queue to be sure of the state
             of the debuggee. For example, if the queue contains 2 debug events on thread X,
             and the debugger suspends thread X after the 1st debug event and then calls continue,
             the 2nd debug event for thread X will still be dispatched even though the thread
             is suspended.
             </summary>
             <param name="pThread"></param>
             <param name="pbQueued"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.EnumerateThreads(JetBrains.Debugger.CorApi.ComInterop.ICorDebugThreadEnum@)">
             <summary>
             EnumerateThreads returns an enum of all managed threads active in the process.
             A thread is considered Managed threads after the CreateThread callback has been
             dispatched and before the ExitThread callback has been dispatched.
             A managed thread may not necessarily have any managed frames on its stack.
            
             Threads can be enumerated even before the CreateProcess callback. The enumeration
             will naturally be empty.
             </summary>
             <param name="ppThreads"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.SetAllThreadsDebugState(JetBrains.Debugger.CorApi.ComInterop.CorDebugThreadState,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread)">
             <summary>
             SetAllThreadsDebugState sets the current debug state of each thread.
             See ICorDebugThread::SetDebugState for details.
            
             The pExceptThisThread parameter allows you to specify one
             thread which is exempted from the debug state change. Pass NULL
             if you want to affect all threads.
            
             This may affect threads not visible via EnumerateThreads, so threads suspended
             via this API will need to be resumed via this API too.
             </summary>
             <param name="state"></param>
             <param name="pExceptThisThread"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.Detach">
             <summary>
             Detach detaches the debugger from the process.  The process
             continues execution normally. The ICorDebugProcess object is
             no longer valid and no further callbacks will occur.  This is
             not implemented for AppDomains (detaching is process-wide).
            
             Note that currently if unmanaged debugging is enabled this call will
             fail due to OS limitations.
            
             Returns S_OK on success.
             </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.Terminate(System.UInt32)">
             <summary>
             Terminate terminates the process (with extreme prejudice, I might add).
            
             NOTE: If the process or appdomain is stopped when Terminate is called,
             the process or appdomain should be continued using Continue so that the
             ExitProcess or ExitAppDomain callback is received.
            
             NOTE: This method is not implemented by an appdomain.
             </summary>
             <param name="exitCode"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.CanCommitChanges(System.UInt32,System.Void**,System.Void**)">
            <summary>
            DEPRECATED
            </summary>
            <param name="cSnapshots"></param>
            <param name="pSnapshots"></param>
            <param name="pError"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.CommitChanges(System.UInt32,System.Void**,System.Void**)">
            <summary>
            DEPRECATED
            </summary>
            <param name="cSnapshots"></param>
            <param name="pSnapshots"></param>
            <param name="pError"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEditAndContinueSnapshot">
            <summary>
             DEPRECATED
            </summary>
            <example><code>
             *
             * DEPRECATED
             *
             * ICorDebugEditAndContinueSnapshot
             */
            
            [
                object,
                local,
                uuid(6DC3FA01-D7CB-11d2-8A95-0080C792E5D8),
                pointer_default(unique)
            ]
            interface ICorDebugEditAndContinueSnapshot : IUnknown
            {
                /*
                 * DEPRECATED
                 */
                HRESULT CopyMetaData([in] IStream *pIStream, [out] GUID *pMvid);
            
                /*
                 * DEPRECATED
                 */
                HRESULT GetMvid([out] GUID *pMvid);
            
                /*
                 * DEPRECATED
                 */
                HRESULT GetRoDataRVA([out] ULONG32 *pRoDataRVA);
            
                /*
                 * DEPRECATED
                 */
                HRESULT GetRwDataRVA([out] ULONG32 *pRwDataRVA);
            
            
                /*
                 * DEPRECATED
                 */
                HRESULT SetPEBytes([in] IStream *pIStream);
            
                /*
                 * DEPRECATED
                 */
                HRESULT SetILMap([in] mdToken mdFunction, [in] ULONG cMapSize,
                                 [in, size_is(cMapSize)] COR_IL_MAP map[]);
            
                /*
                 * DEPRECATED
                 */
                HRESULT SetPESymbolBytes([in] IStream *pIStream);
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEditAndContinueSnapshot.CopyMetaData(System.Void*,System.Guid*)">
            <summary>
            DEPRECATED
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEditAndContinueSnapshot.GetMvid(System.Guid*)">
            <summary>
            DEPRECATED
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEditAndContinueSnapshot.GetRoDataRVA(System.UInt32*)">
            <summary>
            DEPRECATED
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEditAndContinueSnapshot.GetRwDataRVA(System.UInt32*)">
            <summary>
            DEPRECATED
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEditAndContinueSnapshot.SetPEBytes(System.Void*)">
            <summary>
            DEPRECATED
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEditAndContinueSnapshot.SetILMap(System.UInt32,System.UInt32,JetBrains.Debugger.CorApi.ComInterop.COR_IL_MAP*)">
            <summary>
            DEPRECATED
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEditAndContinueSnapshot.SetPESymbolBytes(System.Void*)">
            <summary>
            DEPRECATED
            </summary>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEnum">
            <summary>
             ICorDebugEnum is an abstract enumerator.
            </summary>
            <example><code>
             * ICorDebugEnum is an abstract enumerator.
             */
            
            [
                object,
                local,
                uuid(CC7BCB01-8A68-11d2-983C-0000F808342D),
                pointer_default(unique)
            ]
            interface ICorDebugEnum : IUnknown
            {
                /*
                 * Moves the current position forward the given number of
                 * elements.
                 */
                HRESULT Skip([in] ULONG celt);
            
                /*
                 * Sets the position of the enumerator to the beginning of the
                 * enumeration.
                 */
                HRESULT Reset();
            
                /*
                 * Creates another enumerator with the same current position
                 * as this one.
                 */
                HRESULT Clone([out] ICorDebugEnum **ppEnum);
            
                /*
                 * Gets the number of elements in the enumeration
                 */
                HRESULT GetCount([out] ULONG *pcelt);
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEnum.Skip(System.UInt32)">
            <summary>
            Moves the current position forward the given number of elements.
            </summary>
            <param name="celt">the given number of elements</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEnum.Reset">
            <summary>
            Sets the position of the enumerator to the beginning of the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEnum.Clone(JetBrains.Debugger.CorApi.ComInterop.ICorDebugEnum@)">
            <summary>
            Creates another enumerator with the same current position as this one.
            </summary>
            <param name="ppEnum">another enumerator</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEnum.GetCount(System.UInt32*)">
            <summary>
            Gets the number of elements in the enumeration.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugErrorInfoEnum" -->
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugErrorInfoEnum.Skip(System.UInt32)">
            <summary>
            Moves the current position forward the given number of elements.
            </summary>
            <param name="celt">the given number of elements</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugErrorInfoEnum.Reset">
            <summary>
            Sets the position of the enumerator to the beginning of the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugErrorInfoEnum.Clone(JetBrains.Debugger.CorApi.ComInterop.ICorDebugEnum@)">
            <summary>
            Creates another enumerator with the same current position as this one.
            </summary>
            <param name="ppEnum">another enumerator</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugErrorInfoEnum.GetCount(System.UInt32*)">
            <summary>
            Gets the number of elements in the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugErrorInfoEnum.Next(System.UInt32,System.Void**,System.UInt32*)">
            <summary>
            DEPRECATED
            </summary>
            <param name="celt"></param>
            <param name="errors"></param>
            <param name="pceltFetched"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEval">
            <summary>
             ICorDebugEval collects functionality which requires running code
             inside the debuggee. Note that the operations do not complete until
             ICorDebugProcess::Continue is called, and the EvalComplete callback
             is called.
             An ICorDebugEval object is created in the context of a specific
             thread, which will be used to perform the evaluations.
             If you need to use this functionality without allowing other threads
             to run, set the DebugState of the program's threads to STOP
             before calling Continue.
             Note that since user code is running when the evaluation is in
             progress, any debug events can occur, including class loads,
             breakpoints, etc. Callbacks will be called normally in such a
             case. The state of the Eval will be seen as part of the normal
             program state inspection, the stack chain will be a CHAIN_FUNC_EVAL chain;
             the full debugger API continues to operate as normal. Evals can even be nested.
             Also, the user code may never complete due to deadlock or infinite
             looping. In this case you will need to Abort the Eval before
             resuming the program.
             All objects and types used in a given func-eval must all reside within the
             same app domain. That app-domain need not be the same as the current
             app domain of the thread.
            </summary>
            <example><code>
             /*
             * ICorDebugEval collects functionality which requires running code
             * inside the debuggee. Note that the operations do not complete until
             * ICorDebugProcess::Continue is called, and the EvalComplete callback
             * is called.
             *
             * An ICorDebugEval object is created in the context of a specific
             * thread, which will be used to perform the evaluations.
             *
             * If you need to use this functionality without allowing other threads
             * to run, set the DebugState of the program's threads to STOP
             * before calling Continue.
             *
             * Note that since user code is running when the evaluation is in
             * progress, any debug events can occur, including class loads,
             * breakpoints, etc. Callbacks will be called normally in such a
             * case. The state of the Eval will be seen as part of the normal
             * program state inspection, the stack chain will be a CHAIN_FUNC_EVAL chain;
             * the full debugger API continues to operate as normal. Evals can even be nested.
             *
             * Also, the user code may never complete due to deadlock or infinite
             * looping. In this case you will need to Abort the Eval before
             * resuming the program.
             *
             * All objects and types used in a given func-eval must all reside within the
             * same app domain. That app-domain need not be the same as the current
             * app domain of the thread.
             *
             */
            
            [
                object,
                local,
                uuid(CC7BCAF6-8A68-11d2-983C-0000F808342D),
                pointer_default(unique)
            ]
            interface ICorDebugEval : IUnknown
            {
                /*
                 * CallFunction sets up a function call.  Note that if the function
                 * is virtual, this will perform virtual dispatch.  If the function is
                 * not static, then the first argument must be the "this" object.
                 * If the function is in an a different AppDomain, a transition will 
                 * occur (but all arguments must also be in the target AppDomain)
                 */
            
                HRESULT CallFunction([in] ICorDebugFunction *pFunction,
                                     [in] ULONG32 nArgs,
                                     [in, size_is(nArgs)] ICorDebugValue *ppArgs[]);
            
                /*
                 * NewObject allocates and calls the constructor for an object.
                 */
            
                HRESULT NewObject([in] ICorDebugFunction *pConstructor,
                                  [in] ULONG32 nArgs,
                                  [in, size_is(nArgs)] ICorDebugValue *ppArgs[]);
            
                /*
                 * NewObjectNoConstructor allocates a new object without
                 * attempting to call any constructor on the object.
                 */
            
                HRESULT NewObjectNoConstructor([in] ICorDebugClass *pClass);
            
                /*
                 * NewString allocates a string object with the given contents.
                 * The string is always created in the AppDomain the thread is currently in.
                 */
            
                HRESULT NewString([in] LPCWSTR string);
            
                /*
                 * NewArray allocates a new array with the given element type and
                 * dimensions. If the elementType is a primitive, pElementClass
                 * may be NULL. Otherwise, pElementClass should be the class of
                 * the elements of the array. Note: lowBounds is optional. If
                 * omitted, a zero lower bound for each dimension is assumed.
                 * The array is always created in the AppDomain the thread is currently in.
                 *
                 * NOTE: In the current release, rank must be 1.
                 */
            
                HRESULT NewArray([in] CorElementType elementType,
                                 [in] ICorDebugClass *pElementClass,
                                 [in] ULONG32 rank,
                                 [in, size_is(rank)] ULONG32 dims[],
                                 [in, size_is(rank)] ULONG32 lowBounds[]);
            
                /*
                 * IsActive returns whether the func-eval is currently executing.
                 */
            
                HRESULT IsActive([out] BOOL *pbActive);
            
                /*
                 * Abort aborts the current computation.  Note that in the case of nested
                 * Evals, this may fail unless it is the most recent Eval.
                 */
            
                HRESULT Abort();
            
                /*
                 * GetResult returns the result of the evaluation.  This is only
                 * valid after the evaluation is completed.
                 *
                 * If the evaluation completes normally, the result will be the
                 * return value.  If it terminates with an exception, the result
                 * is the exception thrown. If the evaluation was for a new object,
                 * the return value is the reference to the object.
                 */
            
                HRESULT GetResult([out] ICorDebugValue **ppResult);
            
                /*
                 * GetThread returns the thread on which this eval will run or is running.
                 */
            
                HRESULT GetThread([out] ICorDebugThread **ppThread);
            
                /*
                 * CreateValue creates an ICorDebugValue of the given type for the
                 * sole purpose of using it in a function evaluation. These can be
                 * used to pass user constants as parameters. The value has a zero
                 * or NULL initial value. Use ICorDebugValue::SetValue to
                 * set the value.
                 *
                 * pElementClass is only required for value classes. Pass NULL
                 * otherwise.
                 *
                 * If elementType == ELEMENT_TYPE_CLASS, then you get an
                 * ICorDebugReferenceValue representing the NULL object reference.
                 * You can use this to pass NULL to evals that have object reference
                 * parameters. You cannot set the ICorDebugReferenceValue to
                 * anything... it always remains NULL.
                 */
            
                HRESULT CreateValue([in] CorElementType elementType,
                                    [in] ICorDebugClass *pElementClass,
                                    [out] ICorDebugValue **ppValue);
            }; 
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEval.CallFunction(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction,System.UInt32,JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue[])">
            <summary>
            CallFunction sets up a function call.  Note that if the function
            is virtual, this will perform virtual dispatch.  If the function is
            not static, then the first argument must be the "this" object.
            If the function is in an a different AppDomain, a transition will
            occur (but all arguments must also be in the target AppDomain)
            </summary>
            <param name="pFunction"></param>
            <param name="nArgs"></param>
            <param name="ppArgs"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEval.NewObject(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction,System.UInt32,JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue[])">
            <summary>
            NewObject allocates and calls the constructor for an object.
            </summary>
            <param name="pConstructor"></param>
            <param name="nArgs"></param>
            <param name="ppArgs"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEval.NewObjectNoConstructor(JetBrains.Debugger.CorApi.ComInterop.ICorDebugClass)">
            <summary>
            NewObjectNoConstructor allocates a new object without
            attempting to call any constructor on the object.
            </summary>
            <param name="pClass"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEval.NewString(System.UInt16*)">
            <summary>
            NewString allocates a string object with the given contents.
            The string is always created in the AppDomain the thread is currently in.
            </summary>
            <param name="string"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEval.NewArray(JetBrains.Debugger.CorApi.ComInterop.CorElementType,JetBrains.Debugger.CorApi.ComInterop.ICorDebugClass,System.UInt32,System.UInt32*,System.UInt32*)">
            <summary>
            NewArray allocates a new array with the given element type and
            dimensions. If the elementType is a primitive, pElementClass
            may be NULL. Otherwise, pElementClass should be the class of
            the elements of the array. Note: lowBounds is optional. If
            omitted, a zero lower bound for each dimension is assumed.
            The array is always created in the AppDomain the thread is currently in.
            NOTE: In the current release, rank must be 1.
            </summary>
            <param name="elementType"></param>
            <param name="pElementClass"></param>
            <param name="rank"></param>
            <param name="dims"></param>
            <param name="lowBounds"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEval.IsActive(System.Int32*)">
            <summary>
            IsActive returns whether the func-eval is currently executing.
            </summary>
            <param name="pbActive"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEval.Abort">
            <summary>
            Abort aborts the current computation.  Note that in the case of nested
            Evals, this may fail unless it is the most recent Eval.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEval.GetResult(JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            GetResult returns the result of the evaluation.  This is only
            valid after the evaluation is completed.
            If the evaluation completes normally, the result will be the
            return value.  If it terminates with an exception, the result
            is the exception thrown. If the evaluation was for a new object,
            the return value is the reference to the object.
            </summary>
            <param name="ppResult"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEval.GetThread(JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread@)">
            <summary>
            GetThread returns the thread on which this eval will run or is running.
            </summary>
            <param name="ppThread"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEval.CreateValue(JetBrains.Debugger.CorApi.ComInterop.CorElementType,JetBrains.Debugger.CorApi.ComInterop.ICorDebugClass,JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            CreateValue creates an ICorDebugValue of the given type for the
            sole purpose of using it in a function evaluation. These can be
            used to pass user constants as parameters. The value has a zero
            or NULL initial value. Use ICorDebugValue::SetValue to
            set the value.
            pElementClass is only required for value classes. Pass NULL
            otherwise.
            If elementType == ELEMENT_TYPE_CLASS, then you get an
            ICorDebugReferenceValue representing the NULL object reference.
            You can use this to pass NULL to evals that have object reference
            parameters. You cannot set the ICorDebugReferenceValue to
            anything... it always remains NULL.
            </summary>
            <param name="elementType"></param>
            <param name="pElementClass"></param>
            <param name="ppValue"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEval2">
            <summary>
            </summary>
            <example><code>
             [
                object,
                local,
                uuid(FB0D9CE7-BE66-4683-9D32-A42A04E2FD91),
                pointer_default(unique)
            ]
            interface ICorDebugEval2 : IUnknown
            {
                /*
                 * CallParameterizedFunction is like CallFunction except the function
                 * may be inside a class with type parameters, or may itself take type
                 * parameters, or both.  The type arguments should be given for the
                 * class first, then the function.
                 *
                 * If the function is in an a different AppDomain, a transition will occur.
                 * However, all type and value arguments must be in the target AppDomain.
                 *
                 * Func-eval can only be performed in limited scenarios. If Call*Function
                 * fails, then the HR makes a best effort at describing the most general
                 * possible reason for failure.
                 */
            
                HRESULT CallParameterizedFunction([in] ICorDebugFunction *pFunction,
                                  [in] ULONG32 nTypeArgs,
                                  [in, size_is(nTypeArgs)] ICorDebugType *ppTypeArgs[],
                                  [in] ULONG32 nArgs,
                                  [in, size_is(nArgs)] ICorDebugValue *ppArgs[]);
            
                /*
                 * CreateValueForType generalizes CreateValue by allowing you to specify an
                 * arbitrary object type including constructed types such as List&lt;int&gt;.
                 * Once again the sole purpose is to generate a value to pass for a function evaluation.
                 *
                 * The element type of the type must be ELEMENT_TYPE_CLASS or
                 * ELEMENT_TYPE_VALUE, or one of the simple types.  You cannot use this
                 * to create array values or string values.
                 */
            
                HRESULT CreateValueForType([in] ICorDebugType *pType,
                                           [out] ICorDebugValue **ppValue);
            
                /*
                * NewParameterizedObject allocates and calls the constructor for an object.
                * The object may be in a class that includes type parameters.
                */
            
                HRESULT NewParameterizedObject([in] ICorDebugFunction *pConstructor,
                                           [in] ULONG32 nTypeArgs,
                               [in, size_is(nTypeArgs)] ICorDebugType *ppTypeArgs[],
                                       [in] ULONG32 nArgs,
                               [in, size_is(nArgs)] ICorDebugValue *ppArgs[]);
            
                /*
                 * NewParameterizedObjectNoConstructor allocates a new object without
                 * attempting to call any constructor on the object.
                 * The object may be in a class that includes type parameters.
                 */
            
                HRESULT NewParameterizedObjectNoConstructor([in] ICorDebugClass *pClass,
                                    [in] ULONG32 nTypeArgs,
                                    [in, size_is(nTypeArgs)] ICorDebugType *ppTypeArgs[]);
            
                /*
                 * NewParamaterizedArray allocates a new array whose elements may be instances
                 * of a generic type.  The array is always created in the AppDomain the thread is
                 * currently in.
                 */
                HRESULT NewParameterizedArray([in] ICorDebugType *pElementType,
                              [in] ULONG32 rank,
                              [in, size_is(rank)] ULONG32 dims[],
                              [in, size_is(rank)] ULONG32 lowBounds[]);
            
               /*
                * NewStringWithLength allocates a string object with the given contents.
                * The length is specified in uiLength. This is used for user to pass in null
                * embedded string. If the string's tailing null is expected to be in
                * the managed string, client has to ensure the length including the tailing null.
                *
                * The string is always created in the AppDomain the thread is currently in.
                */
            
                HRESULT NewStringWithLength([in] LPCWSTR string,
                                           [in] UINT  uiLength);
            
                /*
                 * RudeAbort aborts the current computation.  Any locks the aborted
                 * eval was holding are not released, and thus the debugging session
                 * is in an unsafe state.
                 */
            
                 HRESULT RudeAbort(void);
            
            };
            
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEval2.CallParameterizedFunction(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction,System.UInt32,System.Void**,System.UInt32,System.Void**)">
            <summary>
            CallParameterizedFunction is like CallFunction except the function
            may be inside a class with type parameters, or may itself take type
            parameters, or both.  The type arguments should be given for the
            class first, then the function.
            If the function is in an a different AppDomain, a transition will occur.
            However, all type and value arguments must be in the target AppDomain.
            Func-eval can only be performed in limited scenarios. If Call*Function
            fails, then the HR makes a best effort at describing the most general
            possible reason for failure.
            </summary>
            <param name="pFunction"></param>
            <param name="nTypeArgs"></param>
            <param name="ppTypeArgs"></param>
            <param name="nArgs"></param>
            <param name="ppArgs"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEval2.CreateValueForType(JetBrains.Debugger.CorApi.ComInterop.ICorDebugType,JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            CreateValueForType generalizes CreateValue by allowing you to specify an
            arbitrary object type including constructed types such as List&lt;int&gt;.
            Once again the sole purpose is to generate a value to pass for a function evaluation.
            The element type of the type must be ELEMENT_TYPE_CLASS or
            ELEMENT_TYPE_VALUE, or one of the simple types.  You cannot use this
            to create array values or string values.
            </summary>
            <param name="pType"></param>
            <param name="ppValue"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEval2.NewParameterizedObject(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction,System.UInt32,System.Void**,System.UInt32,System.Void**)">
            <summary>
            NewParameterizedObject allocates and calls the constructor for an object.
            The object may be in a class that includes type parameters.
            </summary>
            <param name="pConstructor">The function to call.</param>
            <param name="nTypeArgs">The number of type-arguments for the method in rgpTypeArgs</param>
            <param name="ppTypeArgs">An array of pointers to types.</param>
            <param name="nArgs">The number of arguments for the method in rgpArgs</param>
            <param name="ppArgs">An array of pointers to values for the arguments to the method.</param>
            <returns>HRESULT for the operation</returns>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEval2.NewParameterizedObjectNoConstructor(JetBrains.Debugger.CorApi.ComInterop.ICorDebugClass,System.UInt32,System.Void**)">
            <summary>
            NewParameterizedObjectNoConstructor allocates a new object without
            attempting to call any constructor on the object.
            The object may be in a class that includes type parameters.
            </summary>
            <param name="pClass">the type of the object to create.</param>
            <param name="nTypeArgs">The number of type-arguments for the method in rgpTypeArgs</param>
            <param name="ppTypeArgs">An array of pointers to types.</param>
            <returns>HRESULT for the operation</returns>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEval2.NewParameterizedArray(JetBrains.Debugger.CorApi.ComInterop.ICorDebugType,System.UInt32,System.UInt32*,System.UInt32*)">
            <summary>
            NewParamaterizedArray allocates a new array whose elements may be instances
            of a generic type.  The array is always created in the AppDomain the thread is
            currently in.
            </summary>
            <param name="pElementType"></param>
            <param name="rank"></param>
            <param name="dims"></param>
            <param name="lowBounds"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEval2.NewStringWithLength(System.UInt16*,System.UInt32)">
            <summary>
            NewStringWithLength allocates a string object with the given contents.
            The length is specified in uiLength. This is used for user to pass in null
            embedded string. If the string's tailing null is expected to be in
            the managed string, client has to ensure the length including the tailing null.
            The string is always created in the AppDomain the thread is currently in.
            </summary>
            <param name="string"></param>
            <param name="uiLength"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugEval2.RudeAbort">
            <summary>
            RudeAbort aborts the current computation.  Any locks the aborted
            eval was holding are not released, and thus the debugging session
            is in an unsafe state.
            </summary>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame">
            <summary>
            </summary>
            <example><code>
             [
                object,
                local,
                uuid(CC7BCAEF-8A68-11d2-983C-0000F808342D),
                pointer_default(unique)
            ]
            interface ICorDebugFrame : IUnknown
            {
                /*
                 * GetChain returns the chain of which this stack frame is a part.
                 */
            
                HRESULT GetChain([out] ICorDebugChain **ppChain);
            
                /*
                 * GetCode returns the code which this stack frame is running if any.
                 */
            
                HRESULT GetCode([out] ICorDebugCode **ppCode);
            
                /*
                 * GetFunction returns the function for the code which this stack 
                 * frame is running.  
                 * For ICorDebugInternalFrames, this may point to a method the 
                 * frame is associated with (which may be in a different AppDomain
                 * from the frame itself), or may fail if the frame doesn't relate to any
                 * particular function.
                 */
            
                HRESULT GetFunction([out] ICorDebugFunction **ppFunction);
            
                /*
                 * GetFunctionToken is a convenience routine to return the token for the
                 * function for the code which this stack frame is running.
                 * The scope to resolve the token can be gotten from the ICorDebugFunction 
                 * associated with this frame.
                 */
            
                HRESULT GetFunctionToken([out] mdMethodDef *pToken);
            
                /*
                 * GetStackRange returns the absolute address range of the stack
                 * frame.  (This is useful for piecing together interleaved stack
                 * traces gathered from multiple debugging engines.)  Note that you
                 * cannot make any assumptions about what is actually stored on
                 * the stack - the numeric range is to compare stack frame
                 * locations only.
                 * The start of a stack range is the leafmost boundary of the frame, and 
                 * the end of a stack range is the rootmost boundary of the frame.
                 */
            
                HRESULT GetStackRange([out] CORDB_ADDRESS *pStart, [out] CORDB_ADDRESS *pEnd);
            
                /*
                 * GetCaller returns a pointer to the frame in the current chain
                 * which called this frame, or NULL if this is the rootmost frame
                 * in the chain.
                 */
            
                HRESULT GetCaller([out] ICorDebugFrame **ppFrame);
            
                /*
                 * GetCallee returns a pointer to the frame in the current chain
                 * which this frame called, or NULL if this is the leafmost frame
                 * in the chain.
                 */
            
                HRESULT GetCallee([out] ICorDebugFrame **ppFrame);
            
                /*
                 * CreateStepper creates a stepper object which operates relative to the
                 * frame. The Stepper API must then be used to perform actual stepping.
                 *
                 * Note that if this frame is not active, the frame will typically have to
                 * be returned to before the step is completed.
                 *
                 */
            
                HRESULT CreateStepper([out] ICorDebugStepper **ppStepper);
            };
            
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame.GetChain(JetBrains.Debugger.CorApi.ComInterop.ICorDebugChain@)">
            <summary>
            GetChain returns the chain of which this stack frame is a part.
            </summary>
            <param name="ppChain"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame.GetCode(JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode@)">
            <summary>
            GetCode returns the code which this stack frame is running if any.
            </summary>
            <param name="ppCode"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame.GetFunction(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction@)">
            <summary>
            GetFunction returns the function for the code which this stack
            frame is running.
            For ICorDebugInternalFrames, this may point to a method the
            frame is associated with (which may be in a different AppDomain
            from the frame itself), or may fail if the frame doesn't relate to any
            particular function.
            </summary>
            <param name="ppFunction"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame.GetFunctionToken(System.UInt32*)">
            <summary>
            GetFunctionToken is a convenience routine to return the token for the
            function for the code which this stack frame is running.
            The scope to resolve the token can be gotten from the ICorDebugFunction
            associated with this frame.</summary>
            <param name="pToken"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame.GetStackRange(System.UInt64*,System.UInt64*)">
            <summary>
            GetStackRange returns the absolute address range of the stack
            frame.  (This is useful for piecing together interleaved stack
            traces gathered from multiple debugging engines.)  Note that you
            cannot make any assumptions about what is actually stored on
            the stack - the numeric range is to compare stack frame
            locations only.
            The start of a stack range is the leafmost boundary of the frame, and
            the end of a stack range is the rootmost boundary of the frame.
            </summary>
            <param name="pStart"></param>
            <param name="pEnd"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame.GetCaller(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame@)">
            <summary>
            GetCaller returns a pointer to the frame in the current chain
            which called this frame, or NULL if this is the rootmost frame
            in the chain.
            </summary>
            <param name="ppFrame"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame.GetCallee(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame@)">
            <summary>
            GetCallee returns a pointer to the frame in the current chain
            which this frame called, or NULL if this is the leafmost frame
            in the chain.
            </summary>
            <param name="ppFrame"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame.CreateStepper(JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper@)">
            <summary>
            CreateStepper creates a stepper object which operates relative to the
            frame. The Stepper API must then be used to perform actual stepping.
            Note that if this frame is not active, the frame will typically have to
            be returned to before the step is completed.
            </summary>
            <param name="ppStepper"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrameEnum">
            <summary>
            </summary>
            <example><code>
            [
                object,
                local,
                uuid(CC7BCB07-8A68-11d2-983C-0000F808342D),
                pointer_default(unique)
            ]
            interface ICorDebugFrameEnum : ICorDebugEnum
            {
                /*
                 * Gets the next "celt" number of frames in the enumeration.
                 * The actual number of frames retrieved is returned in "pceltFetched".
                 * Returns S_FALSE if the actual number of frames retrieved is smaller
                 * than the number of frames requested.
                 */
                HRESULT Next([in] ULONG celt,
                             [out, size_is(celt), length_is(*pceltFetched)]
                                ICorDebugFrame *frames[],
                             [out] ULONG *pceltFetched);
            }; </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrameEnum.Skip(System.UInt32)">
            <summary>
            Moves the current position forward the given number of elements.
            </summary>
            <param name="celt">the given number of elements</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrameEnum.Reset">
            <summary>
            Sets the position of the enumerator to the beginning of the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrameEnum.Clone(JetBrains.Debugger.CorApi.ComInterop.ICorDebugEnum@)">
            <summary>
            Creates another enumerator with the same current position as this one.
            </summary>
            <param name="ppEnum">another enumerator</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrameEnum.GetCount(System.UInt32*)">
            <summary>
            Gets the number of elements in the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrameEnum.Next(System.UInt32,System.Void**,System.UInt32*)">
            <summary>
            Gets the next "celt" number of frames in the enumeration.
            The actual number of frames retrieved is returned in "pceltFetched".
            Returns S_FALSE if the actual number of frames retrieved is smaller than the number of frames requested.
            </summary>
            <param name="celt"></param>
            <param name="frames"></param>
            <param name="pceltFetched"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction">
            <summary>
             ICorDebugFunction represents a managed function.
             In the non-EnC case, it is 1:1 with a methoddef metadata token.
             For EnC, each version of a function has its own ICorDebugFunction instance.
             EnCed functions keep the same metadata tokens, but will get new ICorDebugCode instances.
             ICorDebugFunction does not represent generic typeparameters. That means that there's
             an ICDFunction for Func&lt;T&gt;, but not for Func&lt;string&gt; or Func&lt;Bar&gt;. Get the generic
             parameters from ICorDebugIlFrame::EnumerateTypeParameters.
            </summary>
            <example><code>
             /*
                ICorDebugFunction represents a managed function.
                In the non-EnC case, it is 1:1 with a methoddef metadata token.
                For EnC, each version of a function has its own ICorDebugFunction instance.
                EnCed functions keep the same metadata tokens, but will get new ICorDebugCode instances.
            
                ICorDebugFunction does not represent generic typeparameters. That means that there's
                an ICDFunction for Func&lt;T&gt;, but not for Func&lt;string&gt; or Func&lt;Bar&gt;. Get the generic
                parameters from ICorDebugIlFrame::EnumerateTypeParameters.
            */
            [
                object,
                local,
                uuid(CC7BCAF3-8A68-11d2-983C-0000F808342D),
                pointer_default(unique)
            ]
            interface ICorDebugFunction : IUnknown
            {
                /*
                 * GetModule returns the module for the function.
                 */
            
                HRESULT GetModule([out] ICorDebugModule **ppModule);
            
                /*
                 * GetClass returns the class for the function. Returns null if
                 * the function is not a member.
                 */
            
                HRESULT GetClass([out] ICorDebugClass **ppClass);
            
                /*
                 * GetToken returns the metadata methodDef token for the function.
                 */
            
                HRESULT GetToken([out] mdMethodDef *pMethodDef);
            
                /*
                 * GetILCode returns the IL code for the function.  Returns null
                 * if there is no IL code for the function.  Note that this will
                 * get the IL code corresponding to this function's EnC version of
                 * the code in the runtime, if this function has been EnC'd.
                 */
            
                HRESULT GetILCode([out] ICorDebugCode **ppCode);
            
                /*
                 * GetNativeCode returns the native code for the function.
                 * Returns null if there is no native code for the function
                 * (i.e. it is an IL function which has not been jitted)
                 * If this function has been jitted multiple times (Eg, generics) this
                 * will return a random Native Code object.
                 */
            
                HRESULT GetNativeCode([out] ICorDebugCode **ppCode);
            
                /*
                 * CreateBreakpoint creates a breakpoint at the start of the function.
                 *
                 */
            
                HRESULT CreateBreakpoint([out] ICorDebugFunctionBreakpoint **ppBreakpoint);
            
                /*
                 * Returns the token for the local variable signature for this function.
                 * If there is no signature (ie, the function doesn't have any local
                 * variables), then mdSignatureNil will be returned.
                 */
            
                HRESULT GetLocalVarSigToken([out] mdSignature *pmdSig);
            
            
                /*
                 * Obtains the latest (largest) EnC version number for this function.
                 * If this function has never been edited with EnC, this will return
                 * the same value as ICorDebugFunction2::GetVersionNumber.
                 */
                 HRESULT GetCurrentVersionNumber([out] ULONG32 *pnCurrentVersion);
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction.GetModule(JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule@)">
            <summary>
            GetModule returns the module for the function.
            </summary>
            <param name="ppModule"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction.GetClass(JetBrains.Debugger.CorApi.ComInterop.ICorDebugClass@)">
            <summary>
            GetClass returns the class for the function. Returns null if
            the function is not a member.
            </summary>
            <param name="ppClass"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction.GetToken(System.UInt32*)">
            <summary>
            GetToken returns the metadata methodDef token for the function.
            </summary>
            <param name="pMethodDef"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction.GetILCode(JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode@)">
            <summary>
            GetILCode returns the IL code for the function.  Returns null
            if there is no IL code for the function.  Note that this will
            get the IL code corresponding to this function's EnC version of
            the code in the runtime, if this function has been EnC'd.
            </summary>
            <param name="ppCode"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction.GetNativeCode(JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode@)">
            <summary>
            GetNativeCode returns the native code for the function.
            Returns null if there is no native code for the function
            (i.e. it is an IL function which has not been jitted)
            If this function has been jitted multiple times (Eg, generics) this
            will return a random Native Code object.
            </summary>
            <param name="ppCode"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction.CreateBreakpoint(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunctionBreakpoint@)">
            <summary>
            CreateBreakpoint creates a breakpoint at the start of the function.
            </summary>
            <param name="ppBreakpoint"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction.GetLocalVarSigToken(System.UInt32*)">
            <summary>
            Returns the token for the local variable signature for this function.
            If there is no signature (ie, the function doesn't have any local
            variables), then mdSignatureNil will be returned.
            </summary>
            <param name="pmdSig"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction.GetCurrentVersionNumber(System.UInt32*)">
            <summary>
            Obtains the latest (largest) EnC version number for this function.
            If this function has never been edited with EnC, this will return
            the same value as ICorDebugFunction2::GetVersionNumber.
            </summary>
            <param name="pnCurrentVersion"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction2">
            <summary>
             ICorDebugFunction2 is a logical extension to ICorDebugFunction.
            </summary>
            <example><code>
             /*
                ICorDebugFunction2 is a logical extension to ICorDebugFunction.
            */
            [
                object,
                local,
                uuid(EF0C490B-94C3-4e4d-B629-DDC134C532D8),
                pointer_default(unique)
            ]
            interface ICorDebugFunction2 : IUnknown
            {
                /*
                 * Sets the User-code status (for JMC stepping) for this function.
                 * A JMC stepper will skip non-user code.
                 * User code must be a subset of debuggable code.
                 * Returns S_OK if successful, CORDBG_E_FUNCTION_NOT_DEBUGGABLE
                 * if bIsJustMyCode is TRUE and the function is not debuggable.
                 */
                HRESULT SetJMCStatus([in] BOOL bIsJustMyCode);
            
                /*
                 * IsUserCode outputs whether the function is marked as user code.
                 * Always outputs FALSE for non-debuggable functions.
                 * Returns S_OK if successful.
                 */
                HRESULT GetJMCStatus([out] BOOL * pbIsJustMyCode);
            
                /*
                 *    Not yet implemented.
                 */
            
                HRESULT EnumerateNativeCode([out] ICorDebugCodeEnum **ppCodeEnum);
            
                /*
                 * Obtains the EnC version number of the function represented by this ICorDebugFunction2.
                 * When a function is edited with EnC, the new function has a larger version number than
                 * that of any previous version (not necessarily exactly 1 greater).
                 * This function's version number will be less than or equal to the value returned by
                 * ICorDebugFunction::GetCurrentVersionNumber.
                 */
            
                 HRESULT GetVersionNumber([out] ULONG32 *pnVersion);
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction2.SetJMCStatus(System.Int32)">
            <summary>
            Sets the User-code status (for JMC stepping) for this function.
            A JMC stepper will skip non-user code.
            User code must be a subset of debuggable code.
            Returns S_OK if successful, CORDBG_E_FUNCTION_NOT_DEBUGGABLE
            if bIsJustMyCode is TRUE and the function is not debuggable.
            </summary>
            <param name="bIsJustMyCode"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction2.GetJMCStatus(System.Int32*)">
            <summary>
            IsUserCode outputs whether the function is marked as user code.
            Always outputs FALSE for non-debuggable functions.
            Returns S_OK if successful.
            </summary>
            <param name="pbIsJustMyCode"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction2.EnumerateNativeCode(JetBrains.Debugger.CorApi.ComInterop.ICorDebugCodeEnum@)">
            <summary>
            Not yet implemented.
            </summary>
            <param name="ppCodeEnum"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction2.GetVersionNumber(System.UInt32*)">
            <summary>
            Obtains the EnC version number of the function represented by this ICorDebugFunction2.
            When a function is edited with EnC, the new function has a larger version number than
            that of any previous version (not necessarily exactly 1 greater).
            This function's version number will be less than or equal to the value returned by
            ICorDebugFunction::GetCurrentVersionNumber.
            </summary>
            <param name="pnVersion"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunctionBreakpoint">
             <summary>
             
             </summary>
             <example><code>
            [
                object,
                local,
                uuid(CC7BCAE9-8A68-11d2-983C-0000F808342D),
                pointer_default(unique)
            ]
            interface ICorDebugFunctionBreakpoint : ICorDebugBreakpoint
            {
                /*
                 * Returns the function on which this breakpoint is set
                 */
                HRESULT GetFunction([out] ICorDebugFunction **ppFunction);
            
                /*
                 * Returns the offset of this breakpoint within the function
                 */
                HRESULT GetOffset([out] ULONG32 *pnOffset);
            }; </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunctionBreakpoint.Activate(System.Int32)">
            <summary>
            Sets the active state of the breakpoint.
            </summary>
            <param name="bActive"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunctionBreakpoint.IsActive(System.Int32*)">
            <summary>
            Returns whether the breakpoint is active.
            </summary>
            <param name="pbActive"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunctionBreakpoint.GetFunction(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction@)">
            <summary>
            Returns the function on which this breakpoint is set.
            </summary>
            <param name="ppFunction"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunctionBreakpoint.GetOffset(System.UInt32*)">
            <summary>
            Returns the offset of this breakpoint within the function.
            </summary>
            <param name="pnOffset"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValue">
            <summary>
             ICorDebugGenericValue is a subclass of ICorDebugValue which applies to
             all values, and can be used to get &amp; set the value.  It is a
             separate subinterface because it is non-remotable.
             Note that for reference types, the value is the reference rather than
             the contents.
            </summary>
            <example><code>
             /*
             * ICorDebugGenericValue is a subclass of ICorDebugValue which applies to
             * all values, and can be used to get &amp; set the value.  It is a
             * separate subinterface because it is non-remotable.
             *
             * Note that for reference types, the value is the reference rather than
             * the contents.
             */
            
            [
                object,
                local,
                uuid(CC7BCAF8-8A68-11d2-983C-0000F808342D),
                pointer_default(unique)
            ]
            interface ICorDebugGenericValue : ICorDebugValue
            {
                /*
                 * GetValue copies the value into the specified buffer.  The buffer should
                 * be the appropriate size for the simple type.
                 */
            
                HRESULT GetValue([out] void *pTo);
            
                /*
                 * SetValue copies a new value from the specified buffer. The buffer should
                 * be the approprirate size for the simple type.
                 *
                 */
            
                HRESULT SetValue([in] void *pFrom);
            };
            
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValue.GetType(JetBrains.Debugger.CorApi.ComInterop.CorElementType*)">
            <summary>
            GetType returns the simple type of the value.  If the object
            has a more complex runtime type, that type may be examined through the
            appropriate subclasses (e.g. ICorDebugObjectValue can get the class of
            an object.)
            </summary>
            <param name="elementType"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValue.GetSize(System.UInt32*)">
            <summary>
            GetSize returns the size of the value in bytes. Note that for reference
            types this will be the size of the pointer rather than the size of
            the object.
            </summary>
            <param name="pSize"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValue.GetAddress(System.UInt64*)">
            <summary>
            GetAddress returns the address of the value in the debugee
            process.  This might be useful information for the debugger to
            show.
            If the value is unavailable, 0 is returned. This could happen if
            it is at least partly in registers or stored in a GC Handle.
            </summary>
            <param name="pAddress"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValue.CreateBreakpoint(JetBrains.Debugger.CorApi.ComInterop.ICorDebugValueBreakpoint@)">
            <summary>
            NOT YET IMPLEMENTED
            </summary>
            <param name="ppBreakpoint"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValue.GetValue(System.Void*)">
            <summary>
            GetValue copies the value into the specified buffer.  The buffer should
            be the appropriate size for the simple type.
            </summary>
            <param name="pTo"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugGenericValue.SetValue(System.Void*)">
            <summary>
            SetValue copies a new value from the specified buffer. The buffer should
            be the approprirate size for the simple type.
            </summary>
            <param name="pFrom"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugGuidToTypeEnum">
            <summary>
            </summary>
            <example><code>
            [
                object,
                local,
                uuid(6164D242-1015-4BD6-8CBE-D0DBD4B8275A),
                pointer_default(unique)
            ]
            interface ICorDebugGuidToTypeEnum : ICorDebugEnum
            {
                /*
                 * Gets the next "celt" number of IID / Type pairs from the app domain cache.
                 * The actual number of frames retrieved is returned in "pceltFetched".
                 * Returns S_FALSE if the actual number of pairs retrieved is smaller
                 * than the number of pairs requested.
                 */
                HRESULT Next([in] ULONG celt,
                             [out, size_is(celt), length_is(*pceltFetched)]
                             CorDebugGuidToTypeMapping values[],
                             [out] ULONG* pceltFetched);
            }; </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugGuidToTypeEnum.Skip(System.UInt32)">
            <summary>
            Moves the current position forward the given number of elements.
            </summary>
            <param name="celt">the given number of elements</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugGuidToTypeEnum.Reset">
            <summary>
            Sets the position of the enumerator to the beginning of the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugGuidToTypeEnum.Clone(JetBrains.Debugger.CorApi.ComInterop.ICorDebugEnum@)">
            <summary>
            Creates another enumerator with the same current position as this one.
            </summary>
            <param name="ppEnum">another enumerator</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugGuidToTypeEnum.GetCount(System.UInt32*)">
            <summary>
            Gets the number of elements in the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugGuidToTypeEnum.Next(System.UInt32,System.Void**,System.UInt32*)">
            <summary>
            Gets the next "celt" number of IID / Type pairs from the app domain cache.
            The actual number of frames retrieved is returned in "pceltFetched".
            Returns S_FALSE if the actual number of pairs retrieved is smaller than the number of pairs requested.
            </summary>
            <param name="celt"></param>
            <param name="values"></param>
            <param name="pceltFetched"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugHandleValue">
            <summary>
             ICorDebugHandleValue represents a reference value that the debugger has
             explicitly created a GC handle to. It does not represent GC Handles in the debuggee process,
             A normal ICorDebugReference becomes neutered after the debuggee has been
             continued. A ICorDebugHandleValue will survive across continues and can be
             dereferenced until the client explcitly disposes the handle.
             ICorDebugHeapValu2::CreateHandle will create ICorDebugHandleValue
            </summary>
            <example><code>
             /*
             * ICorDebugHandleValue represents a reference value that the debugger has
             * explicitly created a GC handle to. It does not represent GC Handles in the debuggee process,
            
             * A normal ICorDebugReference becomes neutered after the debuggee has been
             * continued. A ICorDebugHandleValue will survive across continues and can be
             * dereferenced until the client explcitly disposes the handle.
             *
             *
             * ICorDebugHeapValu2::CreateHandle will create ICorDebugHandleValue
             */
            [
                object,
                local,
                uuid(029596E8-276B-46a1-9821-732E96BBB00B),
                pointer_default(unique)
            ]
            interface ICorDebugHandleValue : ICorDebugReferenceValue
            {
                /*
                  * returns the type of this handle.
                  *
                  */
                HRESULT GetHandleType([out] CorDebugHandleType *pType);
            
            
                /*
                  * The final release of the interface will also dispose of the handle. This
                  * API provides the ability for client to early dispose the handle.
                  *
                  */
                HRESULT Dispose();
            
            };
            
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugHandleValue.GetType(JetBrains.Debugger.CorApi.ComInterop.CorElementType*)">
            <summary>
            GetType returns the simple type of the value.  If the object
            has a more complex runtime type, that type may be examined through the
            appropriate subclasses (e.g. ICorDebugObjectValue can get the class of
            an object.)
            </summary>
            <param name="elementType"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugHandleValue.GetSize(System.UInt32*)">
            <summary>
            GetSize returns the size of the value in bytes. Note that for reference
            types this will be the size of the pointer rather than the size of
            the object.
            </summary>
            <param name="pSize"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugHandleValue.GetAddress(System.UInt64*)">
            <summary>
            GetAddress returns the address of the value in the debugee
            process.  This might be useful information for the debugger to
            show.
            If the value is unavailable, 0 is returned. This could happen if
            it is at least partly in registers or stored in a GC Handle.
            </summary>
            <param name="pAddress"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugHandleValue.CreateBreakpoint(JetBrains.Debugger.CorApi.ComInterop.ICorDebugValueBreakpoint@)">
            <summary>
            NOT YET IMPLEMENTED
            </summary>
            <param name="ppBreakpoint"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugHandleValue.IsNull(System.Int32*)">
            <summary>
            IsNull tests whether the reference is null.
            </summary>
            <param name="pbNull"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugHandleValue.GetValue(System.UInt64*)">
            <summary>
            GetValue returns the current address of the object referred to by this reference.
            </summary>
            <param name="pValue"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugHandleValue.SetValue(System.UInt64)">
            <summary>
            SetValue sets this reference to refer to a different address.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugHandleValue.Dereference(JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            Dereference returns a ICorDebugValue representing the value
            referenced. This is only valid while the interface has not yet been neutered.
            </summary>
            <param name="ppValue"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugHandleValue.DereferenceStrong(JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            DEPRECATED
            </summary>
            <param name="ppValue"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugHandleValue.GetHandleType(JetBrains.Debugger.CorApi.ComInterop.CorDebugHandleType*)">
            <summary>
            returns the type of this handle.
            </summary>
            <param name="pType"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugHandleValue.Dispose">
            <summary>
            The final release of the interface will also dispose of the handle. This
            API provides the ability for client to early dispose the handle.
            </summary>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugHeapValue">
            <summary>
             ICorDebugHeapValue is a subclass of ICorDebugValue which represents a garbage collected object.
            </summary>
            <example><code>
             /*
             * ICorDebugHeapValue is a subclass of ICorDebugValue which represents
             * a garbage collected object
             */
            
            [
                object,
                local,
                uuid(CC7BCAFA-8A68-11d2-983C-0000F808342D),
                pointer_default(unique)
            ]
            interface ICorDebugHeapValue : ICorDebugValue
            {
                /*
                 * DEPRECATED.
                 * All objects are only valid until Continue is called, at which time they are neutered.
                 */
            
                HRESULT IsValid([out] BOOL *pbValid);
            
                /*
                 * NOT YET IMPLEMENTED
                 */
            
                HRESULT CreateRelocBreakpoint([out]
                                              ICorDebugValueBreakpoint **ppBreakpoint);
            
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugHeapValue.GetType(JetBrains.Debugger.CorApi.ComInterop.CorElementType*)">
            <summary>
            GetType returns the simple type of the value.  If the object
            has a more complex runtime type, that type may be examined through the
            appropriate subclasses (e.g. ICorDebugObjectValue can get the class of
            an object.)
            </summary>
            <param name="elementType"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugHeapValue.GetSize(System.UInt32*)">
            <summary>
            GetSize returns the size of the value in bytes. Note that for reference
            types this will be the size of the pointer rather than the size of
            the object.
            </summary>
            <param name="pSize"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugHeapValue.GetAddress(System.UInt64*)">
            <summary>
            GetAddress returns the address of the value in the debugee
            process.  This might be useful information for the debugger to
            show.
            If the value is unavailable, 0 is returned. This could happen if
            it is at least partly in registers or stored in a GC Handle.
            </summary>
            <param name="pAddress"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugHeapValue.CreateBreakpoint(JetBrains.Debugger.CorApi.ComInterop.ICorDebugValueBreakpoint@)">
            <summary>
            NOT YET IMPLEMENTED
            </summary>
            <param name="ppBreakpoint"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugHeapValue.IsValid(System.Int32*)">
            <summary>
            DEPRECATED.
                * All objects are only valid until Continue is called, at which time they are neutered.
            </summary>
            <param name="pbValid"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugHeapValue2">
            <summary>
             ICorDebugHeapValue2
            </summary>
            <example><code>
             /*
             * ICorDebugHeapValue2
             */
            
            [
                object,
                local,
                uuid(E3AC4D6C-9CB7-43e6-96CC-B21540E5083C),
                pointer_default(unique)
            ]
            interface ICorDebugHeapValue2 : IUnknown
            {
            
                /*
                  * Creates a handle of the given type for this heap value.
                  *
                  */
                HRESULT CreateHandle([in] CorDebugHandleType type, [out] ICorDebugHandleValue ** ppHandle);
            
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugHeapValue2.CreateHandle(JetBrains.Debugger.CorApi.ComInterop.CorDebugHandleType,JetBrains.Debugger.CorApi.ComInterop.ICorDebugHandleValue@)">
            <summary>
            Creates a handle of the given type for this heap value.
            </summary>
            <param name="type"></param>
            <param name="ppHandle"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame">
            <summary>
             ICorDebugILFrame is a specialized interface of ICorDebugFrame for IL frames or jitted frames.
             (Note that jitted frames implement both ICorDebugILFrame and ICorDebugNativeFrame.)
            </summary>
            <example><code>
             
             /*
             * ICorDebugILFrame is a specialized interface of ICorDebugFrame for IL frames or jitted frames.
             * (Note that jitted frames implement both ICorDebugILFrame and ICorDebugNativeFrame.)
             */
            
            [
                object,
                local,
                uuid(03E26311-4F76-11d3-88C6-006097945418),
                pointer_default(unique)
            ]
            interface ICorDebugILFrame : ICorDebugFrame
            {
                /*
                 * GetIP returns the stack frame's offset into the function's IL code.
                 * If this stack frame is active, this address is the next
                 * instruction to execute.  If this stack frame is not active, this is the
                 * next instruction to execute when the stack frame is reactivated.
                 *
                 * Note that if this a jitted frame, the IP will be determined by
                 * mapping backwards from the actual native IP, so the value may
                 * be only approximately correct.
                 *
                 * If pMappingResult is not NULL, A mapping result is returned which
                 * indicates the details of how the IP was obtained.  The following values
                 * can be returned:
                 *
                 *  MAPPING_EXACT - the IP is correct; either the frame is
                 *  interpreted or there is an exact IL map for the function.
                 *
                 *  MAPPING_APPROXIMATE - the IP was successfully mapped, but may
                 *  be only approximately correct
                 *
                 *  MAPPING_UNMAPPED_ADDRESS - although there is mapping info for
                 *  the function, the current address is not mappable to IL.  An
                 *  IP of 0 is returned.
                 *
                 *  MAPPING_PROLOG - the native code is in the prolog, so an IP of
                 *  0 is returned
                 *
                 *  MAPPING_EPILOG - the native code is in an epilog, so the last
                 *  IP of the method is returned
                 *
                 *  MAPPING_NO_INFO - no mapping info is available for the method,
                 *  so an IP of 0 is returned
                 *
                 */
            
                typedef enum CorDebugMappingResult
                {
                    MAPPING_PROLOG              = 0x1,
                    MAPPING_EPILOG              = 0x2,
                    MAPPING_NO_INFO             = 0x4,
                    MAPPING_UNMAPPED_ADDRESS    = 0x8,
                    MAPPING_EXACT               = 0x10,
                    MAPPING_APPROXIMATE         = 0x20,
                } CorDebugMappingResult;
            
                HRESULT GetIP([out] ULONG32 *pnOffset, [out] CorDebugMappingResult *pMappingResult);
            
                /*
                 * SetIP sets the instruction pointer to the IL at the given offset.
                 * The debugger will do its best to fix up the state of the executing code
                 * so that it is consistent with the new IP as far as the EE is concerned,
                 * while preserving as much of the state of the user program as possible.
                 *
                 * Calling SetIP immediately invalidates all frames and chains for the
                 * current thread; the debugger must perform a new stack trace if it
                 * requires frame information after calling SetIP.
                 *
                 */
            
                HRESULT SetIP([in] ULONG32 nOffset);
            
                /*
                 * EnumerateLocalVariables returns a list of the local variables
                 * available in the frame.  Note that this may not include all of
                 * the locals in the running function, as some of them may not be
                 * active.
                 */
            
                HRESULT EnumerateLocalVariables([out] ICorDebugValueEnum **ppValueEnum);
            
                /*
                 * GetLocalVariable gets the value for a local variable
                 * in an IL frame.  This can be used either in an IL
                 * frame or a jitted frame.
                 */
            
                HRESULT GetLocalVariable([in] DWORD dwIndex,
                                         [out] ICorDebugValue **ppValue);
            
                /*
                 * EnumerateArguments returns a list of the arguments available in the
                 * frame.  Note that this will include varargs arguments as well as
                 * arguments declared by the function signature (inlucding the implicit 
                 * "this" argument if any).
                 */
            
                HRESULT EnumerateArguments([out] ICorDebugValueEnum **ppValueEnum);
            
                /*
                 * GetArgument gets the value for an argument
                 * in an IL frame.  This can be used either in an IL
                 * frame or a jitted frame.
                 * For instance (non-static) methods, argument index 0 is the "this" object,
                 * and the normal explicit arguments start with index 1.
                 */
            
                HRESULT GetArgument([in] DWORD dwIndex,
                                    [out] ICorDebugValue **ppValue);
            
                /*
                 * NOT YET IMPLEMENTED
                 */
            
                HRESULT GetStackDepth([out] ULONG32 *pDepth);
            
                /*
                 * NOT YET IMPLEMENTED
                 */
            
                HRESULT GetStackValue([in] DWORD dwIndex,
                                      [out] ICorDebugValue **ppValue);
            
                /*
                 * CanSetIP attempts to determine if it's safe to set the instruction pointer
                 * to the IL at the given offset. If this returns S_OK, then executing
                 * SetIP (see above) will result in a safe, correct, continued execution.
                 * If CanSetIP returns anything else, SetIP can still be invoked, but
                 * continued, correct execution of the debuggee cannot be guaranteed.
                 *
                 */
            
                HRESULT CanSetIP([in] ULONG32 nOffset);
            };
            
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame.GetChain(JetBrains.Debugger.CorApi.ComInterop.ICorDebugChain@)">
            <summary>
            GetChain returns the chain of which this stack frame is a part.
            </summary>
            <param name="ppChain"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame.GetCode(JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode@)">
            <summary>
            GetCode returns the code which this stack frame is running if any.
            </summary>
            <param name="ppCode"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame.GetFunction(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction@)">
            <summary>
            GetFunction returns the function for the code which this stack
            frame is running.
            For ICorDebugInternalFrames, this may point to a method the
            frame is associated with (which may be in a different AppDomain
            from the frame itself), or may fail if the frame doesn't relate to any
            particular function.
            </summary>
            <param name="ppFunction"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame.GetFunctionToken(System.UInt32*)">
            <summary>
            GetFunctionToken is a convenience routine to return the token for the
            function for the code which this stack frame is running.
            The scope to resolve the token can be gotten from the ICorDebugFunction
            associated with this frame.</summary>
            <param name="pToken"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame.GetStackRange(System.UInt64*,System.UInt64*)">
            <summary>
            GetStackRange returns the absolute address range of the stack
            frame.  (This is useful for piecing together interleaved stack
            traces gathered from multiple debugging engines.)  Note that you
            cannot make any assumptions about what is actually stored on
            the stack - the numeric range is to compare stack frame
            locations only.
            The start of a stack range is the leafmost boundary of the frame, and
            the end of a stack range is the rootmost boundary of the frame.
            </summary>
            <param name="pStart"></param>
            <param name="pEnd"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame.GetCaller(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame@)">
            <summary>
            GetCaller returns a pointer to the frame in the current chain
            which called this frame, or NULL if this is the rootmost frame
            in the chain.
            </summary>
            <param name="ppFrame"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame.GetCallee(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame@)">
            <summary>
            GetCallee returns a pointer to the frame in the current chain
            which this frame called, or NULL if this is the leafmost frame
            in the chain.
            </summary>
            <param name="ppFrame"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame.CreateStepper(JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper@)">
            <summary>
            CreateStepper creates a stepper object which operates relative to the
            frame. The Stepper API must then be used to perform actual stepping.
            Note that if this frame is not active, the frame will typically have to
            be returned to before the step is completed.
            </summary>
            <param name="ppStepper"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame.GetIP(System.UInt32*,JetBrains.Debugger.CorApi.ComInterop.CorDebugMappingResult*)">
            <summary>
            GetIP returns the stack frame's offset into the function's IL code.
            If this stack frame is active, this address is the next
            instruction to execute.  If this stack frame is not active, this is the
            next instruction to execute when the stack frame is reactivated.
            Note that if this a jitted frame, the IP will be determined by
            mapping backwards from the actual native IP, so the value may
            be only approximately correct.
            If pMappingResult is not NULL, A mapping result is returned which
            indicates the details of how the IP was obtained.  The following values
            can be returned:
             MAPPING_EXACT - the IP is correct; either the frame is
             interpreted or there is an exact IL map for the function.
             MAPPING_APPROXIMATE - the IP was successfully mapped, but may
             be only approximately correct
             MAPPING_UNMAPPED_ADDRESS - although there is mapping info for
             the function, the current address is not mappable to IL.  An
             IP of 0 is returned.
             MAPPING_PROLOG - the native code is in the prolog, so an IP of
             0 is returned
             MAPPING_EPILOG - the native code is in an epilog, so the last
             IP of the method is returned
             MAPPING_NO_INFO - no mapping info is available for the method,
             so an IP of 0 is returned
            </summary>
            <param name="pnOffset"></param>
            <param name="pMappingResult"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame.SetIP(System.UInt32)">
            <summary>
            SetIP sets the instruction pointer to the IL at the given offset.
            The debugger will do its best to fix up the state of the executing code
            so that it is consistent with the new IP as far as the EE is concerned,
            while preserving as much of the state of the user program as possible.
            Calling SetIP immediately invalidates all frames and chains for the
            current thread; the debugger must perform a new stack trace if it
            requires frame information after calling SetIP.
            </summary>
            <param name="nOffset"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame.EnumerateLocalVariables(JetBrains.Debugger.CorApi.ComInterop.ICorDebugValueEnum@)">
            <summary>
            EnumerateLocalVariables returns a list of the local variables
            available in the frame.  Note that this may not include all of
            the locals in the running function, as some of them may not be
            active.
            </summary>
            <param name="ppValueEnum"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame.GetLocalVariable(System.UInt32,JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            GetLocalVariable gets the value for a local variable
            in an IL frame.  This can be used either in an IL
            frame or a jitted frame.
            </summary>
            <param name="dwIndex"></param>
            <param name="ppValue"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame.EnumerateArguments(JetBrains.Debugger.CorApi.ComInterop.ICorDebugValueEnum@)">
            <summary>
            EnumerateArguments returns a list of the arguments available in the
            frame.  Note that this will include varargs arguments as well as
            arguments declared by the function signature (inlucding the implicit
            "this" argument if any).
            </summary>
            <param name="ppValueEnum"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame.GetArgument(System.UInt32,JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            GetArgument gets the value for an argument
            in an IL frame.  This can be used either in an IL
            frame or a jitted frame.
            For instance (non-static) methods, argument index 0 is the "this" object,
            and the normal explicit arguments start with index 1.
            </summary>
            <param name="dwIndex"></param>
            <param name="ppValue"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame.GetStackDepth(System.UInt32*)">
            <summary>
            NOT YET IMPLEMENTED
            </summary>
            <param name="pDepth"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame.GetStackValue(System.UInt32,JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            NOT YET IMPLEMENTED
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame.CanSetIP(System.UInt32)">
            <summary>
            CanSetIP attempts to determine if it's safe to set the instruction pointer
            to the IL at the given offset. If this returns S_OK, then executing
            SetIP (see above) will result in a safe, correct, continued execution.
            If CanSetIP returns anything else, SetIP can still be invoked, but
            continued, correct execution of the debuggee cannot be guaranteed.
            </summary>
            <param name="nOffset"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame2">
            <summary>
             ICorDebugILFrame2 is a logical extension to ICorDebugILFrame.
            </summary>
            <example><code>
             /*
             * ICorDebugILFrame2 is a logical extension to ICorDebugILFrame.
             */
            [
                object,
                local,
                uuid(5D88A994-6C30-479b-890F-BCEF88B129A5),
                pointer_default(unique)
            ]
            interface ICorDebugILFrame2 : IUnknown
            {
                /*
                 * Performs an on-stack replacement for an outstanding function remap opportunity.
                 * This is used to update execution of an edited function to the latest version, 
                 * preserving the current frame state (such as the values of all locals). 
                 * This can only be called when a FunctionRemapOpportunity callback has been delivered
                 * for this leaf frame, and the callback has not yet been continued.  newILOffset
                 * is the offset into the new function at which execution should continue.
                 * When the remap has completed, a FunctionRemapComplete callback will be delivered.
                 */
                HRESULT RemapFunction([in] ULONG32 newILOffset);
            
                /*
                 * EnumerateTypeParameters returns the type parameters active on a frame.
                 * This will include both the class type parameters (if any) followed by the method type
                 * parameters (if any).
                 * Use the metadata API IMetaDataImport2::EnumGenericParams to determine how many
                 * Class type parameters vs. Method Type parameters there are in this list.
                 * The type parameters will not always be available.
                 */
            
                HRESULT EnumerateTypeParameters([out] ICorDebugTypeEnum **ppTyParEnum);
            
            }; 
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame2.RemapFunction(System.UInt32)">
            <summary>
            Performs an on-stack replacement for an outstanding function remap opportunity.
            This is used to update execution of an edited function to the latest version,
            preserving the current frame state (such as the values of all locals).
            This can only be called when a FunctionRemapOpportunity callback has been delivered
            for this leaf frame, and the callback has not yet been continued.  newILOffset
            is the offset into the new function at which execution should continue.
            When the remap has completed, a FunctionRemapComplete callback will be delivered.
            </summary>
            <param name="newILOffset"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame2.EnumerateTypeParameters(JetBrains.Debugger.CorApi.ComInterop.ICorDebugTypeEnum@)">
            <summary>
            EnumerateTypeParameters returns the type parameters active on a frame.
            This will include both the class type parameters (if any) followed by the method type
            parameters (if any).
            Use the metadata API IMetaDataImport2::EnumGenericParams to determine how many
            Class type parameters vs. Method Type parameters there are in this list.
            The type parameters will not always be available.
            </summary>
            <param name="ppTyParEnum"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame3">
            <summary>
            </summary>
            <example><code>
            [
                object,
                local,
                uuid(9A9E2ED6-04DF-4FE0-BB50-CAB64126AD24),
                pointer_default(unique)
            ]
            interface ICorDebugILFrame3 : IUnknown
            {
                /*
                 *  For the specified IL offset, obtains an ICorDebugValue object that encapsulates
                 *  the return value of a function.  The provided IL offset should be at a function
                 *  call site and the debuggee should be stopped at a breakpoint set at the native
                 *  offset returned by ICorDebugCode3::GetNativeOffsetForReturnValueBreakpoint for
                 *  the same IL offset.
                 *  If the debuggee is not stopped at the correct location for the specified IL offset
                 *  the API will fail.
                 *  If the function call doesn't return a value the API will fail.
                 */
                HRESULT GetReturnValueForILOffset(ULONG32 ILoffset, [out] ICorDebugValue** ppReturnValue);
            };
            </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugILFrame3.GetReturnValueForILOffset(System.UInt32,JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            For the specified IL offset, obtains an ICorDebugValue object that encapsulates
            the return value of a function.  The provided IL offset should be at a function
            call site and the debuggee should be stopped at a breakpoint set at the native
            offset returned by ICorDebugCode3::GetNativeOffsetForReturnValueBreakpoint for
            the same IL offset.
            If the debuggee is not stopped at the correct location for the specified IL offset
            the API will fail.
            If the function call doesn't return a value the API will fail. 
            </summary>
            <param name="ILoffset"></param>
            <param name="ppReturnValue"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugInternalFrame">
            <summary>
            </summary>
            <example><code>
             
            [
                object,
                local,
                uuid(B92CC7F7-9D2D-45c4-BC2B-621FCC9DFBF4),
                pointer_default(unique)
            ]
            interface ICorDebugInternalFrame : ICorDebugFrame
            {
            
                typedef enum CorDebugInternalFrameType
                {
                    // This is a 'null' value for GetFrameType and is included for completeness sake.
                    // ICorDebugInternalFrame::GetFrameType() should never actually return this.
                    STUBFRAME_NONE = 0x00000000,
            
                    // This frame is a M2U stub-frame. This could include both PInvoke
                    // and COM-interop calls.
                    STUBFRAME_M2U = 0x0000001,
            
                    // This is a U2M stub frame.
                    STUBFRAME_U2M = 0x0000002,
            
                    // AppDomain transition.
                    STUBFRAME_APPDOMAIN_TRANSITION = 0x00000003,
            
                    // LightWeight method calls.
                    STUBFRAME_LIGHTWEIGHT_FUNCTION = 0x00000004,
            
                    // Start of Func-eval. This is included for CHF callbacks.
                    // Funcevals also have a chain CHAIN_FUNC_EVAL (legacy from v1.0)
                    STUBFRAME_FUNC_EVAL = 0x00000005,
            
                    // Start of an internal call into the CLR.
                    STUBFRAME_INTERNALCALL = 0x00000006,
            
                    // start of a class initialization; corresponds to CHAIN_CLASS_INIT
                    STUBFRAME_CLASS_INIT = 0x00000007,
            
                    // an exception is thrown; corresponds to CHAIN_EXCEPTION_FILTER
                    STUBFRAME_EXCEPTION = 0x00000008,
            
                    // a frame used for code-access security purposes; corresponds to CHAIN_SECURITY
                    STUBFRAME_SECURITY = 0x00000009,
            
                    // a frame used to mark that the runtime is jitting a managed method
                    STUBFRAME_JIT_COMPILATION = 0x0000000a,
                } CorDebugInternalFrameType;
            
                // Get the type of internal frame. This will never be STUBFRAME_NONE.
                // Debuggers should gracefully ignore unrecognized internal frame types.
                HRESULT GetFrameType([out] CorDebugInternalFrameType * pType);
            
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugInternalFrame.GetChain(JetBrains.Debugger.CorApi.ComInterop.ICorDebugChain@)">
            <summary>
            GetChain returns the chain of which this stack frame is a part.
            </summary>
            <param name="ppChain"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugInternalFrame.GetCode(JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode@)">
            <summary>
            GetCode returns the code which this stack frame is running if any.
            </summary>
            <param name="ppCode"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugInternalFrame.GetFunction(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction@)">
            <summary>
            GetFunction returns the function for the code which this stack
            frame is running.
            For ICorDebugInternalFrames, this may point to a method the
            frame is associated with (which may be in a different AppDomain
            from the frame itself), or may fail if the frame doesn't relate to any
            particular function.
            </summary>
            <param name="ppFunction"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugInternalFrame.GetFunctionToken(System.UInt32*)">
            <summary>
            GetFunctionToken is a convenience routine to return the token for the
            function for the code which this stack frame is running.
            The scope to resolve the token can be gotten from the ICorDebugFunction
            associated with this frame.</summary>
            <param name="pToken"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugInternalFrame.GetStackRange(System.UInt64*,System.UInt64*)">
            <summary>
            GetStackRange returns the absolute address range of the stack
            frame.  (This is useful for piecing together interleaved stack
            traces gathered from multiple debugging engines.)  Note that you
            cannot make any assumptions about what is actually stored on
            the stack - the numeric range is to compare stack frame
            locations only.
            The start of a stack range is the leafmost boundary of the frame, and
            the end of a stack range is the rootmost boundary of the frame.
            </summary>
            <param name="pStart"></param>
            <param name="pEnd"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugInternalFrame.GetCaller(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame@)">
            <summary>
            GetCaller returns a pointer to the frame in the current chain
            which called this frame, or NULL if this is the rootmost frame
            in the chain.
            </summary>
            <param name="ppFrame"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugInternalFrame.GetCallee(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame@)">
            <summary>
            GetCallee returns a pointer to the frame in the current chain
            which this frame called, or NULL if this is the leafmost frame
            in the chain.
            </summary>
            <param name="ppFrame"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugInternalFrame.CreateStepper(JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper@)">
            <summary>
            CreateStepper creates a stepper object which operates relative to the
            frame. The Stepper API must then be used to perform actual stepping.
            Note that if this frame is not active, the frame will typically have to
            be returned to before the step is completed.
            </summary>
            <param name="ppStepper"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugInternalFrame.GetFrameType(JetBrains.Debugger.CorApi.ComInterop.CorDebugInternalFrameType*)">
            <summary>
            Get the type of internal frame. This will never be STUBFRAME_NONE.
            Debuggers should gracefully ignore unrecognized internal frame types.
            </summary>
            <param name="pType"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugInternalFrame2">
            <summary>
            </summary>
            <example><code>
             [
                object,
                local,
                uuid(C0815BDC-CFAB-447e-A779-C116B454EB5B),
                pointer_default(unique)
            ]
            interface ICorDebugInternalFrame2 : IUnknown
            {
                /*
                 * Returns the stack address of the internal frame marker.
                 */
                HRESULT GetAddress([out] CORDB_ADDRESS *pAddress);
            
                 * Check if an internal frame is closer to the leaf than pFrameToCompare.
                 */
                HRESULT IsCloserToLeaf([in] ICorDebugFrame * pFrameToCompare, 
                                       [out] BOOL * pIsCloser);
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugInternalFrame2.GetAddress(System.UInt64*)">
            <summary>
            Returns the stack address of the internal frame marker.
            </summary>
            <param name="pAddress"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugInternalFrame2.IsCloserToLeaf(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame,System.Int32*)">
            <summary>
            Check if an internal frame is closer to the leaf than pFrameToCompare.
            </summary>
            <param name="pFrameToCompare"></param>
            <param name="pIsCloser"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback">
             <summary>
             ICorDebugManagedCallback is implemented by the user of the
             ICorDebug interfaces in order to respond to events in managed code
             in the debuggee process.
             This interface handles manage debug events from v1.0/v1.1
             
             All callbacks are called with the process in the synchronized state
             All callbacks are serialized, and are called in in the same thread.
             Each callback implementor must call Continue in a callback to
                  resume execution.
             If Continue is not called before returning, the process will
             remain stopped. Continue must later be called before any more
             event callbacks will happen.
             </summary>
             <example><code>
             /*
             * ICorDebugManagedCallback is implemented by the user of the
             * ICorDebug interfaces in order to respond to events in managed code
             * in the debuggee process.
             * This interface handles manage debug events from v1.0/v1.1
             */
            
            [
                object,
                local,
                uuid(3d6f5f60-7538-11d3-8d5b-00104b35e7ef),
                pointer_default(unique)
            ]
            interface ICorDebugManagedCallback : IUnknown
            {
                /*
                 * All callbacks are called with the process in the synchronized state
                 * All callbacks are serialized, and are called in in the same thread.
                 * Each callback implementor must call Continue in a callback to
                 *      resume execution.
                 * If Continue is not called before returning, the process will
                 * remain stopped. Continue must later be called before any more
                 * event callbacks will happen.
                 *
                 */
            
                /*
                 * Breakpoint is called when a breakpoint is hit.
                 */
            
                HRESULT Breakpoint(ICorDebugAppDomain *pAppDomain,
                                   ICorDebugThread *pThread,
                                   ICorDebugBreakpoint *pBreakpoint);
            
                /*
                 * StepComplete is called when a step has completed.  The stepper
                 * may be used to continue stepping if desired (except for TERMINATE
                 * reasons.)
                 *
                 * STEP_NORMAL means that stepping completed normally, in the same
                 *      function.
                 *
                 * STEP_RETURN means that stepping continued normally, after the function
                 *      returned.
                 *
                 * STEP_CALL means that stepping continued normally, at the start of
                 *      a newly called function.
                 *
                 * STEP_EXCEPTION_FILTER means that control passed to an exception filter
                 *      after an exception was thrown.
                 *
                 * STEP_EXCEPTION_HANDLER means that control passed to an exception handler
                 *      after an exception was thrown.
                 *
                 * STEP_INTERCEPT means that control passed to an interceptor.
                 *
                 * STEP_EXIT means that the thread exited before the step completed.
                 *      No more stepping can be performed with the stepper.
                 */
            
                typedef enum CorDebugStepReason
                {
                    STEP_NORMAL,
                    STEP_RETURN,
                    STEP_CALL,
                    STEP_EXCEPTION_FILTER,
                    STEP_EXCEPTION_HANDLER,
                    STEP_INTERCEPT,
                    STEP_EXIT
                } CorDebugStepReason;
            
                HRESULT StepComplete(ICorDebugAppDomain *pAppDomain,
                                     ICorDebugThread *pThread,
                                     ICorDebugStepper *pStepper,
                                     CorDebugStepReason reason);
            
                /*
                 * Break is called when a break opcode in the code stream is
                 * executed.
                 */
            
                HRESULT Break(ICorDebugAppDomain *pAppDomain,
                              ICorDebugThread *thread);
            
                /*
                 * Exception is called when an exception is thrown from managed
                 * code, The specific exception can be retrieved from the thread object.
                 *
                 * If unhandled is FALSE, this is a "first chance" exception that
                 * hasn't had a chance to be processed by the application.  If
                 * unhandled is TRUE, this is an unhandled exception which will
                 * terminate the process.
                 */
            
                HRESULT Exception(ICorDebugAppDomain *pAppDomain,
                                  ICorDebugThread *pThread,
                                  BOOL unhandled);
            
                /*
                 * EvalComplete is called when an evaluation is completed.
                 */
            
                HRESULT EvalComplete(ICorDebugAppDomain *pAppDomain,
                                     ICorDebugThread *pThread,
                                     ICorDebugEval *pEval);
            
                /*
                 * EvalException is called when an evaluation terminates with
                 * an unhandled exception.
                 */
            
                HRESULT EvalException(ICorDebugAppDomain *pAppDomain,
                                      ICorDebugThread *pThread,
                                      ICorDebugEval *pEval);
            
                /*
                 * CreateProcess is called when a process is first attached to or
                 * started.
                 *
                 * This entry point won't be called until the EE is initialized.
                 * Most of the ICorDebug API will return CORDBG_E_NOTREADY prior
                 * to the CreateProcess callback.
                 */
            
                HRESULT CreateProcess(ICorDebugProcess *pProcess);
            
                /*
                 * ExitProcess is called when a process exits.
                 *
                 * Note: you don't Continue from an ExitProcess event, and this
                 * event may fire asynchronously to other events, while the
                 * process appears to be stopped. This can occur if the process
                 * dies while stopped, usually due to some external force.
                 *
                 * If the CLR is already dispatching a managed callback, this event
                 * will be delayed until after that callback has returned.
                 *
                 * This is the only exit/unload event that is guaranteed to get called
                 * on shutdown.
                 */
            
                HRESULT ExitProcess(ICorDebugProcess *pProcess);
            
                /*
                 * CreateThread is called when a thread first begins executing managed
                 * code. The thread will be positioned immediately at the first
                 * managed code to be executed.
                 */
            
                HRESULT CreateThread(ICorDebugAppDomain *pAppDomain,
                                     ICorDebugThread *thread);
            
                /*
                 * ExitThread is called when a thread which has run managed code exits. 
                 * Once this callback is fired, the thread no longer will appear in thread enumerations.
                 */
            
                HRESULT ExitThread(ICorDebugAppDomain *pAppDomain,
                                   ICorDebugThread *thread);
            
                /*
                 * LoadModule is called when a Common Language Runtime module is successfully
                 * loaded. This is an appropriate time to examine metadata for the
                 * module, set JIT compiler flags, or enable or disable
                 * class loading callbacks for the module.
                 */
            
                HRESULT LoadModule(ICorDebugAppDomain *pAppDomain,
                                   ICorDebugModule *pModule);
            
                /*
                 * UnloadModule is called when a Common Language Runtime module (DLL) is unloaded. The module
                 * should not be used after this point.
                 */
            
                HRESULT UnloadModule(ICorDebugAppDomain *pAppDomain,
                                     ICorDebugModule *pModule);
            
                /*
                 * LoadClass is called when a class finishes loading.  This callback only
                 * occurs if ClassLoading has been enabled for the class's module.
                 *
                 * ClassLoading is always enabled for dynamic modules. This is a good time
                 * to update symbols (ICorDebugModule3::CreateReaderForInMemorySymbols) and
                 * bind breakpoints to newly generated classes in dynamic modules.
                 */
            
                HRESULT LoadClass(ICorDebugAppDomain *pAppDomain,
                                  ICorDebugClass *c);
            
                /*
                 * UnloadClass is called immediately before a class is unloaded. The class
                 * should not be referenced after this point. This callback only occurs if
                 * ClassLoading has been enabled for the class's module.
                 */
            
                HRESULT UnloadClass(ICorDebugAppDomain *pAppDomain,
                                    ICorDebugClass *c);
            
                /*
                 * DebuggerError is called when an error occurs while attempting to
                 * handle an event from the Common Language Runtime. It is very strongly
                 * advised that debuggers log this message to the end user because
                 * this callback indicates the debugging services have been disabled due to
                 * an error.
                 *
                 * ICorDebugProcess::GetID() will be safe to call, but all other APIs should
                 * not be called and will fail if they are.
                 * This includes ICorDebugProcess::Terminate and ICorDebug  Process::Detach. The
                 * debugger should use OS facilities for terminating processes to shut down the process.
                 */
                HRESULT DebuggerError(ICorDebugProcess *pProcess,
                                      HRESULT errorHR,
                                      DWORD errorCode);
            
            
                /*
                 * Enum defining log message LoggingLevels
                 */
                typedef enum LoggingLevelEnum
                {
                    LTraceLevel0 = 0,
                    LTraceLevel1,
                    LTraceLevel2,
                    LTraceLevel3,
                    LTraceLevel4,
                    LStatusLevel0 = 20,
                    LStatusLevel1,
                    LStatusLevel2,
                    LStatusLevel3,
                    LStatusLevel4,
                    LWarningLevel = 40,
                    LErrorLevel = 50,
                    LPanicLevel = 100
                } LoggingLevelEnum;
            
            
                typedef enum LogSwitchCallReason
                {
                    SWITCH_CREATE,
                    SWITCH_MODIFY,
                    SWITCH_DELETE
                } LogSwitchCallReason;
            
            
                /*
                 * LogMessage is called when a Common Language Runtime managed thread calls the Log
                 * class in the System.Diagnostics package to log an event.
                 */
                HRESULT LogMessage(ICorDebugAppDomain *pAppDomain,
                                   ICorDebugThread *pThread,
                                   LONG lLevel,
                                   WCHAR *pLogSwitchName,
                                   WCHAR *pMessage);
            
                /*
                 * LogSwitch is called when a Common Language Runtime managed thread calls the LogSwitch
                 * class in the System.Diagnostics package to create/modify a LogSwitch.
                 */
                HRESULT LogSwitch(ICorDebugAppDomain *pAppDomain,
                                  ICorDebugThread *pThread,
                                  LONG lLevel,
                                  ULONG ulReason,
                                  WCHAR *pLogSwitchName,
                                  WCHAR *pParentName);
            
                /*
                 * CreateAppDomain is called when an app domain is created.
                 */
                HRESULT CreateAppDomain(ICorDebugProcess *pProcess,
                                        ICorDebugAppDomain *pAppDomain);
            
                /*
                 * ExitAppDomain is called when an app domain exits.
                 */
                HRESULT ExitAppDomain(ICorDebugProcess *pProcess,
                                      ICorDebugAppDomain *pAppDomain);
            
            
                /*
                 * LoadAssembly is called when a Common Language Runtime assembly is successfully
                 * loaded.
                 */
                HRESULT LoadAssembly(ICorDebugAppDomain *pAppDomain,
                                     ICorDebugAssembly *pAssembly);
            
                /*
                 * UnloadAssembly is called when a Common Language Runtime assembly is unloaded. The assembly
                 * should not be used after this point.
                 */
                HRESULT UnloadAssembly(ICorDebugAppDomain *pAppDomain,
                                       ICorDebugAssembly *pAssembly);
            
                /*
                 * ControlCTrap is called if a CTRL-C is trapped in the process being
                 * debugged. All appdomains within the process are stopped for
                 * this callback.
                 * Return values:
                 *      S_OK    : Debugger will handle the ControlC Trap
                 *      S_FALSE : Debugger won't handle the ControlC Trap
                 */
                HRESULT ControlCTrap(ICorDebugProcess *pProcess);
            
                /*
                 * NameChange() is called if either an AppDomain's or
                 * Thread's name changes.
                 */
                HRESULT NameChange(ICorDebugAppDomain *pAppDomain,
                                   ICorDebugThread *pThread);
            
                /*
                 * UpdateModuleSymbols is called when PDB debug symbols are available for an 
                 * in-memory module. This is a debugger's chance to load the symbols 
                 * (using ISymUnmanagedBinder::GetReaderForStream), and bind source-level
                 * breakpoints for the module.
                 * 
                 * This callback is no longer dispatched for dynamic modules.  Instead,
                 * debuggers should call ICorDebugModule3::CreateReaderForInMemorySymbols
                 * to obtain a symbol reader for a dynamic module.  
                 */
                HRESULT UpdateModuleSymbols(ICorDebugAppDomain *pAppDomain,
                                            ICorDebugModule *pModule,
                                            IStream *pSymbolStream);
            
            
                /*
                 * DEPRECATED
                 */
                HRESULT EditAndContinueRemap(ICorDebugAppDomain *pAppDomain,
                                             ICorDebugThread *pThread,
                                             ICorDebugFunction *pFunction,
                                             BOOL fAccurate);
            
                /*
                 * BreakpointSetError is called if the CLR was unable to accuratley bind a breakpoint that
                 * was set before a function was JIT compiled. The given breakpoint will never be hit. The
                 * debugger should deactivate it and rebind it appropiatley.
                 */
                HRESULT BreakpointSetError(ICorDebugAppDomain *pAppDomain,
                                           ICorDebugThread *pThread,
                                           ICorDebugBreakpoint *pBreakpoint,
                                           DWORD dwError);
            };
            
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback.Breakpoint(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread,JetBrains.Debugger.CorApi.ComInterop.ICorDebugBreakpoint)">
            <summary>
            Breakpoint is called when a breakpoint is hit.
            </summary>
            <param name="pAppDomain"></param>
            <param name="pThread"></param>
            <param name="pBreakpoint"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback.StepComplete(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread,JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper,JetBrains.Debugger.CorApi.ComInterop.CorDebugStepReason)">
            <summary>
            StepComplete is called when a step has completed.  The stepper
            may be used to continue stepping if desired (except for TERMINATE
            reasons.)
            
            STEP_NORMAL means that stepping completed normally, in the same
                 function.
            
            STEP_RETURN means that stepping continued normally, after the function
                 returned.
            
            STEP_CALL means that stepping continued normally, at the start of
                 a newly called function.
            
            STEP_EXCEPTION_FILTER means that control passed to an exception filter
                 after an exception was thrown.
            
            STEP_EXCEPTION_HANDLER means that control passed to an exception handler
                 after an exception was thrown.
            
            STEP_INTERCEPT means that control passed to an interceptor.
            
            STEP_EXIT means that the thread exited before the step completed.
                 No more stepping can be performed with the stepper.
            </summary>
            <param name="pAppDomain"></param>
            <param name="pThread"></param>
            <param name="pStepper"></param>
            <param name="reason"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback.Break(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread)">
            <summary>
             Break is called when a break opcode in the code stream is
             executed.
            </summary>
            <param name="pAppDomain"></param>
            <param name="thread"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback.Exception(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread,System.Int32)">
            <summary>
            Exception is called when an exception is thrown from managed
            code, The specific exception can be retrieved from the thread object.
            
            If unhandled is FALSE, this is a "first chance" exception that
            hasn't had a chance to be processed by the application.  If
            unhandled is TRUE, this is an unhandled exception which will
            terminate the process.
            
            </summary>
            <param name="pAppDomain"></param>
            <param name="pThread"></param>
            <param name="unhandled"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback.EvalComplete(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread,JetBrains.Debugger.CorApi.ComInterop.ICorDebugEval)">
            <summary>
            EvalComplete is called when an evaluation is completed.
            </summary>
            <param name="pAppDomain"></param>
            <param name="pThread"></param>
            <param name="pEval"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback.EvalException(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread,JetBrains.Debugger.CorApi.ComInterop.ICorDebugEval)">
            <summary>
            EvalException is called when an evaluation terminates with
            an unhandled exception.
            </summary>
            <param name="pAppDomain"></param>
            <param name="pThread"></param>
            <param name="pEval"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback.CreateProcess(JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess)">
            <summary>
            CreateProcess is called when a process is first attached to or
            started.
            
            This entry point won't be called until the EE is initialized.
            Most of the ICorDebug API will return CORDBG_E_NOTREADY prior
            to the CreateProcess callback.
            </summary>
            <param name="pProcess"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback.ExitProcess(JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess)">
            <summary>
            ExitProcess is called when a process exits.
            
            Note: you don't Continue from an ExitProcess event, and this
            event may fire asynchronously to other events, while the
            process appears to be stopped. This can occur if the process
            dies while stopped, usually due to some external force.
            
            If the CLR is already dispatching a managed callback, this event
            will be delayed until after that callback has returned.
            
            This is the only exit/unload event that is guaranteed to get called
            on shutdown.
            </summary>
            <param name="pProcess"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback.CreateThread(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread)">
            <summary>
            CreateThread is called when a thread first begins executing managed
            code. The thread will be positioned immediately at the first
            managed code to be executed.
            </summary>
            <param name="pAppDomain"></param>
            <param name="thread"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback.ExitThread(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread)">
            <summary>
            ExitThread is called when a thread which has run managed code exits. 
            Once this callback is fired, the thread no longer will appear in thread enumerations.
            </summary>
            <param name="pAppDomain"></param>
            <param name="thread"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback.LoadModule(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain,JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule)">
            <summary>
            LoadModule is called when a Common Language Runtime module is successfully
            loaded. This is an appropriate time to examine metadata for the
            module, set JIT compiler flags, or enable or disable
            class loading callbacks for the module.
            </summary>
            <param name="pAppDomain"></param>
            <param name="pModule"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback.UnloadModule(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain,JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule)">
            <summary>
            UnloadModule is called when a Common Language Runtime module (DLL) is unloaded. The module
            should not be used after this point.
            </summary>
            <param name="pAppDomain"></param>
            <param name="pModule"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback.LoadClass(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain,JetBrains.Debugger.CorApi.ComInterop.ICorDebugClass)">
            <summary>
            LoadClass is called when a class finishes loading.  This callback only
            occurs if ClassLoading has been enabled for the class's module.
            
            ClassLoading is always enabled for dynamic modules. This is a good time
            to update symbols (ICorDebugModule3::CreateReaderForInMemorySymbols) and
            bind breakpoints to newly generated classes in dynamic modules.
            </summary>
            <param name="pAppDomain"></param>
            <param name="c"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback.UnloadClass(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain,JetBrains.Debugger.CorApi.ComInterop.ICorDebugClass)">
            <summary>
            UnloadClass is called immediately before a class is unloaded. The class
            should not be referenced after this point. This callback only occurs if
            ClassLoading has been enabled for the class's module.
            </summary>
            <param name="pAppDomain"></param>
            <param name="c"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback.DebuggerError(JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess,System.Int32,System.UInt32)">
            <summary>
            DebuggerError is called when an error occurs while attempting to
            handle an event from the Common Language Runtime. It is very strongly
            advised that debuggers log this message to the end user because
            this callback indicates the debugging services have been disabled due to
            an error.
            
            ICorDebugProcess::GetID() will be safe to call, but all other APIs should
            not be called and will fail if they are.
            This includes ICorDebugProcess::Terminate and ICorDebug  Process::Detach. The
            debugger should use OS facilities for terminating processes to shut down the process.
            </summary>
            <param name="pProcess"></param>
            <param name="errorHR"></param>
            <param name="errorCode"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback.LogMessage(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread,System.Int32,System.UInt16*,System.UInt16*)">
            <summary>
            LogMessage is called when a Common Language Runtime managed thread calls the Log
            class in the System.Diagnostics package to log an event.
            </summary>
            <param name="pAppDomain"></param>
            <param name="pThread"></param>
            <param name="lLevel"><see cref="T:JetBrains.Debugger.CorApi.ComInterop.LoggingLevelEnum"/></param>
            <param name="pLogSwitchName"></param>
            <param name="pMessage"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback.LogSwitch(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread,System.Int32,System.UInt32,System.UInt16*,System.UInt16*)">
            <summary>
            LogSwitch is called when a Common Language Runtime managed thread calls the LogSwitch
            class in the System.Diagnostics package to create/modify a LogSwitch.
            </summary>
            <param name="pAppDomain"></param>
            <param name="pThread"></param>
            <param name="lLevel"><see cref="T:JetBrains.Debugger.CorApi.ComInterop.LoggingLevelEnum"/></param>
            <param name="ulReason"><see cref="T:JetBrains.Debugger.CorApi.ComInterop.LogSwitchCallReason"/></param>
            <param name="pLogSwitchName"></param>
            <param name="pParentName"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback.CreateAppDomain(JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess,JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain)">
            <summary>
            CreateAppDomain is called when an app domain is created.
            </summary>
            <param name="pProcess"></param>
            <param name="pAppDomain"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback.ExitAppDomain(JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess,JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain)">
            <summary>
            ExitAppDomain is called when an app domain exits.
            </summary>
            <param name="pProcess"></param>
            <param name="pAppDomain"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback.LoadAssembly(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain,JetBrains.Debugger.CorApi.ComInterop.ICorDebugAssembly)">
            <summary>
            LoadAssembly is called when a Common Language Runtime assembly is successfully
            loaded.
            </summary>
            <param name="pAppDomain"></param>
            <param name="pAssembly"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback.UnloadAssembly(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain,JetBrains.Debugger.CorApi.ComInterop.ICorDebugAssembly)">
            <summary>
            UnloadAssembly is called when a Common Language Runtime assembly is unloaded. The assembly
            should not be used after this point.
            </summary>
            <param name="pAppDomain"></param>
            <param name="pAssembly"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback.ControlCTrap(JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess)">
            <summary>
            ControlCTrap is called if a CTRL-C is trapped in the process being
            debugged. All appdomains within the process are stopped for
            this callback.
            Return values:
                 S_OK    : Debugger will handle the ControlC Trap
                 S_FALSE : Debugger won't handle the ControlC Trap
            </summary>
            <param name="pProcess"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback.NameChange(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread)">
            <summary>
            NameChange() is called if either an AppDomain's or
            Thread's name changes.
            </summary>
            <param name="pAppDomain"></param>
            <param name="pThread"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback.UpdateModuleSymbols(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain,JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule,JetBrains.Debugger.CorApi.ComInterop.IStream)">
            <summary>
            UpdateModuleSymbols is called when PDB debug symbols are available for an 
            in-memory module. This is a debugger's chance to load the symbols 
            (using ISymUnmanagedBinder::GetReaderForStream), and bind source-level
            breakpoints for the module.
            
            This callback is no longer dispatched for dynamic modules.  Instead,
            debuggers should call ICorDebugModule3::CreateReaderForInMemorySymbols
            to obtain a symbol reader for a dynamic module.  
            </summary>
            <param name="pAppDomain"></param>
            <param name="pModule"></param>
            <param name="pSymbolStream"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback.EditAndContinueRemap(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread,JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction,System.Int32)">
            <summary>
            DEPRECATED
            </summary>
            <param name="pAppDomain"></param>
            <param name="pThread"></param>
            <param name="pFunction"></param>
            <param name="fAccurate"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback.BreakpointSetError(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread,JetBrains.Debugger.CorApi.ComInterop.ICorDebugBreakpoint,System.UInt32)">
            <summary>
            BreakpointSetError is called if the CLR was unable to accuratley bind a breakpoint that
            was set before a function was JIT compiled. The given breakpoint will never be hit. The
            debugger should deactivate it and rebind it appropiatley.
            </summary>
            <param name="pAppDomain"></param>
            <param name="pThread"></param>
            <param name="pBreakpoint"></param>
            <param name="dwError"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback2">
            <summary>
             ICorDebugManagedCallback2 is a logical extension to ICorDebugManagedCallback.
             This handles new debug events introduced in V2.0. A debugger's callback object
             to ICorDebug::SetManagedHandler must implement this interface if it is debugging v2.0 apps.
            </summary>
            <example><code>
             
              * ICorDebugManagedCallback2 is a logical extension to ICorDebugManagedCallback.
              * This handles new debug events introduced in V2.0. A debugger's callback object
              * to ICorDebug::SetManagedHandler must implement this interface if it is debugging v2.0 apps.
              */
            [
                object,
                local,
                uuid(250E5EEA-DB5C-4C76-B6F3-8C46F12E3203),
                pointer_default(unique)
            ]
            interface ICorDebugManagedCallback2 : IUnknown
            {
            
               /*
                 * FunctionRemapOpportunity is fired whenever execution reaches a sequence point in an older version
                 * of an edited function. This event gives the debugger an opportunity to remap the IP to its proper
                 * place in the new version by calling ICorDebugILFrame2::RemapFunction. If the debugger does not call
                 * RemapFunction before calling Continue, the runtime will continue executing the old code and will
                 * fire another FunctionRemapOpportunity callback at the next sequence point
                 */
                HRESULT FunctionRemapOpportunity(ICorDebugAppDomain *pAppDomain,
                                                 ICorDebugThread *pThread,
                                                 ICorDebugFunction *pOldFunction,
                                                 ICorDebugFunction *pNewFunction,
                                                 ULONG32 oldILOffset);
            
                /*
                 * CreateConnection is called when a new connection is created.
                 */
                HRESULT CreateConnection(ICorDebugProcess *pProcess,
                                         CONNID dwConnectionId,
                                         WCHAR *pConnName);
            
                /*
                 * ChangeConnection is called when a connection's set of tasks changes.
                 */
                HRESULT ChangeConnection(ICorDebugProcess *pProcess,
                                         CONNID dwConnectionId );
            
                /*
                 * DestroyConnection is called when a connection is ended.
                 */
                HRESULT DestroyConnection(ICorDebugProcess *pProcess,
                                          CONNID dwConnectionId );
            
            
            
            
            
            
                typedef enum CorDebugExceptionCallbackType
                {
                    DEBUG_EXCEPTION_FIRST_CHANCE = 1,        /* Fired when exception thrown */
                    DEBUG_EXCEPTION_USER_FIRST_CHANCE = 2,   /* Fired when search reaches first user code */
                    DEBUG_EXCEPTION_CATCH_HANDLER_FOUND = 3, /* Fired if &amp; when search finds a handler */
                    DEBUG_EXCEPTION_UNHANDLED = 4            /* Fired if search doesnt find a handler */
                } CorDebugExceptionCallbackType;
            
            
                typedef enum CorDebugExceptionFlags
                {
                    DEBUG_EXCEPTION_NONE = 0,
                    DEBUG_EXCEPTION_CAN_BE_INTERCEPTED = 0x0001 /* Indicates interceptable exception */
                } CorDebugExceptionFlags;
            
            
                /*
                 * Exception is called at various points during the search phase of the
                 * exception-handling process.  The exception being processed can be
                 * retrieved from the ICorDebugThread.
                 */
                HRESULT Exception( ICorDebugAppDomain *pAppDomain,
                                   ICorDebugThread *pThread,
                                   ICorDebugFrame *pFrame,
                                   ULONG32 nOffset,
                                   CorDebugExceptionCallbackType dwEventType,
                                   DWORD dwFlags );
            
            
                typedef enum CorDebugExceptionUnwindCallbackType
                {
                    DEBUG_EXCEPTION_UNWIND_BEGIN = 1, /* Fired at the beginning of the unwind */
                    DEBUG_EXCEPTION_INTERCEPTED = 2   /* Fired after an exception has been intercepted */
                } CorDebugExceptionUnwindCallbackType;
            
            
            
                /*
                 * For non-intercepted exceptions, ExceptionUnwind is called at the beginning of the second pass 
                 * when we start to unwind the stack.  For intercepted exceptions, ExceptionUnwind is called when
                 * the interception is complete, conceptually at the end of the second pass.
                 *
                 * dwFlags is not currently used.
                 */
                HRESULT ExceptionUnwind( ICorDebugAppDomain *pAppDomain,
                                         ICorDebugThread *pThread,
                                         CorDebugExceptionUnwindCallbackType dwEventType,
                                         DWORD dwFlags );
            
                /*
                 * FunctionRemapComplete is fired whenever execution has completed switching over to a
                 * new version of an edited function (as requested by a call to ICorDebugILFrame2::RemapFunction).
                 * At this point (and no sooner) steppers can be added to that new version of the function.
                 */
                HRESULT FunctionRemapComplete(ICorDebugAppDomain *pAppDomain,
                                                                                ICorDebugThread *pThread,
                                                                                ICorDebugFunction *pFunction);
            
                // Notification that an Managed Debug Assistant (MDA) was hit in the debuggee process.
                // - MDAs are heuristic warnings and do not require any explicit debugger action (other than continue, of course) for proper functionality.
                // - The CLR can change what MDAs are fired (and what data is in any given MDA) at any point.
                // - Therefore, debuggers should not build any specific functionality requiring specific MDAs patterns.
                // - MDAs may be queued and fired "after the fact". This could happen if the runtime needs to slip from when an
                //   MDA occurs to get to a safe point for firing it. It also means the runtime reserves the right to fire a bunch of MDAs
                //   in a single set of callback queue (similar for what we do w/ attach events).
                //
                // See the MDA documentation for how to enable / disable notifications.
                //
                // Parameters:
                // - pController is the controller object (process or appdomain) that the MDA occurred in.
                //     Clients should not make any assumption about whether the controller is a process or appdomain (though they can
                //     always QI to find out).
                //     Call continue on this to resume the debuggee.
                // - pThread - managed thread on which the debug event occurred. If the MDA occurred on an unmanaged thread then
                //     this will be null. Get the OS thread ID from the MDA object itself.
                // - pMDA is an object containing MDA information.
                //    Suggested usage is that the client does not keep a reference to the MDA object after returning from this callback
                //    because that lets the CLR quickly recycle the MDA's memory. This could be a performance win if there are
                //    lots of MDAs firing.
                HRESULT MDANotification(
                    ICorDebugController * pController,
                    ICorDebugThread *pThread,
                    ICorDebugMDA * pMDA
                );
            
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback2.FunctionRemapOpportunity(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread,JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction,JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction,System.UInt32)">
            <summary>
            FunctionRemapOpportunity is fired whenever execution reaches a sequence point in an older version
            of an edited function. This event gives the debugger an opportunity to remap the IP to its proper
            place in the new version by calling ICorDebugILFrame2::RemapFunction. If the debugger does not call
            RemapFunction before calling Continue, the runtime will continue executing the old code and will
            fire another FunctionRemapOpportunity callback at the next sequence point
            </summary>
            <param name="pAppDomain"></param>
            <param name="pThread"></param>
            <param name="pOldFunction"></param>
            <param name="pNewFunction"></param>
            <param name="oldILOffset"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback2.CreateConnection(JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess,System.UInt32,System.UInt16*)">
            <summary>
            CreateConnection is called when a new connection is created.
            </summary>
            <param name="pProcess"></param>
            <param name="dwConnectionId"></param>
            <param name="pConnName"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback2.ChangeConnection(JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess,System.UInt32)">
            <summary>
            ChangeConnection is called when a connection's set of tasks changes.
            </summary>
            <param name="pProcess"></param>
            <param name="dwConnectionId"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback2.DestroyConnection(JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess,System.UInt32)">
            <summary>
            DestroyConnection is called when a connection is ended.
            </summary>
            <param name="pProcess"></param>
            <param name="dwConnectionId"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback2.Exception(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread,JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame,System.UInt32,JetBrains.Debugger.CorApi.ComInterop.CorDebugExceptionCallbackType,System.UInt32)">
            <summary>
            Exception is called at various points during the search phase of the
            exception-handling process.  The exception being processed can be
            retrieved from the ICorDebugThread.
            </summary>
            <param name="pAppDomain"></param>
            <param name="pThread"></param>
            <param name="pFrame"></param>
            <param name="nOffset"></param>
            <param name="dwEventType"></param>
            <param name="dwFlags"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback2.ExceptionUnwind(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread,JetBrains.Debugger.CorApi.ComInterop.CorDebugExceptionUnwindCallbackType,System.UInt32)">
            <summary>
            For non-intercepted exceptions, ExceptionUnwind is called at the beginning of the second pass
            when we start to unwind the stack.  For intercepted exceptions, ExceptionUnwind is called when
            the interception is complete, conceptually at the end of the second pass.
            dwFlags is not currently used.
            </summary>
            <param name="pAppDomain"></param>
            <param name="pThread"></param>
            <param name="dwEventType"></param>
            <param name="dwFlags"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback2.FunctionRemapComplete(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread,JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction)">
            <summary>
            FunctionRemapComplete is fired whenever execution has completed switching over to a
            new version of an edited function (as requested by a call to ICorDebugILFrame2::RemapFunction).
            At this point (and no sooner) steppers can be added to that new version of the function.
            </summary>
            <param name="pAppDomain"></param>
            <param name="pThread"></param>
            <param name="pFunction"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback2.MDANotification(JetBrains.Debugger.CorApi.ComInterop.ICorDebugController,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread,JetBrains.Debugger.CorApi.ComInterop.ICorDebugMDA)">
            <summary>
             Notification that an Managed Debug Assistant (MDA) was hit in the debuggee process.
             - MDAs are heuristic warnings and do not require any explicit debugger action (other than continue, of course) for proper functionality.
             - The CLR can change what MDAs are fired (and what data is in any given MDA) at any point.
             - Therefore, debuggers should not build any specific functionality requiring specific MDAs patterns.
             - MDAs may be queued and fired "after the fact". This could happen if the runtime needs to slip from when an
               MDA occurs to get to a safe point for firing it. It also means the runtime reserves the right to fire a bunch of MDAs
               in a single set of callback queue (similar for what we do w/ attach events).
             See the MDA documentation for how to enable / disable notifications.
             Parameters:
             - pController is the controller object (process or appdomain) that the MDA occurred in.
                 Clients should not make any assumption about whether the controller is a process or appdomain (though they can
                 always QI to find out).
                 Call continue on this to resume the debuggee.
             - pThread - managed thread on which the debug event occurred. If the MDA occurred on an unmanaged thread then
                 this will be null. Get the OS thread ID from the MDA object itself.
             - pMDA is an object containing MDA information.
                Suggested usage is that the client does not keep a reference to the MDA object after returning from this callback
                because that lets the CLR quickly recycle the MDA's memory. This could be a performance win if there are
                lots of MDAs firing.
            </summary>
            <param name="pController"></param>
            <param name="pThread"></param>
            <param name="pMDA"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback3.CustomNotification(JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread,JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain)">
             <summary>
             Indicates that a custom debugger notification has been raised.
            
             A subsequent call to the ICorDebugThread4::GetCurrentCustomDebuggerNotification method retrieves the thread
             object that was passed to the Debugger.NotifyOfCrossThreadDependency method.
             The thread object's type must have been previously enabled by calling the
             ICorDebugProcess3::SetEnableCustomNotification method.
             The debugger can read type-specific parameters from the fields of the thread object,
             and can store responses into fields.
            
             The ICorDebug interface imposes no policy on the types of notifications or their contents,
             and the semantics of the notifications are strictly a contract between debuggers, applications, and the .NET Framework.
             </summary>
             <param name="pThread">[in] A pointer to the thread that raised the notification.</param>
             <param name="pAppDomain">[in] A pointer to the application domain that contains the thread that raised the notification.</param>
             <returns>This method returns the following specific HRESULTs as well as HRESULT errors that indicate method failure.</returns>
             <seealso cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread4.GetCurrentCustomDebuggerNotification(JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)"/>
             <seealso cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess3.SetEnableCustomNotification(JetBrains.Debugger.CorApi.ComInterop.ICorDebugClass,System.Int32)"/>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugMDA">
            <summary>
             Represent data for an Managed Debugging Assistant (MDA) notification. See the MDA documentation for MDA-specific information like:
             - enabling / disabling MDAs
             - MDA naming conventions
             - What the contents of an MDA look like, schemas, etc.
            </summary>
            <example><code>
             // Represent data for an Managed Debugging Assistant (MDA) notification. See the MDA documentation for MDA-specific information like:
             // - enabling / disabling MDAs
             // - MDA naming conventions
             // - What the contents of an MDA look like, schemas, etc.
            [
                object,
                local,
                uuid(CC726F2F-1DB7-459b-B0EC-05F01D841B42),
                pointer_default(unique)
            ]
            interface ICorDebugMDA : IUnknown
            {
                // Get the string for the type of the MDA. Never empty.
                // This is a convenient performant alternative to getting the XML stream and extracting
                // the type from that based off the schema.
                HRESULT GetName(
                    [in] ULONG32 cchName,
                    [out] ULONG32 * pcchName,
                    [out, size_is(cchName), length_is(*pcchName)] WCHAR szName[]);
            
                // Get a string description of the MDA. This may be empty (0-length).
                HRESULT GetDescription(
                    [in] ULONG32 cchName,
                    [out] ULONG32 * pcchName,
                    [out, size_is(cchName), length_is(*pcchName)] WCHAR szName[]);
            
                // Get the full associated XML for the MDA. This may be empty.
                // This could be a potentially expensive operation if the xml stream is large.
                // See the MDA documentation for the schema for this XML stream.
                HRESULT GetXML(
                    [in] ULONG32 cchName,
                    [out] ULONG32 * pcchName,
                    [out, size_is(cchName), length_is(*pcchName)] WCHAR szName[]);
            
                // Get the flags associated w/ the MDA. New flags may be added in future versions.
                typedef enum CorDebugMDAFlags
                {
            	// If this flag is high, then the thread may have slipped since the MDA was fired. 
            	MDA_FLAG_SLIP = 0x2
                } CorDebugMDAFlags;
                HRESULT GetFlags([in] CorDebugMDAFlags * pFlags);
            
                // Thread that the MDA is fired on. We use the os tid instead of an ICDThread in case an MDA is fired on a
                // native thread (or a managed thread that hasn't yet entered managed code and so we don't have a ICDThread
                // object for it yet)
                HRESULT GetOSThreadId([out] DWORD * pOsTid);
            };
            
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugMDA.GetName(System.UInt32,System.UInt32*,System.UInt16*)">
            <summary>
            Get the string for the type of the MDA. Never empty.
            This is a convenient performant alternative to getting the XML stream and extracting
            the type from that based off the schema.
            </summary>
            <param name="cchName"></param>
            <param name="pcchName"></param>
            <param name="szName"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugMDA.GetDescription(System.UInt32,System.UInt32*,System.UInt16*)">
            <summary>
            Get a string description of the MDA. This may be empty (0-length).
            </summary>
            <param name="cchName"></param>
            <param name="pcchName"></param>
            <param name="szName"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugMDA.GetXML(System.UInt32,System.UInt32*,System.UInt16*)">
            <summary>
            Get the full associated XML for the MDA. This may be empty.
            This could be a potentially expensive operation if the xml stream is large.
            See the MDA documentation for the schema for this XML stream.
            </summary>
            <param name="cchName"></param>
            <param name="pcchName"></param>
            <param name="szName"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugMDA.GetFlags(JetBrains.Debugger.CorApi.ComInterop.CorDebugMDAFlags*)">
            <summary>
            Get the flags associated w/ the MDA. New flags may be added in future versions.
            </summary>
            <param name="pFlags"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugMDA.GetOSThreadId(System.UInt32*)">
            <summary>
            Thread that the MDA is fired on. We use the os tid instead of an ICDThread in case an MDA is fired on a
            native thread (or a managed thread that hasn't yet entered managed code and so we don't have a ICDThread
            object for it yet)
            </summary>
            <param name="pOsTid"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule">
            <summary>
             ICorDebugModule represents a Common Language Runtime module that is loaded into a
             specific AppDomain.  Normally this is an executable or a DLL, but it may also be
             some other file of a multi-module assembly.  There is an ICorDebugModule instance
             for each AppDomain a module is loaded into, even in the case of shared modules
             like
             mscorlib.
            </summary>
            <example><code>
             /*
             * ICorDebugModule represents a Common Language Runtime module that is loaded into a
             * specific AppDomain.  Normally this is an executable or a DLL, but it may also be
             * some other file of a multi-module assembly.  There is an ICorDebugModule instance
             * for each AppDomain a module is loaded into, even in the case of shared modules like
             * mscorlib.
             */
            
            [
                object,
                local,
                uuid(dba2d8c1-e5c5-4069-8c13-10a7c6abf43d),
                pointer_default(unique)
            ]
            interface ICorDebugModule : IUnknown
            {
                /*
                 * GetProcess returns the process of which this module is a part.
                 */
            
                HRESULT GetProcess([out] ICorDebugProcess **ppProcess);
            
                /*
                 * GetBaseAddress returns the base address of the module.
                 *
                 * For modules loaded from NGEN images, the base address will be 0.
                 */
            
                HRESULT GetBaseAddress([out] CORDB_ADDRESS *pAddress);
            
                /*
                 * GetAssembly returns the assembly of which this module is a part.
                 */
            
                HRESULT GetAssembly([out] ICorDebugAssembly **ppAssembly);
            
                /*
                 * GetName returns a name identifying the module.
                 *
                 * For on-disk modules this is a full path.  For dynamic modules this 
                 * is just the filename if one was provided.  Otherwise, and for other 
                 * in-memory modules, this is just the simple name stored in the module's
                 * metadata.
                 */
            
                HRESULT GetName([in] ULONG32 cchName,
                                [out] ULONG32 *pcchName,
                                [out, size_is(cchName),
                                length_is(*pcchName)] WCHAR szName[]);
            
                /*
                 * EnableJITDebugging controls whether the jitter preserves
                 * debugging information for methods within this module.
                 * If bTrackJITInfo is true, then the jitter preserves
                 * mapping information between the IL version of a function and
                 * the jitted version for functions in the module.  If bAllowJitOpts
                 * is true, then the jitter will generate code with certain (JIT-specific)
                 * optimizations.
                 *
                 * JITDebug is enabled by default for all modules loaded when the
                 * debugger is active.  Programmatically enabling/disabling these
                 * settings will override global settings.
                 *
                 */
                HRESULT EnableJITDebugging([in] BOOL bTrackJITInfo,
                                           [in] BOOL bAllowJitOpts);
            
                /*
                 * EnableClassLoadCallbacks controls whether on not LoadClass and
                 * UnloadClass callbacks are called for the particular module.
                 * For non-dynamic modules, they are off by default.
                 * For dynamic modules, they are on by default and can not be disabled.
                 */
            
                HRESULT EnableClassLoadCallbacks([in] BOOL bClassLoadCallbacks);
            
                /*
                 * GetFunctionFromToken returns the ICorDebugFunction from
                 * metadata information. Returns CORDBG_E_FUNCTION_NOT_IL if
                 * called with a methodDef that does not refer to an IL method.
                 * In the EnC case, this will return the most recent version of the function.
                 */
            
                HRESULT GetFunctionFromToken([in] mdMethodDef methodDef,
                                             [out] ICorDebugFunction **ppFunction);
            
                /*
                 * NOT YET IMPLEMENTED
                 */
            
                HRESULT GetFunctionFromRVA([in] CORDB_ADDRESS rva,
                                           [out] ICorDebugFunction **ppFunction);
            
                /*
                 * GetClassFromToken returns the ICorDebugClass from metadata information.
                 */
            
                HRESULT GetClassFromToken([in] mdTypeDef typeDef,
                                          [out] ICorDebugClass **ppClass);
            
                /*
                 * NOT YET IMPLEMENTED
                 */
            
                HRESULT CreateBreakpoint([out] ICorDebugModuleBreakpoint **ppBreakpoint);
            
                /*
                 * DEPRECATED
                 */
            
                HRESULT GetEditAndContinueSnapshot([out] ICorDebugEditAndContinueSnapshot **ppEditAndContinueSnapshot);
            
                /*
                 * Return a metadata interface pointer that can be used to examine the
                 * metadata for this module.
                 */
                HRESULT GetMetaDataInterface([in] REFIID riid, [out] IUnknown **ppObj);
            
            
                /*
                 * Return the token for the Module table entry for this object.  The token
                 * may then be passed to the meta data import api's.
                 */
                HRESULT GetToken([out] mdModule *pToken);
            
                /*
                 * If this is a dynamic module, IsDynamic sets *pDynamic to true, otherwise
                 * sets *pDynamic to false.
                 * Dynamic modules can continue to grow new classes (receive LoadClass callbacks) even after
                 * the module is loaded.
                 */
                HRESULT IsDynamic([out] BOOL *pDynamic);
            
                /*
                 * GetGlobalVariableValue returns a value object for the given global
                 * variable.
                 */
                HRESULT GetGlobalVariableValue([in] mdFieldDef fieldDef,
                                               [out] ICorDebugValue **ppValue);
            
                /*
                 * GetSize returns the size, in bytes, of the module.
                 *
                 * For modules loaded from NGEN images, the size will be 0.
                 */
                HRESULT GetSize([out] ULONG32 *pcBytes);
            
                /*
                 * If this is a module that exists only in the debuggee's memory,
                 * then pInMemory will be set to TRUE. The Runtime supports
                 * loading assemblies from raw streams of bytes. Such modules are
                 * called "in memory" modules and they have no on-disk
                 * representation.
                 */
                HRESULT IsInMemory([out] BOOL *pInMemory);
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule.GetProcess(JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess@)">
            <summary>
            GetProcess returns the process of which this module is a part.
            </summary>
            <param name="ppProcess"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule.GetBaseAddress(System.UInt64*)">
            <summary>
            GetBaseAddress returns the base address of the module.
            For modules loaded from NGEN images, the base address will be 0.
            </summary>
            <param name="pAddress"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule.GetAssembly(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAssembly@)">
            <summary>
            GetAssembly returns the assembly of which this module is a part.
            </summary>
            <param name="ppAssembly"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule.GetName(System.UInt32,System.UInt32*,System.UInt16*)">
            <summary>
            GetName returns a name identifying the module.
            For on-disk modules this is a full path.  For dynamic modules this
            is just the filename if one was provided.  Otherwise, and for other
            in-memory modules, this is just the simple name stored in the module's
            metadata.
            </summary>
            <param name="cchName"></param>
            <param name="pcchName"></param>
            <param name="szName"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule.EnableJITDebugging(System.Int32,System.Int32)">
            <summary>
            EnableJITDebugging controls whether the jitter preserves
            debugging information for methods within this module.
            If bTrackJITInfo is true, then the jitter preserves
            mapping information between the IL version of a function and
            the jitted version for functions in the module.  If bAllowJitOpts
            is true, then the jitter will generate code with certain (JIT-specific)
            optimizations.
            JITDebug is enabled by default for all modules loaded when the
            debugger is active.  Programmatically enabling/disabling these
            settings will override global settings.
            </summary>
            <param name="bTrackJITInfo"></param>
            <param name="bAllowJitOpts"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule.EnableClassLoadCallbacks(System.Int32)">
            <summary>
            EnableClassLoadCallbacks controls whether on not LoadClass and
            UnloadClass callbacks are called for the particular module.
            For non-dynamic modules, they are off by default.
            For dynamic modules, they are on by default and can not be disabled.
            </summary>
            <param name="bClassLoadCallbacks"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule.GetFunctionFromToken(System.UInt32,JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction@)">
            <summary>
            GetFunctionFromToken returns the ICorDebugFunction from
            metadata information. Returns CORDBG_E_FUNCTION_NOT_IL if
            called with a methodDef that does not refer to an IL method.
            In the EnC case, this will return the most recent version of the function.
            </summary>
            <param name="methodDef"></param>
            <param name="ppFunction"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule.GetFunctionFromRVA(System.UInt64,System.Void**)">
            <summary>
            NOT YET IMPLEMENTED
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule.GetClassFromToken(System.UInt32,JetBrains.Debugger.CorApi.ComInterop.ICorDebugClass@)">
            <summary>
            GetClassFromToken returns the ICorDebugClass from metadata information.
            </summary>
            <param name="typeDef"></param>
            <param name="ppClass"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule.CreateBreakpoint(System.Void**)">
            <summary>
            NOT YET IMPLEMENTED
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule.GetEditAndContinueSnapshot(System.Void**)">
            <summary>
            DEPRECATED
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule.GetMetaDataInterface(System.Guid*,System.Void**)">
            <summary>
             Return a metadata interface pointer that can be used to examine the
             metadata for this module.
            </summary>
            <param name="riid"></param>
            <param name="ppObj"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule.GetToken(System.UInt32*)">
            <summary>
            Return the token for the Module table entry for this object.  The token
            may then be passed to the meta data import api's.
            </summary>
            <param name="pToken"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule.IsDynamic(System.Int32*)">
            <summary>
            If this is a dynamic module, IsDynamic sets *pDynamic to true, otherwise
            sets *pDynamic to false.
            Dynamic modules can continue to grow new classes (receive LoadClass callbacks) even after
            the module is loaded.
            </summary>
            <param name="pDynamic"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule.GetGlobalVariableValue(System.UInt32,JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            GetGlobalVariableValue returns a value object for the given global
            variable.
            </summary>
            <param name="fieldDef"></param>
            <param name="ppValue"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule.GetSize(System.UInt32*)">
            <summary>
            GetSize returns the size, in bytes, of the module.
            For modules loaded from NGEN images, the size will be 0.
            </summary>
            <param name="pcBytes"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule.IsInMemory(System.Int32*)">
            <summary>
            If this is a module that exists only in the debuggee's memory,
            then pInMemory will be set to TRUE. The Runtime supports
            loading assemblies from raw streams of bytes. Such modules are
            called "in memory" modules and they have no on-disk
            representation.
            </summary>
            <param name="pInMemory"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule2">
            <summary>
             ICorDebugModule2 is a logical extension to ICorDebugModule.
            </summary>
            <example><code>
             /*
             * ICorDebugModule2 is a logical extension to ICorDebugModule.
             */
            [
                object,
                local,
                uuid(7FCC5FB5-49C0-41de-9938-3B88B5B9ADD7),
                pointer_default(unique)
            ]
            interface ICorDebugModule2 : IUnknown
            {
                /*
                 * SetUserCode sets the user-code status of all the functions on all the classes in
                 * the module to bIsJustMyCode, except for the functions or classes in the tokens array,
                 * which it sets to !bIsJustMyCode.
                 * These settings erase all previous JMC settings in this module.
                 * JMC status can be refined by calls to SetJMCStatus on the Class and Function.
                 * Returns S_OK if all functions were set successfully,
                 * CORDBG_E_FUNCTION_NOT_DEBUGGABLE if some function to be marked TRUE was not
                 * debuggable.
                 */
                HRESULT SetJMCStatus(BOOL bIsJustMyCode,
                                    ULONG32 cTokens,
                                    [in, size_is(cTokens)] mdToken pTokens[]);
            
               /*
                 * ApplyChanges is called to apply an Edit and Continue delta to the running process.
                 * An EnC delta consists of a delta metadata blob (created by IMetadataEmit2::SaveDelta)
                 * and a delta IL blob (a method body stream just like the one in an on disk assembly).
                 * If this operation fails, the debug session is considered to be in an invalid state
                 * and must be restarted.
                 */
                HRESULT ApplyChanges(ULONG cbMetadata,
                                     [in, size_is(cbMetadata)] BYTE pbMetadata[],
                                     ULONG cbIL,
                                     [in, size_is(cbIL)] BYTE pbIL[]);
            
              /*
               * SetJITCompilerFlags sets the flags that control the JIT compiler. If the set of flags is invalid,
               * the function will fail. This function can only be called from within the true LoadModule callback
               * for the given module. Attempts to call it after this callback has been delivered or in a "faked"
               * LoadModule callback for debugger attach will fail.
               */
            
                HRESULT SetJITCompilerFlags( DWORD dwFlags );
            
                /*
                * GetJITCompilerFlags gets the set of flags that control the JIT compiler for this module.
                */
            
                HRESULT GetJITCompilerFlags( [out] DWORD *pdwFlags );
            
                /*
                 * Resolve an assembly given an AssemblyRef token. Note that
                 * this will not trigger the loading of assembly. If assembly is not yet loaded,
                 * this will return an CORDBG_E_CANNOT_RESOLVE_ASSEMBLY error
                 *
                */
                HRESULT ResolveAssembly(mdToken tkAssemblyRef,
                                       [out] ICorDebugAssembly **ppAssembly);
            
            };
            
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule2.SetJMCStatus(System.Int32,System.UInt32,System.UInt32*)">
            <summary>
            SetUserCode sets the user-code status of all the functions on all the classes in
            the module to bIsJustMyCode, except for the functions or classes in the tokens array,
            which it sets to !bIsJustMyCode.
            These settings erase all previous JMC settings in this module.
            JMC status can be refined by calls to SetJMCStatus on the Class and Function.
            Returns S_OK if all functions were set successfully,
            CORDBG_E_FUNCTION_NOT_DEBUGGABLE if some function to be marked TRUE was not
            debuggable.
            </summary>
            <param name="bIsJustMyCode"></param>
            <param name="cTokens"></param>
            <param name="pTokens"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule2.ApplyChanges(System.UInt32,System.Byte*,System.UInt32,System.Byte*)">
            <summary>
            ApplyChanges is called to apply an Edit and Continue delta to the running process.
            An EnC delta consists of a delta metadata blob (created by IMetadataEmit2::SaveDelta)
            and a delta IL blob (a method body stream just like the one in an on disk assembly).
            If this operation fails, the debug session is considered to be in an invalid state
            and must be restarted.
            </summary>
            <param name="cbMetadata"></param>
            <param name="pbMetadata"></param>
            <param name="cbIL"></param>
            <param name="pbIL"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule2.SetJITCompilerFlags(System.UInt32)">
            <summary>
            SetJITCompilerFlags sets the flags that control the JIT compiler. If the set of flags is invalid,
            the function will fail. This function can only be called from within the true LoadModule callback
            for the given module. Attempts to call it after this callback has been delivered or in a "faked"
            LoadModule callback for debugger attach will fail.
            </summary>
            <param name="dwFlags"><see cref="T:JetBrains.Debugger.CorApi.ComInterop.CorDebugJITCompilerFlags"/></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule2.GetJITCompilerFlags(System.UInt32*)">
            <summary>
            GetJITCompilerFlags gets the set of flags that control the JIT compiler for this module.
            </summary>
            <param name="pdwFlags"><see cref="T:JetBrains.Debugger.CorApi.ComInterop.CorDebugJITCompilerFlags"/></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule2.ResolveAssembly(System.UInt32,JetBrains.Debugger.CorApi.ComInterop.ICorDebugAssembly@)">
            <summary>
            Resolve an assembly given an AssemblyRef token. Note that
            this will not trigger the loading of assembly. If assembly is not yet loaded,
            this will return an CORDBG_E_CANNOT_RESOLVE_ASSEMBLY error
            </summary>
            <param name="tkAssemblyRef"></param>
            <param name="ppAssembly"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule3">
             <summary>
             ICorDebugModule3 is a logical extension to ICorDebugModule.
             </summary>
             <example><code>
             /*
             * ICorDebugModule3 is a logical extension to ICorDebugModule.
             */
            [
                object,
                local,
                uuid(86F012BF-FF15-4372-BD30-B6F11CAAE1DD),
                pointer_default(unique)
            ]
            interface ICorDebugModule3 : IUnknown
            {
                /*
                 * CreateReaderForInMemorySymbols creates a debug symbol reader object (eg. 
                 * ISymUnmanagedReader) for a dynamic module.  This symbol reader becomes stale
                 * and is usually discarded whenever a LoadClass callback is delivered for the
                 * module.
                 *
                 * Arguments:
                 *    riid - The IID of the COM interface to return (typically IID_ISymUnmanagedReader)
                 *   ppObj - Where to store the reader interface.
                 *
                 * Return Value:
                 *   S_OK on success
                 *   Error hresults otherwise, including:
                 *   CORDBG_E_MODULE_LOADED_FROM_DISK if this isn't an in-memory or dynamic module
                 *   CORDBG_E_SYMBOLS_NOT_AVAILABLE if symbols weren't supplied by the application or aren't
                 *      yet available.
                 *
                 * Notes:
                 *   This API can also be used to create a symbol reader object for in-memory 
                 *   (non-dynamic) modules, but only after the symbols are first available
                 *   (indicated by the UpdateModuleSymbols callback).
                 *
                 *   This API returns a new reader instance every time it is called (like CoCreateInstance)
                 *   and so the debugger should cache the result and only request a new one when
                 *   the underlying data may have changed (i.e. a LoadClass event).
                 *
                 *   Dynamic modules do not have any symbols available until the first type has been
                 *   loaded into them (as indicated by the LoadClass callback).  
                 */
                HRESULT CreateReaderForInMemorySymbols([in] REFIID riid,
                                                       [out][iid_is(riid)] void **ppObj);
            }
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule3.CreateReaderForInMemorySymbols(System.Guid*,System.Void**)">
            <summary>
            CreateReaderForInMemorySymbols creates a debug symbol reader object (eg. 
            ISymUnmanagedReader) for a dynamic module.  This symbol reader becomes stale
            and is usually discarded whenever a LoadClass callback is delivered for the
            module.
            
            Arguments:
               riid - The IID of the COM interface to return (typically IID_ISymUnmanagedReader)
              ppObj - Where to store the reader interface.
            
            Return Value:
              S_OK on success
              Error hresults otherwise, including:
              CORDBG_E_MODULE_LOADED_FROM_DISK if this isn't an in-memory or dynamic module
              CORDBG_E_SYMBOLS_NOT_AVAILABLE if symbols weren't supplied by the application or aren't
                 yet available.
            
            Notes:
              This API can also be used to create a symbol reader object for in-memory 
              (non-dynamic) modules, but only after the symbols are first available
              (indicated by the UpdateModuleSymbols callback).
            
              This API returns a new reader instance every time it is called (like CoCreateInstance)
              and so the debugger should cache the result and only request a new one when
              the underlying data may have changed (i.e. a LoadClass event).
            
              Dynamic modules do not have any symbols available until the first type has been
              loaded into them (as indicated by the LoadClass callback).   
            </summary>
            <param name="riid"></param>
            <param name="ppObj"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModuleBreakpoint">
             <summary>
             
             </summary>
             <example><code>
            
            [
                object,
                local,
                uuid(CC7BCAEA-8A68-11d2-983C-0000F808342D),
                pointer_default(unique)
            ]
            interface ICorDebugModuleBreakpoint : ICorDebugBreakpoint
            {
                /*
                 * Returns the module on which this breakpoint is set.
                 */
                HRESULT GetModule([out] ICorDebugModule **ppModule);
            }; </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModuleBreakpoint.Activate(System.Int32)">
            <summary>
            Sets the active state of the breakpoint.
            </summary>
            <param name="bActive"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModuleBreakpoint.IsActive(System.Int32*)">
            <summary>
            Returns whether the breakpoint is active.
            </summary>
            <param name="pbActive"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModuleBreakpoint.GetModule(JetBrains.Debugger.CorApi.ComInterop.ICorDebugModule@)">
            <summary>
            Returns the module on which this breakpoint is set.
            </summary>
            <param name="ppModule"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModuleEnum">
            <summary>
            </summary>
            <example><code>
            [
                object,
                local,
                uuid(CC7BCB09-8A68-11d2-983C-0000F808342D),
                pointer_default(unique)
            ]
            interface ICorDebugModuleEnum : ICorDebugEnum
            {
                /*
                 * Gets the next "celt" number of modules in the enumeration.
                 * The actual number of modules retrieved is returned in "pceltFetched".
                 * Returns S_FALSE if the actual number of modules retrieved is smaller
                 * than the number of modules requested.
                 */
                HRESULT Next([in] ULONG celt,
                             [out, size_is(celt), length_is(*pceltFetched)]
                                ICorDebugModule *modules[],
                             [out] ULONG *pceltFetched);
            }; </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModuleEnum.Skip(System.UInt32)">
            <summary>
            Moves the current position forward the given number of elements.
            </summary>
            <param name="celt">the given number of elements</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModuleEnum.Reset">
            <summary>
            Sets the position of the enumerator to the beginning of the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModuleEnum.Clone(JetBrains.Debugger.CorApi.ComInterop.ICorDebugEnum@)">
            <summary>
            Creates another enumerator with the same current position as this one.
            </summary>
            <param name="ppEnum">another enumerator</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModuleEnum.GetCount(System.UInt32*)">
            <summary>
            Gets the number of elements in the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugModuleEnum.Next(System.UInt32,System.Void**,System.UInt32*)">
            <summary>
            Gets the next "celt" number of modules in the enumeration.
            The actual number of modules retrieved is returned in "pceltFetched".
            Returns S_FALSE if the actual number of modules retrieved is smaller than the number of modules requested.
            </summary>
            <param name="celt"></param>
            <param name="modules"></param>
            <param name="pceltFetched"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugNativeFrame">
            <summary>
             ICorDebugNativeFrame is a specialized interface of ICorDebugFrame for jitted frames, i.e. native frames for managed methods.
             (Note that jitted frames implement both ICorDebugILFrame and ICorDebugNativeFrame.)
            </summary>
            <example><code>
             
             /*
             * ICorDebugNativeFrame is a specialized interface of ICorDebugFrame for jitted frames, i.e. 
             * native frames for managed methods.
             * (Note that jitted frames implement both ICorDebugILFrame and ICorDebugNativeFrame.)
             */
            
            [
                object,
                local,
                uuid(03E26314-4F76-11d3-88C6-006097945418),
                pointer_default(unique)
            ]
            interface ICorDebugNativeFrame : ICorDebugFrame
            {
                /*
                 * GetIP returns the stack frame's offset into the function's
                 * native code.  If this stack frame is active, this address is
                 * the next instruction to execute.  If this stack frame is not
                 * active, this is the next instruction to execute when the stack
                 * frame is reactivated.
                 */
            
                HRESULT GetIP([out] ULONG32 *pnOffset);
            
                /*
                 * SetIP sets the instruction pointer to the given native
                 * offset. CorDebug will attempt to keep the stack frame in a
                 * coherent state.  (Note that even if the frame is in a valid
                 * state as far as the runtime is concerned, there still may be
                 * problems - e.g. uninitialized local variables, etc.  The caller
                 * (or perhaps the user) is responsible for insuring coherency of
                 * the running program.)
                 *
                 * Calling SetIP immediately invalidates all frames and chains for the
                 * current thread; the debugger must perform a new stack trace if it
                 * requires frame information after calling SetIP.
                 */
            
                HRESULT SetIP(ULONG32 nOffset);
            
                /*
                 * GetRegisterSet returns the register set for the given frame.
                 *
                 */
            
                HRESULT GetRegisterSet([out] ICorDebugRegisterSet **ppRegisters);
            
                /*
                 * GetLocalRegisterValue gets the value for a local variable or
                 * argument stored in a register of a native frame. This can be
                 * used either in a native frame or a jitted frame.
                 */
            
                HRESULT GetLocalRegisterValue(CorDebugRegister reg,
                                              ULONG cbSigBlob,
                                              PCCOR_SIGNATURE pvSigBlob,
                                              [out] ICorDebugValue **ppValue);
            
                /*
                 * GetLocalDoubleRegisterValue gets the value for a local variable
                 * or argument stored in 2 registers of a native frame. This can
                 * be used either in a native frame or a jitted frame.
                 */
            
                HRESULT GetLocalDoubleRegisterValue(CorDebugRegister highWordReg,
                                                    CorDebugRegister lowWordReg,
                                                    ULONG cbSigBlob,
                                                    PCCOR_SIGNATURE pvSigBlob,
                                                    [out] ICorDebugValue **ppValue);
            
                /*
                 * GetLocalMemoryValue gets the value for a local variable stored
                 * at the given address.
                 */
            
                HRESULT GetLocalMemoryValue(CORDB_ADDRESS address,
                                            ULONG cbSigBlob,
                                            PCCOR_SIGNATURE pvSigBlob,
                                            [out] ICorDebugValue **ppValue);
            
                /*
                 * GetLocalRegisterMemoryValue gets the value for a local which
                 * is stored half in a register and half in memory.
                 */
            
                HRESULT GetLocalRegisterMemoryValue(CorDebugRegister highWordReg,
                                                    CORDB_ADDRESS lowWordAddress,
                                                    ULONG cbSigBlob,
                                                    PCCOR_SIGNATURE pvSigBlob,
                                                    [out] ICorDebugValue **ppValue);
            
                /*
                 * GetLocalMemoryRegisterValue gets the value for a local which
                 * is stored half in a register and half in memory.
                 */
            
                HRESULT GetLocalMemoryRegisterValue(CORDB_ADDRESS highWordAddress,
                                                    CorDebugRegister lowWordRegister,
                                                    ULONG cbSigBlob,
                                                    PCCOR_SIGNATURE pvSigBlob,
                                                    [out] ICorDebugValue **ppValue);
                /*
                 * CanSetIP attempts to determine if it's safe to set the instruction pointer
                 * to the given native offset. If this returns S_OK, then executing
                 * SetIP (see above) will result in a safe, correct, continued execution.
                 * If CanSetIP returns anything else, SetIP can still be invoked, but
                 * continued, correct execution of the debuggee cannot be guaranteed.
                 *
                 */
            
                HRESULT CanSetIP(ULONG32 nOffset);
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugNativeFrame.GetChain(JetBrains.Debugger.CorApi.ComInterop.ICorDebugChain@)">
            <summary>
            GetChain returns the chain of which this stack frame is a part.
            </summary>
            <param name="ppChain"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugNativeFrame.GetCode(JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode@)">
            <summary>
            GetCode returns the code which this stack frame is running if any.
            </summary>
            <param name="ppCode"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugNativeFrame.GetFunction(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction@)">
            <summary>
            GetFunction returns the function for the code which this stack
            frame is running.
            For ICorDebugInternalFrames, this may point to a method the
            frame is associated with (which may be in a different AppDomain
            from the frame itself), or may fail if the frame doesn't relate to any
            particular function.
            </summary>
            <param name="ppFunction"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugNativeFrame.GetFunctionToken(System.UInt32*)">
            <summary>
            GetFunctionToken is a convenience routine to return the token for the
            function for the code which this stack frame is running.
            The scope to resolve the token can be gotten from the ICorDebugFunction
            associated with this frame.</summary>
            <param name="pToken"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugNativeFrame.GetStackRange(System.UInt64*,System.UInt64*)">
            <summary>
            GetStackRange returns the absolute address range of the stack
            frame.  (This is useful for piecing together interleaved stack
            traces gathered from multiple debugging engines.)  Note that you
            cannot make any assumptions about what is actually stored on
            the stack - the numeric range is to compare stack frame
            locations only.
            The start of a stack range is the leafmost boundary of the frame, and
            the end of a stack range is the rootmost boundary of the frame.
            </summary>
            <param name="pStart"></param>
            <param name="pEnd"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugNativeFrame.GetCaller(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame@)">
            <summary>
            GetCaller returns a pointer to the frame in the current chain
            which called this frame, or NULL if this is the rootmost frame
            in the chain.
            </summary>
            <param name="ppFrame"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugNativeFrame.GetCallee(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame@)">
            <summary>
            GetCallee returns a pointer to the frame in the current chain
            which this frame called, or NULL if this is the leafmost frame
            in the chain.
            </summary>
            <param name="ppFrame"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugNativeFrame.CreateStepper(JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper@)">
            <summary>
            CreateStepper creates a stepper object which operates relative to the
            frame. The Stepper API must then be used to perform actual stepping.
            Note that if this frame is not active, the frame will typically have to
            be returned to before the step is completed.
            </summary>
            <param name="ppStepper"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugNativeFrame.GetIP(System.UInt32*)">
            <summary>
            GetIP returns the stack frame's offset into the function's
            native code.  If this stack frame is active, this address is
            the next instruction to execute.  If this stack frame is not
            active, this is the next instruction to execute when the stack
            frame is reactivated.
            </summary>
            <param name="pnOffset"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugNativeFrame.SetIP(System.UInt32)">
            <summary>
            SetIP sets the instruction pointer to the given native
            offset. CorDebug will attempt to keep the stack frame in a
            coherent state.  (Note that even if the frame is in a valid
            state as far as the runtime is concerned, there still may be
            problems - e.g. uninitialized local variables, etc.  The caller
            (or perhaps the user) is responsible for insuring coherency of
            the running program.)
            Calling SetIP immediately invalidates all frames and chains for the
            current thread; the debugger must perform a new stack trace if it
            requires frame information after calling SetIP.
            </summary>
            <param name="nOffset"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugNativeFrame.GetRegisterSet(JetBrains.Debugger.CorApi.ComInterop.ICorDebugRegisterSet@)">
            <summary>
            GetRegisterSet returns the register set for the given frame.
            </summary>
            <param name="ppRegisters"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugNativeFrame.GetLocalRegisterValue(JetBrains.Debugger.CorApi.ComInterop.CorDebugRegister,System.UInt32,System.Void*,JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            GetLocalRegisterValue gets the value for a local variable or
            argument stored in a register of a native frame. This can be
            used either in a native frame or a jitted frame.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugNativeFrame.GetLocalDoubleRegisterValue(JetBrains.Debugger.CorApi.ComInterop.CorDebugRegister,JetBrains.Debugger.CorApi.ComInterop.CorDebugRegister,System.UInt32,System.Void*,JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            GetLocalDoubleRegisterValue gets the value for a local variable
            or argument stored in 2 registers of a native frame. This can
            be used either in a native frame or a jitted frame.
            </summary>
            <param name="highWordReg"></param>
            <param name="lowWordReg"></param>
            <param name="cbSigBlob"></param>
            <param name="pvSigBlob"></param>
            <param name="ppValue"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugNativeFrame.GetLocalMemoryValue(System.UInt64,System.UInt32,System.Void*,JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            GetLocalMemoryValue gets the value for a local variable stored
            at the given address.
            </summary>
            <param name="address"></param>
            <param name="cbSigBlob"></param>
            <param name="pvSigBlob"></param>
            <param name="ppValue"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugNativeFrame.GetLocalRegisterMemoryValue(JetBrains.Debugger.CorApi.ComInterop.CorDebugRegister,System.UInt64,System.UInt32,System.Void*,JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            GetLocalRegisterMemoryValue gets the value for a local which
            is stored half in a register and half in memory.
            </summary>
            <param name="highWordReg"></param>
            <param name="lowWordAddress"></param>
            <param name="cbSigBlob"></param>
            <param name="pvSigBlob"></param>
            <param name="ppValue"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugNativeFrame.GetLocalMemoryRegisterValue(System.UInt64,JetBrains.Debugger.CorApi.ComInterop.CorDebugRegister,System.UInt32,System.Void*,JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            GetLocalMemoryRegisterValue gets the value for a local which
            is stored half in a register and half in memory.
            </summary>
            <param name="highWordAddress"></param>
            <param name="lowWordRegister"></param>
            <param name="cbSigBlob"></param>
            <param name="pvSigBlob"></param>
            <param name="ppValue"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugNativeFrame.CanSetIP(System.UInt32)">
            <summary>
            CanSetIP attempts to determine if it's safe to set the instruction pointer
            to the given native offset. If this returns S_OK, then executing
            SetIP (see above) will result in a safe, correct, continued execution.
            If CanSetIP returns anything else, SetIP can still be invoked, but
            continued, correct execution of the debuggee cannot be guaranteed.
            </summary>
            <param name="nOffset"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugNativeFrame2">
            <summary>
            </summary>
            <example><code>
             [
                object,
                local,
                uuid(35389FF1-3684-4c55-A2EE-210F26C60E5E),
                pointer_default(unique)
            ]
            interface ICorDebugNativeFrame2 : IUnknown
            {
                /*
                 * Returns true if the current frame is a child frame.
                 */
                HRESULT IsChild([out] BOOL *pIsChild);
            
                /*
                 * Return true if the specified frame is the parent frame of the current frame.
                 */
                HRESULT IsMatchingParentFrame([in] ICorDebugNativeFrame2 *pPotentialParentFrame,
                                              [out] BOOL *pIsParent);
            
                /*
                 * Return the stack parameter size on x86.  On other platforms, we return S_FALSE and set pSize to 0.
                 * This is because other platforms don't need this information for unwinding.
                 */
                HRESULT GetStackParameterSize([out] ULONG32 * pSize);
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugNativeFrame2.IsChild(System.Int32*)">
            <summary>
            Returns true if the current frame is a child frame.
            </summary>
            <param name="pIsChild"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugNativeFrame2.IsMatchingParentFrame(JetBrains.Debugger.CorApi.ComInterop.ICorDebugNativeFrame2,System.Int32*)">
            <summary>
            Return true if the specified frame is the parent frame of the current frame.
            </summary>
            <param name="pPotentialParentFrame"></param>
            <param name="pIsParent"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugNativeFrame2.GetStackParameterSize(System.UInt32*)">
            <summary>
            Return the stack parameter size on x86.  On other platforms, we return S_FALSE and set pSize to 0.
            This is because other platforms don't need this information for unwinding.
            </summary>
            <param name="pSize"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugObjectEnum">
            <summary>
            </summary>
            <example><code>
            [
                object,
                local,
                uuid(CC7BCB02-8A68-11d2-983C-0000F808342D),
                pointer_default(unique)
            ]
            interface ICorDebugObjectEnum : ICorDebugEnum
            {
                /*
                 * Gets the next "celt" number of objects in the enumeration.
                 * The actual number of objects retrieved is returned in "pceltFetched".
                 * Returns S_FALSE if the actual number of objects retrieved is smaller
                 * than the number of objects requested.
                 */
                HRESULT Next([in] ULONG celt,
                             [out, size_is(celt),
                              length_is(*pceltFetched)]  CORDB_ADDRESS objects[],
                             [out] ULONG *pceltFetched);
            }; </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugObjectEnum.Skip(System.UInt32)">
            <summary>
            Moves the current position forward the given number of elements.
            </summary>
            <param name="celt">the given number of elements</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugObjectEnum.Reset">
            <summary>
            Sets the position of the enumerator to the beginning of the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugObjectEnum.Clone(JetBrains.Debugger.CorApi.ComInterop.ICorDebugEnum@)">
            <summary>
            Creates another enumerator with the same current position as this one.
            </summary>
            <param name="ppEnum">another enumerator</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugObjectEnum.GetCount(System.UInt32*)">
            <summary>
            Gets the number of elements in the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugObjectEnum.Next(System.UInt32,System.UInt64**,System.UInt32*)">
            <summary>
             Gets the next "celt" number of objects in the enumeration.
             The actual number of objects retrieved is returned in "pceltFetched".
             Returns S_FALSE if the actual number of objects retrieved is smaller than the number of objects requested.
            </summary>
            <param name="celt"></param>
            <param name="objects"></param>
            <param name="pceltFetched"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugObjectValue">
            <summary>
             ICorDebugObjectValue is a subclass of ICorDebugValue which applies to
             values which contain an object.
             An ICorDebugObjectValue becomes invalid after the debuggee is continued.
            </summary>
            <example><code>
             
             * ICorDebugObjectValue is a subclass of ICorDebugValue which applies to
             * values which contain an object.
             * An ICorDebugObjectValue becomes invalid after the debuggee is continued.
             */
            
            [
                object,
                local,
                uuid(18AD3D6E-B7D2-11d2-BD04-0000F80849BD),
                pointer_default(unique)
            ]
            interface ICorDebugObjectValue : ICorDebugValue
            {
                /*
                 * GetClass returns the runtime class of the object in the value.
                 */
            
                HRESULT GetClass([out] ICorDebugClass **ppClass);
            
                /*
                 * GetFieldValue returns a value for the given field in the given
                 * class. The class must be on the class hierarchy of the object's
                 * class, and the field must be a field of that class.
                 */
            
                HRESULT GetFieldValue([in] ICorDebugClass *pClass,
                                      [in] mdFieldDef fieldDef,
                                      [out] ICorDebugValue **ppValue);
            
                /*
                 * NOT YET IMPLEMENTED
                 */
            
                HRESULT GetVirtualMethod([in] mdMemberRef memberRef,
                                         [out] ICorDebugFunction **ppFunction);
            
                /*
                 * NOT YET IMPLEMENTED
                 */
            
                HRESULT GetContext([out] ICorDebugContext **ppContext);
            
                /*
                 * IsValueClass returns true if the the class of this object is
                 * a value class.
                 */
            
                HRESULT IsValueClass([out] BOOL *pbIsValueClass);
            
                /*
                 * DEPRECATED
                 */
            
                HRESULT GetManagedCopy([out] IUnknown **ppObject);
            
                /*
                 * DEPRECATED
                 */
            
                HRESULT SetFromManagedCopy([in] IUnknown *pObject);
            };
            
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugObjectValue.GetType(JetBrains.Debugger.CorApi.ComInterop.CorElementType*)">
            <summary>
            GetType returns the simple type of the value.  If the object
            has a more complex runtime type, that type may be examined through the
            appropriate subclasses (e.g. ICorDebugObjectValue can get the class of
            an object.)
            </summary>
            <param name="elementType"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugObjectValue.GetSize(System.UInt32*)">
            <summary>
            GetSize returns the size of the value in bytes. Note that for reference
            types this will be the size of the pointer rather than the size of
            the object.
            </summary>
            <param name="pSize"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugObjectValue.GetAddress(System.UInt64*)">
            <summary>
            GetAddress returns the address of the value in the debugee
            process.  This might be useful information for the debugger to
            show.
            If the value is unavailable, 0 is returned. This could happen if
            it is at least partly in registers or stored in a GC Handle.
            </summary>
            <param name="pAddress"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugObjectValue.CreateBreakpoint(JetBrains.Debugger.CorApi.ComInterop.ICorDebugValueBreakpoint@)">
            <summary>
            NOT YET IMPLEMENTED
            </summary>
            <param name="ppBreakpoint"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugObjectValue.GetClass(JetBrains.Debugger.CorApi.ComInterop.ICorDebugClass@)">
            <summary>
            GetClass returns the runtime class of the object in the value.
            </summary>
            <param name="ppClass"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugObjectValue.GetFieldValue(JetBrains.Debugger.CorApi.ComInterop.ICorDebugClass,System.UInt32,JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            GetFieldValue returns a value for the given field in the given
            class. The class must be on the class hierarchy of the object's
            class, and the field must be a field of that class.
            </summary>
            <param name="pClass"></param>
            <param name="fieldDef"></param>
            <param name="ppValue"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugObjectValue.GetVirtualMethod(System.UInt32,JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction@)">
            <summary>
            NOT YET IMPLEMENTED
            </summary>
            <param name="memberRef"></param>
            <param name="ppFunction"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugObjectValue.GetContext(JetBrains.Debugger.CorApi.ComInterop.ICorDebugContext@)">
            <summary>
            NOT YET IMPLEMENTED
            </summary>
            <param name="ppContext"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugObjectValue.IsValueClass(System.Int32*)">
            <summary>
            IsValueClass returns true if the the class of this object is
            a value class.
            </summary>
            <param name="pbIsValueClass"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugObjectValue.GetManagedCopy(System.Void**)">
            <summary>
            DEPRECATED
            </summary>
            <param name="ppObject"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugObjectValue.SetFromManagedCopy(System.Void**)">
            <summary>
            DEPRECATED
            </summary>
            <param name="pObject"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugObjectValue2">
             <summary>
             
             </summary>
             <example><code>
             [
                object,
                local,
                uuid(49E4A320-4A9B-4eca-B105-229FB7D5009F),
                pointer_default(unique)
            ]
            interface ICorDebugObjectValue2 : IUnknown
            {
                /*
                 * GetVirtualMethodForType returns the most derived function
                 * for the given ref on this object.
                 *
                 * Note: not yet implemented.
                 */
            
                HRESULT GetVirtualMethodAndType([in] mdMemberRef memberRef,
                                                [out] ICorDebugFunction **ppFunction,
                                                [out] ICorDebugType **ppType);
            };
             </code></example>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess">
             <summary>
             ICorDebugProcess represents a process running some managed code. 
             </summary>
             <example><code>
             /*
             * ICorDebugProcess represents a process running some managed code.
             */
            
            [
                object,
                local,
                uuid(3d6f5f64-7538-11d3-8d5b-00104b35e7ef),
                pointer_default(unique)
            ]
            interface ICorDebugProcess : ICorDebugController
            {
                /*
                 * GetID returns the OS ID of the process.
                 */
            
                HRESULT GetID([out] DWORD *pdwProcessId);
            
                /*
                 * GetHandle returns a handle to the process. This handle is owned
                 * by the debugging API; the debugger should duplicate it before
                 * using it.
                 */
            
                HRESULT GetHandle([out] HPROCESS *phProcessHandle);
            
                /*
                 * GetThread returns the ICorDebugThread with the given OS Id.
                 *
                 * Note that eventually there will not be a one to one correspondence
                 * between OS threads and runtime threads, so this entry point will
                 * go away.
                 */
            
                HRESULT GetThread([in] DWORD dwThreadId, [out] ICorDebugThread **ppThread);
            
                /*
                 * NOT YET IMPLEMENTED
                 */
            
                HRESULT EnumerateObjects([out] ICorDebugObjectEnum **ppObjects);
            
                /*
                 * IsTransitionStub tests whether an address is inside of a transition stub
                 * which will cause a transition to managed code.  This can be used by
                 * unmanaged stepping code to decide when to return stepping control to
                 * the managed stepper.
                 *
                 * Note that, tentatively, these stubs may also be able to be identified
                 * ahead of time by looking at information in the PE file.
                 *
                 */
            
                HRESULT IsTransitionStub([in] CORDB_ADDRESS address,
                                         [out] BOOL *pbTransitionStub);
            
            
                /*
                 * IsOSSuspended returns whether or not the thread has been
                 * suspended as part of the debugger logic of stopping the process.
                 * (that is, it has had its Win32 suspend count incremented by
                 * one.)  The debugger UI may want to take this into account if
                 * it shows the user the OS suspend count of the thread.
                 *
                 * This function only makes sense in the context of
                 * unmanaged debugging - during managed debugging threads are not
                 * OS suspended. (They are cooperatively suspended.)
             */
            
                HRESULT IsOSSuspended([in] DWORD threadID, [out] BOOL *pbSuspended);
            
                /*
                 * GetThreadContext returns the context for the given thread.  The
                 * debugger should call this function rather than the Win32
                 * GetThreadContext, because the thread may actually be in a "hijacked"
                 * state where its context has been temporarily changed.
                 *
                 * This should only be used on when a thread is in native code. Use ICorDebugRegisterSet
                 * for threads in managed code.
                 *
                 * The data returned is a CONTEXT structure for the current platform.
                 * (CONTEXT is typically declared in winnt.h) Just as with a call
                 * to Win32's GetThreadContext, the caller should initialize the
                 * CONTEXT struct before calling.
                 *
                 */
            
                HRESULT GetThreadContext([in] DWORD threadID,
                                         [in] ULONG32 contextSize,
                                         [in, out, length_is(contextSize),
                                         size_is(contextSize)] BYTE context[]);
            
                /*
                 * SetThreadContext sets the context for the given thread.  The
                 * debugger should call this function rather than the Win32
                 * SetThreadContext, because the thread may actually be in a "hijacked"
                 * state where its context has been temporarily changed.
                 *
                 * This should only be used on when a thread is in native code. Use ICorDebugRegisterSet
                 * for threads in managed code.
                 *
                 * This should never be needed to modify the context of a thread during an oob-debug
                 * event.
                 *
                 * The data passed should be a CONTEXT structure for the current platform.
                 * (CONTEXT is typically declared in winnt.h)
                 *
                 * This is a dangerous call which can corrupt the runtime if used
                 * improperly.
                 *
                 */
            
                HRESULT SetThreadContext([in] DWORD threadID,
                                         [in] ULONG32 contextSize,
                                         [in, length_is(contextSize),
                                         size_is(contextSize)] BYTE context[]);
            
                /*
                 * ReadMemory reads memory from the process.
                 * This is primarily intended to be used by interop-debugging to inspect memory
                 * regions used by the unmanaged portion of the debuggee.
                 *
                 * This can also be used to read IL and native jitted code.
                 * Any managed breakpoints will be automatically stripped from the returned buffer.
                 * No adjustments will be made for Native breakpoints set by ICorDebugProcess2::SetUnmanagedBreakpoint
                 *
                 * No caching of process memory is peformed.
                 * These parameters have the same semantics as kernel32!ReadProcessMemory.
                 * The entire range must be read for the function to return success.
                 */
            
                HRESULT ReadMemory([in] CORDB_ADDRESS address, [in] DWORD size,
                                   [out, size_is(size), length_is(size)] BYTE buffer[],
                                   [out] SIZE_T *read);
            
                /*
                 * WriteMemory writes memory in the process.
                 * In v2.0, Native debuggers should *not* use this to inject breakpoints
                 * into the instruction stream. Use ICorDebugProcess2::SetUnamangedBreakpoint
                 * instead.
                 *
                 * This is a dangerous call which can corrupt the runtime if used
                 * improperly. It is highly recommended that this is only used outside
                 * of managed code.
                 *
                 * These parameters have the same semantics as kernel32!WriteProcessMemory.
                 */
            
                HRESULT WriteMemory([in] CORDB_ADDRESS address, [in] DWORD size,
                                    [in, size_is(size)] BYTE buffer[],
                                    [out]SIZE_T *written);
            
            
                /*
                 * ClearCurrentException clears the current unmanaged exception on
                 * the given thread. Call this before calling Continue when a
                 * thread has reported an unmanaged exception that should be
                 * ignored by the debuggee.
                 *
                 * This will clear both the outstanding IB and OOB events on the given thread.
                 * Out-of-band Breakpoint and single-step exceptions are automatically cleared.
                 *
                 * See ICorDebugThread2::InterceptCurrentException for continuing managed exceptions.
                 *
                 */
            
                HRESULT ClearCurrentException([in] DWORD threadID);
            
                /*
                 * EnableLogMessages enables/disables sending of log messages to the
                 * debugger for logging.
                 * This is only valid after the CreateProcess callback.
                 *
                 */
            
                HRESULT EnableLogMessages([in]BOOL fOnOff);
            
                /*
                 * ModifyLogSwitch modifies the specified switch's severity level.
                 * This is only valid after the CreateProcess callback.
                 *
                 */
                HRESULT ModifyLogSwitch([in, annotation("_In_")] WCHAR *pLogSwitchName,
                                        [in]LONG lLevel);
            
                /*
                 * EnumerateAppDomains enumerates all app domains in the process.
                 * This can be used before the CreateProcess callback.
                 *
                 */
            
                HRESULT EnumerateAppDomains([out] ICorDebugAppDomainEnum **ppAppDomains);
            
                /*
                 * NOT YET IMPLEMENTED
                 */
            
                HRESULT GetObject([out] ICorDebugValue **ppObject);
            
                /*
                 * DEPRECATED
                 */
            
                HRESULT ThreadForFiberCookie([in] DWORD fiberCookie,
                                             [out] ICorDebugThread **ppThread);
            
                /*
                 * Returns the OS thread id of the debugger's internal helper thread.
                 * During managed/unmanaged debugging, it is the debugger's
                 * responsibility to ensure that the thread with this ID remains running
                 * if it hits a breakpoint placed by the debugger. A debugger may also
                 * wish to hide this thread from the user.
                 *
                 * If there is no helper thread in the process yet, then this method
                 * will return zero as the thread id.
                 *
                 * Note: you cannot cache this value. The ID of the helper thread may
                 * change over time, so this value must be re-queried at every stopping
                 * event.
                 *
                 * Note: this value will be correct on every unmanaged CreateThread event.
                 * This will allow a debugger to determine the TID of the helper thread
                 * and hide it from the user. A thread identified as a helper thread during
                 * an unmanaged CreateThread event will never run managed user code.
                 */
            
                HRESULT GetHelperThreadID([out] DWORD *pThreadID);
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.Stop(System.UInt32)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.Stop(System.UInt32)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.Continue(System.Int32)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.Continue(System.Int32)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.IsRunning(System.Int32*)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.IsRunning(System.Int32*)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.HasQueuedCallbacks(JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread,System.Int32*)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.HasQueuedCallbacks(JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread,System.Int32*)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.EnumerateThreads(JetBrains.Debugger.CorApi.ComInterop.ICorDebugThreadEnum@)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.EnumerateThreads(JetBrains.Debugger.CorApi.ComInterop.ICorDebugThreadEnum@)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.SetAllThreadsDebugState(JetBrains.Debugger.CorApi.ComInterop.CorDebugThreadState,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.SetAllThreadsDebugState(JetBrains.Debugger.CorApi.ComInterop.CorDebugThreadState,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.Detach">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.Detach"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.Terminate(System.UInt32)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.Terminate(System.UInt32)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.CanCommitChanges(System.UInt32,System.Void**,System.Void**)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.CanCommitChanges(System.UInt32,System.Void**,System.Void**)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.CommitChanges(System.UInt32,System.Void**,System.Void**)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugController.CommitChanges(System.UInt32,System.Void**,System.Void**)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.GetID(System.UInt32*)">
            <summary>
            GetID returns the OS ID of the process.
            </summary>
            <param name="pdwProcessId"></param>
            <seealso cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcessEx.GetPid(JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess)"/>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.GetHandle(System.Void**)">
            <summary>
            GetHandle returns a handle to the process. This handle is owned
            by the debugging API; the debugger should duplicate it before
            using it.
            </summary>
            <param name="phProcessHandle"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.GetThread(System.UInt32,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread@)">
            <summary>
            GetThread returns the ICorDebugThread with the given OS Id.
            
            Note that eventually there will not be a one to one correspondence
            between OS threads and runtime threads, so this entry point will
            go away.
            </summary>
            <param name="dwThreadId"></param>
            <param name="ppThread"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.EnumerateObjects(JetBrains.Debugger.CorApi.ComInterop.ICorDebugObjectEnum@)">
            <summary>
            NOT YET IMPLEMENTED
            </summary>
            <param name="ppObjects"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.IsTransitionStub(System.UInt64,System.Int32*)">
            <summary>
            IsTransitionStub tests whether an address is inside of a transition stub
            which will cause a transition to managed code.  This can be used by
            unmanaged stepping code to decide when to return stepping control to
            the managed stepper.
            
            Note that, tentatively, these stubs may also be able to be identified
            ahead of time by looking at information in the PE file.
            </summary>
            <param name="address"></param>
            <param name="pbTransitionStub"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.IsOSSuspended(System.UInt32,System.Int32*)">
            <summary>
            IsOSSuspended returns whether or not the thread has been
            suspended as part of the debugger logic of stopping the process.
            (that is, it has had its Win32 suspend count incremented by
            one.)  The debugger UI may want to take this into account if
            it shows the user the OS suspend count of the thread.
            
            This function only makes sense in the context of
            unmanaged debugging - during managed debugging threads are not
            OS suspended. (They are cooperatively suspended.)
            </summary>
            <param name="threadID"></param>
            <param name="pbSuspended"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.GetThreadContext(System.UInt32,System.UInt32,System.Byte*)">
            <summary>
            GetThreadContext returns the context for the given thread.  The
            debugger should call this function rather than the Win32
            GetThreadContext, because the thread may actually be in a "hijacked"
            state where its context has been temporarily changed.
            
            This should only be used on when a thread is in native code. Use ICorDebugRegisterSet
            for threads in managed code.
            
            The data returned is a CONTEXT structure for the current platform.
            (CONTEXT is typically declared in winnt.h) Just as with a call
            to Win32's GetThreadContext, the caller should initialize the
            CONTEXT struct before calling. 
            </summary>
            <param name="threadID"></param>
            <param name="contextSize"></param>
            <param name="context"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.SetThreadContext(System.UInt32,System.UInt32,System.Byte*)">
            <summary>
            SetThreadContext sets the context for the given thread.  The
            debugger should call this function rather than the Win32
            SetThreadContext, because the thread may actually be in a "hijacked"
            state where its context has been temporarily changed.
            
            This should only be used on when a thread is in native code. Use ICorDebugRegisterSet
            for threads in managed code.
            
            This should never be needed to modify the context of a thread during an oob-debug
            event.
            
            The data passed should be a CONTEXT structure for the current platform.
            (CONTEXT is typically declared in winnt.h)
            
            This is a dangerous call which can corrupt the runtime if used
            improperly. 
            </summary>
            <param name="threadID"></param>
            <param name="contextSize"></param>
            <param name="context"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.ReadMemory(System.UInt64,System.UInt32,System.Byte*,System.UIntPtr*)">
            <summary>
            ReadMemory reads memory from the process.
            This is primarily intended to be used by interop-debugging to inspect memory
            regions used by the unmanaged portion of the debuggee.
            
            This can also be used to read IL and native jitted code.
            Any managed breakpoints will be automatically stripped from the returned buffer.
            No adjustments will be made for Native breakpoints set by ICorDebugProcess2::SetUnmanagedBreakpoint
            
            No caching of process memory is peformed.
            These parameters have the same semantics as kernel32!ReadProcessMemory.
            The entire range must be read for the function to return success.
            </summary>
            <param name="address"></param>
            <param name="size"></param>
            <param name="buffer"></param>
            <param name="read"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.WriteMemory(System.UInt64,System.UInt32,System.Byte*,System.UIntPtr*)">
            <summary>
            WriteMemory writes memory in the process.
            In v2.0, Native debuggers should *not* use this to inject breakpoints
            into the instruction stream. Use ICorDebugProcess2::SetUnamangedBreakpoint
            instead.
            
            This is a dangerous call which can corrupt the runtime if used
            improperly. It is highly recommended that this is only used outside
            of managed code.
            
            These parameters have the same semantics as kernel32!WriteProcessMemory. 
            </summary>
            <param name="address"></param>
            <param name="size"></param>
            <param name="buffer"></param>
            <param name="written"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.ClearCurrentException(System.UInt32)">
            <summary>
            ClearCurrentException clears the current unmanaged exception on
            the given thread. Call this before calling Continue when a
            thread has reported an unmanaged exception that should be
            ignored by the debuggee.
            
            This will clear both the outstanding IB and OOB events on the given thread.
            Out-of-band Breakpoint and single-step exceptions are automatically cleared.
            
            See ICorDebugThread2::InterceptCurrentException for continuing managed exceptions.
            </summary>
            <param name="threadID"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.EnableLogMessages(System.Int32)">
            <summary>
            EnableLogMessages enables/disables sending of log messages to the
            debugger for logging.
            This is only valid after the CreateProcess callback.
            </summary>
            <param name="fOnOff"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.ModifyLogSwitch(System.UInt16*,System.Int32)">
            <summary>
            ModifyLogSwitch modifies the specified switch's severity level.
            This is only valid after the CreateProcess callback.
            </summary>
            <param name="pLogSwitchName"></param>
            <param name="lLevel"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.EnumerateAppDomains(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomainEnum@)">
            <summary>
            EnumerateAppDomains enumerates all app domains in the process.
            This can be used before the CreateProcess callback.
            </summary>
            <param name="ppAppDomains"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.GetObject(JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            NOT YET IMPLEMENTED
            </summary>
            <param name="ppObject"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.ThreadForFiberCookie(System.UInt32,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread@)">
            <summary>
            DEPRECATED
            </summary>
            <param name="fiberCookie"></param>
            <param name="ppThread"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess.GetHelperThreadID(System.UInt32*)">
            <summary>
            Returns the OS thread id of the debugger's internal helper thread.
            During managed/unmanaged debugging, it is the debugger's
            responsibility to ensure that the thread with this ID remains running
            if it hits a breakpoint placed by the debugger. A debugger may also
            wish to hide this thread from the user.
            
            If there is no helper thread in the process yet, then this method
            will return zero as the thread id.
            
            Note: you cannot cache this value. The ID of the helper thread may
            change over time, so this value must be re-queried at every stopping
            event.
            
            Note: this value will be correct on every unmanaged CreateThread event.
            This will allow a debugger to determine the TID of the helper thread
            and hide it from the user. A thread identified as a helper thread during
            an unmanaged CreateThread event will never run managed user code.
            </summary>
            <param name="pThreadID"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess2">
            <summary>
            </summary>
            <example><code>
             [
                object,
                local,
                uuid(AD1B3588-0EF0-4744-A496-AA09A9F80371),
                pointer_default(unique)
            ]
            interface ICorDebugProcess2 : IUnknown
            {
            
                /*
                  * Return a ICorDebugThread2 interface given a TASKID
                 * Host can set TASKID using ICLRTask::SetTaskIdentifier
                  */
                HRESULT GetThreadForTaskID(
                   [in] TASKID taskid,
                   [out] ICorDebugThread2 **ppThread);
            
            
                /*
                 * Returns the version of the runtime the debugee process is running.
                 */
                HRESULT GetVersion([out] COR_VERSION* version);
            
                /*
                 * Set an unmanaged breakpoint at the given native address. If the address is within
                 * the runtime, the breakpoint will be ignored.
                 * This allows the CLR to avoid dispatching out-of-band breakpoints for breakpoints
                 * set by the debugger.
                 * buffer[] returns the opcode at the address that is replaced by the breakpoint.
                 */
            
                HRESULT SetUnmanagedBreakpoint([in] CORDB_ADDRESS address,
                                               [in] ULONG32 bufsize,
                                               [out, size_is(bufsize), length_is(*bufLen)] BYTE buffer[],
                                               [out] ULONG32 * bufLen);
            
                /*
                 * Remove a breakpoint set by SetUnmanagedBreakpoint.
                 */
                HRESULT ClearUnmanagedBreakpoint([in] CORDB_ADDRESS address);
            
            
                /*
                 * SetDesiredNGENCompilerFlags specifies the set of flags that must be set in a pre-JITted
                 * image in order for the runtime to load that image into this app domain. If no such image exists,
                 * the runtime will load the IL and JIT instead. The flags set by this function are just used to select the
                 * correct pre-JITted image; if no suitable image is found the debugger will still need to use
                 * ICorDebugModule2::SetJITCompilerFlags to set the flags as desired for JIT.
                 *
                 * This function must be called during the CreateProcess callback.
                 * Attempts to call it after this callback has been delivered will fail.
                 */
                 HRESULT SetDesiredNGENCompilerFlags( [in] DWORD pdwFlags );
            
                /*
                 * GetDesiredNGENCompilerFlags gets the set of flags that must be set in a pre-JITted image in order
                 * for the runtime to load that image into this process.
                 */
                 HRESULT GetDesiredNGENCompilerFlags( [out] DWORD *pdwFlags );
            
            
                /*
                * Gets an ICorDebugReferenceValue object from a raw GC handle value.
                *
                * handle is the IntPtr within a GCHandle. Do not confuse
                * this with a GC reference value. This is a potentially dangerous API and may
                * corrupt both the debugger and debuggee if a bogus handle is passed in.
                * This API does not necessarily validate that the handle is valid.
                *
                * The ICorDebugReferenceValue will behave much like a normal reference. It will
                * be neutered on the next continue; the lifetime of the target object will
                * not be affected by the existence of the ReferenceValue.
                */
                HRESULT GetReferenceValueFromGCHandle( [in] UINT_PTR handle,
                                                       [out] ICorDebugReferenceValue **pOutValue);
            
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess2.GetThreadForTaskID(System.UInt64,JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread2@)">
            <summary>
            Return a ICorDebugThread2 interface given a TASKID
            Host can set TASKID using ICLRTask::SetTaskIdentifier
            </summary>
            <param name="taskid"></param>
            <param name="ppThread"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess2.GetVersion(JetBrains.Debugger.CorApi.ComInterop.COR_VERSION*)">
            <summary>
            Returns the version of the runtime the debugee process is running.
            </summary>
            <param name="version"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess2.SetUnmanagedBreakpoint(System.UInt64,System.UInt32,System.Byte*,System.UInt32*)">
            <summary>
            Set an unmanaged breakpoint at the given native address. If the address is within
            the runtime, the breakpoint will be ignored.
            This allows the CLR to avoid dispatching out-of-band breakpoints for breakpoints
            set by the debugger.
            buffer[] returns the opcode at the address that is replaced by the breakpoint.
            </summary>
            <param name="address"></param>
            <param name="bufsize"></param>
            <param name="buffer"></param>
            <param name="bufLen"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess2.ClearUnmanagedBreakpoint(System.UInt64)">
            <summary>
            Remove a breakpoint set by SetUnmanagedBreakpoint.
            </summary>
            <param name="address"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess2.SetDesiredNGENCompilerFlags(System.UInt32)">
            <summary>
            SetDesiredNGENCompilerFlags specifies the set of flags that must be set in a pre-JITted
            image in order for the runtime to load that image into this app domain. If no such image exists,
            the runtime will load the IL and JIT instead. The flags set by this function are just used to select the
            correct pre-JITted image; if no suitable image is found the debugger will still need to use
            ICorDebugModule2::SetJITCompilerFlags to set the flags as desired for JIT.
            This function must be called during the CreateProcess callback.
            Attempts to call it after this callback has been delivered will fail.
            </summary>
            <param name="pdwFlags"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess2.GetDesiredNGENCompilerFlags(System.UInt32*)">
            <summary>
             GetDesiredNGENCompilerFlags gets the set of flags that must be set in a pre-JITted image in order
             for the runtime to load that image into this process.
            </summary>
            <param name="pdwFlags"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess2.GetReferenceValueFromGCHandle(System.Void*,JetBrains.Debugger.CorApi.ComInterop.ICorDebugReferenceValue@)">
            <summary>
            Gets an ICorDebugReferenceValue object from a raw GC handle value.
            handle is the IntPtr within a GCHandle. Do not confuse
            this with a GC reference value. This is a potentially dangerous API and may
            corrupt both the debugger and debuggee if a bogus handle is passed in.
            This API does not necessarily validate that the handle is valid.
            The ICorDebugReferenceValue will behave much like a normal reference. It will
            be neutered on the next continue; the lifetime of the target object will
            not be affected by the existence of the ReferenceValue.
            </summary>
            <param name="handle"></param>
            <param name="pOutValue"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess3.SetEnableCustomNotification(JetBrains.Debugger.CorApi.ComInterop.ICorDebugClass,System.Int32)">
             <summary>
             Enables and disables custom debugger notifications of the specified type.
            
             When fEnable is set to true, calls to the Debugger.NotifyOfCrossThreadDependency method trigger
             an ICorDebugManagedCallback3::CustomNotification callback.
             Notifications are disabled by default; therefore, the debugger must specify any notification types it knows
             about and wants to handle. Because the ICorDebugClass class is scoped by application domain,
             the debugger must call SetEnableCustomNotification for every application domain in the process
             if it wants to receive the notification across the entire process.
            
             Starting with the .NET Framework version 4, the only supported notification is a cross-thread dependency notification.
             </summary>
             <param name="pClass">[in] The type that specifies custom debugger notifications.</param>
             <param name="fEnable">[in] true to enable custom debugger notifications; false to disable notifications. The default value is false.</param>
             <returns></returns>
             <seealso cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback3.CustomNotification(JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread,JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain)"/>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcessEnum">
            <summary>
            </summary>
            <example><code>
            [
                object,
                local,
                uuid(CC7BCB05-8A68-11d2-983C-0000F808342D),
                pointer_default(unique)
            ]
            interface ICorDebugProcessEnum : ICorDebugEnum
            {
                /*
                 * Gets the next "celt" number of processes in the enumeration.
                 * The actual number of processes retrieved is returned in "pceltFetched".
                 * Returns S_FALSE if the actual number of processes retrieved is smaller
                 * than the number of processes requested.
                 */
                HRESULT Next([in] ULONG celt,
                             [out, size_is(celt), length_is(*pceltFetched)]
                                ICorDebugProcess *processes[],
                             [out] ULONG *pceltFetched);
            }; </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcessEnum.Skip(System.UInt32)">
            <summary>
            Moves the current position forward the given number of elements.
            </summary>
            <param name="celt">the given number of elements</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcessEnum.Reset">
            <summary>
            Sets the position of the enumerator to the beginning of the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcessEnum.Clone(JetBrains.Debugger.CorApi.ComInterop.ICorDebugEnum@)">
            <summary>
            Creates another enumerator with the same current position as this one.
            </summary>
            <param name="ppEnum">another enumerator</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcessEnum.GetCount(System.UInt32*)">
            <summary>
            Gets the number of elements in the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcessEnum.Next(System.UInt32,System.Void**,System.UInt32*)">
            <summary>
            Gets the next "celt" number of processes in the enumeration.
            The actual number of processes retrieved is returned in "pceltFetched".
            Returns S_FALSE if the actual number of processes retrieved is smaller than the number of processes requested.
            </summary>
            <param name="celt"></param>
            <param name="processes"></param>
            <param name="pceltFetched"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugReferenceValue">
            <summary>
             ICorDebugReferenceValue is a subclass of ICorDebugValue which applies to
             a reference type.
             The runtime may Garbage Collect objects once the debuggee is continued. The GC may
             move objects around in memory.
             An ICorDebugReference will either cooperate with GCs such that its information is updated
             after the GC, or it will be implicitly neutered before the GC.
             The ICorDebugReferenceValue inteface may be implicitly neutered after the debuggee
             has been continued. The derived ICorDebugHandleValue is not neutered until explicitly
             released or exposed.
            </summary>
            <example><code>
             
             * ICorDebugReferenceValue is a subclass of ICorDebugValue which applies to
             * a reference type.
             * The runtime may Garbage Collect objects once the debuggee is continued. The GC may
             * move objects around in memory.
             *
             * An ICorDebugReference will either cooperate with GCs such that its information is updated
             * after the GC, or it will be implicitly neutered before the GC.
             *
             * The ICorDebugReferenceValue inteface may be implicitly neutered after the debuggee
             * has been continued. The derived ICorDebugHandleValue is not neutered until explicitly
             * released or exposed.
             *
             */
            
            [
                object,
                local,
                uuid(CC7BCAF9-8A68-11d2-983C-0000F808342D),
                pointer_default(unique)
            ]
            interface ICorDebugReferenceValue : ICorDebugValue
            {
                /*
                 * IsNull tests whether the reference is null.
                 */
            
                HRESULT IsNull([out] BOOL *pbNull);
            
                /*
                 * GetValue returns the current address of the object referred to by this
                 * reference.
                 */
            
                HRESULT GetValue([out] CORDB_ADDRESS *pValue);
            
                /*
                 * SetValue sets this reference to refer to a different address.
                 */
            
                HRESULT SetValue([in] CORDB_ADDRESS value);
            
                /*
                 * Dereference returns a ICorDebugValue representing the value
                 * referenced. This is only valid while the interface has not yet been neutered.
                 */
            
                HRESULT Dereference([out] ICorDebugValue **ppValue);
            
                /*
                 * DEPRECATED
                 */
            
                HRESULT DereferenceStrong([out] ICorDebugValue **ppValue);
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugReferenceValue.GetType(JetBrains.Debugger.CorApi.ComInterop.CorElementType*)">
            <summary>
            GetType returns the simple type of the value.  If the object
            has a more complex runtime type, that type may be examined through the
            appropriate subclasses (e.g. ICorDebugObjectValue can get the class of
            an object.)
            </summary>
            <param name="elementType"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugReferenceValue.GetSize(System.UInt32*)">
            <summary>
            GetSize returns the size of the value in bytes. Note that for reference
            types this will be the size of the pointer rather than the size of
            the object.
            </summary>
            <param name="pSize"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugReferenceValue.GetAddress(System.UInt64*)">
            <summary>
            GetAddress returns the address of the value in the debugee
            process.  This might be useful information for the debugger to
            show.
            If the value is unavailable, 0 is returned. This could happen if
            it is at least partly in registers or stored in a GC Handle.
            </summary>
            <param name="pAddress"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugReferenceValue.CreateBreakpoint(JetBrains.Debugger.CorApi.ComInterop.ICorDebugValueBreakpoint@)">
            <summary>
            NOT YET IMPLEMENTED
            </summary>
            <param name="ppBreakpoint"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugReferenceValue.IsNull(System.Int32*)">
            <summary>
            IsNull tests whether the reference is null.
            </summary>
            <param name="pbNull"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugReferenceValue.GetValue(System.UInt64*)">
            <summary>
            GetValue returns the current address of the object referred to by this reference.
            </summary>
            <param name="pValue"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugReferenceValue.SetValue(System.UInt64)">
            <summary>
            SetValue sets this reference to refer to a different address.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugReferenceValue.Dereference(JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            Dereference returns a ICorDebugValue representing the value
            referenced. This is only valid while the interface has not yet been neutered.
            </summary>
            <param name="ppValue"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugReferenceValue.DereferenceStrong(JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            DEPRECATED
            </summary>
            <param name="ppValue"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugRegisterSet">
            <summary>
            </summary>
            <example><code>
             
             * Program state object interfaces
             * ------------------------------------------------------------------------- */
            
             * ICorDebugRegisterSet
             */
            
            [
                object,
                local,
                uuid(CC7BCB0B-8A68-11d2-983C-0000F808342D),
                pointer_default(unique)
            ]
            interface ICorDebugRegisterSet : IUnknown
            {
                typedef enum CorDebugRegister
                {
                    // registers (potentially) available on all architectures
                    // Note that these overlap with the architecture-specific
                    // registers
                    //
                    // NOTE: On IA64, REGISTER_FRAME_POINTER represents the BSP register.
            
                    REGISTER_INSTRUCTION_POINTER = 0,
                    REGISTER_STACK_POINTER,
                    REGISTER_FRAME_POINTER,
            
            
                    // X86 registers
            
                    REGISTER_X86_EIP = 0,
                    REGISTER_X86_ESP,
                    REGISTER_X86_EBP,
            
                    REGISTER_X86_EAX,
                    REGISTER_X86_ECX,
                    REGISTER_X86_EDX,
                    REGISTER_X86_EBX,
            
                    REGISTER_X86_ESI,
                    REGISTER_X86_EDI,
            
                    REGISTER_X86_FPSTACK_0,
                    REGISTER_X86_FPSTACK_1,
                    REGISTER_X86_FPSTACK_2,
                    REGISTER_X86_FPSTACK_3,
                    REGISTER_X86_FPSTACK_4,
                    REGISTER_X86_FPSTACK_5,
                    REGISTER_X86_FPSTACK_6,
                    REGISTER_X86_FPSTACK_7,
            
            
                    // AMD64 registers
            
                    REGISTER_AMD64_RIP = 0,
                    REGISTER_AMD64_RSP,
                    REGISTER_AMD64_RBP,
            
                    REGISTER_AMD64_RAX,
                    REGISTER_AMD64_RCX,
                    REGISTER_AMD64_RDX,
                    REGISTER_AMD64_RBX,
            
                    REGISTER_AMD64_RSI,
                    REGISTER_AMD64_RDI,
            
                    REGISTER_AMD64_R8,
                    REGISTER_AMD64_R9,
                    REGISTER_AMD64_R10,
                    REGISTER_AMD64_R11,
                    REGISTER_AMD64_R12,
                    REGISTER_AMD64_R13,
                    REGISTER_AMD64_R14,
                    REGISTER_AMD64_R15,
            
                    // Xmm FP
            
                    REGISTER_AMD64_XMM0,
                    REGISTER_AMD64_XMM1,
                    REGISTER_AMD64_XMM2,
                    REGISTER_AMD64_XMM3,
                    REGISTER_AMD64_XMM4,
                    REGISTER_AMD64_XMM5,
                    REGISTER_AMD64_XMM6,
                    REGISTER_AMD64_XMM7,
                    REGISTER_AMD64_XMM8,
                    REGISTER_AMD64_XMM9,
                    REGISTER_AMD64_XMM10,
                    REGISTER_AMD64_XMM11,
                    REGISTER_AMD64_XMM12,
                    REGISTER_AMD64_XMM13,
                    REGISTER_AMD64_XMM14,
                    REGISTER_AMD64_XMM15,
            
            
                    // IA64 registers
            
                    REGISTER_IA64_BSP = REGISTER_FRAME_POINTER,
            
                    // To get a particular general register, add the register number
                    // to REGISTER_IA64_R0.  The same also goes for floating point
                    // registers.
                    //
                    // For example, if you need REGISTER_IA64_R83,
                    // use REGISTER_IA64_R0 + 83.
                    REGISTER_IA64_R0  = REGISTER_IA64_BSP + 1,
                    REGISTER_IA64_F0  = REGISTER_IA64_R0  + 128,
            
            
                    // ARM registers (@ARMTODO: FP?)
            
                    REGISTER_ARM_PC = 0,
                    REGISTER_ARM_SP,
                    REGISTER_ARM_R0,
                    REGISTER_ARM_R1,
                    REGISTER_ARM_R2,
                    REGISTER_ARM_R3,
                    REGISTER_ARM_R4,
                    REGISTER_ARM_R5,
                    REGISTER_ARM_R6,
                    REGISTER_ARM_R7,
                    REGISTER_ARM_R8,
                    REGISTER_ARM_R9,
                    REGISTER_ARM_R10,
                    REGISTER_ARM_R11,
                    REGISTER_ARM_R12,
                    REGISTER_ARM_LR,
            
                    // ARM64 registers
                        
                    REGISTER_ARM64_PC = 0,
                    REGISTER_ARM64_SP,
                    REGISTER_ARM64_FP,
                    REGISTER_ARM64_X0,
                    REGISTER_ARM64_X1,
                    REGISTER_ARM64_X2,
                    REGISTER_ARM64_X3,
                    REGISTER_ARM64_X4,
                    REGISTER_ARM64_X5,
                    REGISTER_ARM64_X6,
                    REGISTER_ARM64_X7,
                    REGISTER_ARM64_X8,
                    REGISTER_ARM64_X9,
                    REGISTER_ARM64_X10,
                    REGISTER_ARM64_X11,
                    REGISTER_ARM64_X12,
                    REGISTER_ARM64_X13,
                    REGISTER_ARM64_X14,
                    REGISTER_ARM64_X15,
                    REGISTER_ARM64_X16,
                    REGISTER_ARM64_X17,
                    REGISTER_ARM64_X18,
                    REGISTER_ARM64_X19,
                    REGISTER_ARM64_X20,
                    REGISTER_ARM64_X21,
                    REGISTER_ARM64_X22,
                    REGISTER_ARM64_X23,
                    REGISTER_ARM64_X24,
                    REGISTER_ARM64_X25,
                    REGISTER_ARM64_X26,
                    REGISTER_ARM64_X27,
                    REGISTER_ARM64_X28,
                    REGISTER_ARM64_LR,
            
                    // other architectures here
            
                } CorDebugRegister;
            
                /*
                 * GetRegistersAvailable returns a mask indicating which registers
                 * are available in the given register set.  Registers may be unavailable
                 * if their value is undeterminable for the given situation.  The returned
                 * word contains a bit for each register (1 &lt;&lt; register index), which will
                 * be 1 if the register is available or 0 if it is not.
                 */
            
                HRESULT GetRegistersAvailable([out] ULONG64 *pAvailable);
            
                /*
                 * GetRegisters returns an array of register values corresponding
                 * to the given mask.  The registers which have their bit set in
                 * the mask will be packed into the resulting array.  (No room is
                 * assigned in the array for registers whose mask bit is not set.)
                 * Thus, the size of the array should be equal to the number of
                 * 1's in the mask.
                 *
                 * If an unavailable register is indicated by the mask, an indeterminate
                 * value will be returned for the corresponding register.
                 *
                 * registerBufferCount should indicate number of elements in the
                 * buffer to receive the register values.  If it is too small for
                 * the number of registers indicated by the mask, the higher
                 * numbered registers will be truncated from the set.  Or, if it
                 * is too large, the unused registerBuffer elements will be
                 * unmodified.  */
            
                HRESULT GetRegisters([in] ULONG64 mask, [in] ULONG32 regCount,
                                     [out, size_is(regCount), length_is(regCount)]
                                     CORDB_REGISTER regBuffer[]);
            
                /*
                 * NOT YET IMPLEMENTED
                 */
            
                HRESULT SetRegisters([in] ULONG64 mask,
                                     [in] ULONG32 regCount,
                                     [in, size_is(regCount)] CORDB_REGISTER regBuffer[]);
            
                /*
                 * GetThreadContext returns the context for the given thread.  The
                 * debugger should call this function rather than the Win32
                 * GetThreadContext, because the thread may actually be in a "hijacked"
                 * state where its context has been temporarily changed.
                 *
                 * The data returned is a CONTEXT structure for the current platform.
                 *
                 * For non-leaf frames, clients should check which registers are valid by
                 * using GetRegistersAvailable.
                 *
                 */
            
                HRESULT GetThreadContext([in] ULONG32 contextSize,
                                         [in, out, length_is(contextSize),
                                         size_is(contextSize)] BYTE context[]);
            
                /*
                 * Not implemented in v2.0. It is too dangerous to manipulate the context of
                 * threads in Managed code. Use other high level operations (like SetIp,
                 * ICorDebugValue::SetValue) instead.
                 *
                 */
            
                HRESULT SetThreadContext([in] ULONG32 contextSize,
                                         [in, length_is(contextSize),
                                         size_is(contextSize)] BYTE context[]);
            }
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugRegisterSet.GetRegistersAvailable(System.UInt64*)">
            <summary>
            GetRegistersAvailable returns a mask indicating which registers
            are available in the given register set.  Registers may be unavailable
            if their value is undeterminable for the given situation.  The returned
            word contains a bit for each register (1 &lt;&lt; register index), which will
            be 1 if the register is available or 0 if it is not.
            </summary>
            <param name="pAvailable"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugRegisterSet.GetRegisters(System.UInt64,System.UInt32,System.UInt64*)">
            <summary>
            GetRegisters returns an array of register values corresponding
            to the given mask.  The registers which have their bit set in
            the mask will be packed into the resulting array.  (No room is
            assigned in the array for registers whose mask bit is not set.)
            Thus, the size of the array should be equal to the number of
            1's in the mask.
            If an unavailable register is indicated by the mask, an indeterminate
            value will be returned for the corresponding register.
            registerBufferCount should indicate number of elements in the
            buffer to receive the register values.  If it is too small for
            the number of registers indicated by the mask, the higher
            numbered registers will be truncated from the set.  Or, if it
            is too large, the unused registerBuffer elements will be
            unmodified.
            </summary>
            <param name="mask"></param>
            <param name="regCount"></param>
            <param name="regBuffer"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugRegisterSet.SetRegisters(System.UInt64,System.UInt32,System.UInt64*)">
            <summary>
            NOT YET IMPLEMENTED
            </summary>
            <param name="mask"></param>
            <param name="regCount"></param>
            <param name="regBuffer"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugRegisterSet.GetThreadContext(System.UInt32,System.Byte*)">
            <summary>
            GetThreadContext returns the context for the given thread.  The
            debugger should call this function rather than the Win32
            GetThreadContext, because the thread may actually be in a "hijacked"
            state where its context has been temporarily changed.
            The data returned is a CONTEXT structure for the current platform.
            For non-leaf frames, clients should check which registers are valid by
            using GetRegistersAvailable.
            </summary>
            <param name="contextSize"></param>
            <param name="context"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugRegisterSet.SetThreadContext(System.UInt32,System.Byte*)">
            <summary>
            Not implemented in v2.0. It is too dangerous to manipulate the context of
            threads in Managed code. Use other high level operations (like SetIp,
            ICorDebugValue::SetValue) instead.
            </summary>
            <param name="contextSize"></param>
            <param name="context"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugRuntimeUnwindableFrame">
            <summary>
             ICorDebugRuntimeUnwindableFrame is a specialized interface of ICorDebugFrame for unmanaged methods
             which requires special knowledge to unwind.  They are not jitted code.  When the debugger sees this type
             of frames, it should use ICorDebugStackWalk::Next() to unwind, but it should do inspection itself.
             The debugger can call ICorDebugStackWalk::GetContext() to retrieve the CONTEXT of the frame when it gets
             an ICorDebugRuntimeUnwindableFrame.
            </summary>
            <example><code>
             /*
             * ICorDebugRuntimeUnwindableFrame is a specialized interface of ICorDebugFrame for unmanaged methods
             * which requires special knowledge to unwind.  They are not jitted code.  When the debugger sees this type
             * of frames, it should use ICorDebugStackWalk::Next() to unwind, but it should do inspection itself.
             * The debugger can call ICorDebugStackWalk::GetContext() to retrieve the CONTEXT of the frame when it gets 
             * an ICorDebugRuntimeUnwindableFrame.
             */
            
            [
                object,
                local,
                uuid(879CAC0A-4A53-4668-B8E3-CB8473CB187F),
                pointer_default(unique)
            ]
            interface ICorDebugRuntimeUnwindableFrame : ICorDebugFrame
            {
            }
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugRuntimeUnwindableFrame.GetChain(JetBrains.Debugger.CorApi.ComInterop.ICorDebugChain@)">
            <summary>
            GetChain returns the chain of which this stack frame is a part.
            </summary>
            <param name="ppChain"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugRuntimeUnwindableFrame.GetCode(JetBrains.Debugger.CorApi.ComInterop.ICorDebugCode@)">
            <summary>
            GetCode returns the code which this stack frame is running if any.
            </summary>
            <param name="ppCode"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugRuntimeUnwindableFrame.GetFunction(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFunction@)">
            <summary>
            GetFunction returns the function for the code which this stack
            frame is running.
            For ICorDebugInternalFrames, this may point to a method the
            frame is associated with (which may be in a different AppDomain
            from the frame itself), or may fail if the frame doesn't relate to any
            particular function.
            </summary>
            <param name="ppFunction"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugRuntimeUnwindableFrame.GetFunctionToken(System.UInt32*)">
            <summary>
            GetFunctionToken is a convenience routine to return the token for the
            function for the code which this stack frame is running.
            The scope to resolve the token can be gotten from the ICorDebugFunction
            associated with this frame.</summary>
            <param name="pToken"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugRuntimeUnwindableFrame.GetStackRange(System.UInt64*,System.UInt64*)">
            <summary>
            GetStackRange returns the absolute address range of the stack
            frame.  (This is useful for piecing together interleaved stack
            traces gathered from multiple debugging engines.)  Note that you
            cannot make any assumptions about what is actually stored on
            the stack - the numeric range is to compare stack frame
            locations only.
            The start of a stack range is the leafmost boundary of the frame, and
            the end of a stack range is the rootmost boundary of the frame.
            </summary>
            <param name="pStart"></param>
            <param name="pEnd"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugRuntimeUnwindableFrame.GetCaller(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame@)">
            <summary>
            GetCaller returns a pointer to the frame in the current chain
            which called this frame, or NULL if this is the rootmost frame
            in the chain.
            </summary>
            <param name="ppFrame"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugRuntimeUnwindableFrame.GetCallee(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame@)">
            <summary>
            GetCallee returns a pointer to the frame in the current chain
            which this frame called, or NULL if this is the leafmost frame
            in the chain.
            </summary>
            <param name="ppFrame"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugRuntimeUnwindableFrame.CreateStepper(JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper@)">
            <summary>
            CreateStepper creates a stepper object which operates relative to the
            frame. The Stepper API must then be used to perform actual stepping.
            Note that if this frame is not active, the frame will typically have to
            be returned to before the step is completed.
            </summary>
            <param name="ppStepper"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStackWalk">
            <summary>
             The new V3.0 stackwalking API.
            </summary>
            <example><code>
             
             * The new V3.0 stackwalking API.
             */
            [
                object,
                local,
                uuid(A0647DE9-55DE-4816-929C-385271C64CF7),
                pointer_default(unique)
            ]
            interface ICorDebugStackWalk : IUnknown
            {
                typedef enum CorDebugSetContextFlag
                {
                    SET_CONTEXT_FLAG_ACTIVE_FRAME = 0x1,
                    SET_CONTEXT_FLAG_UNWIND_FRAME = 0x2,
                } CorDebugSetContextFlag;
            
                /* 
                 * Get the current context of this stack frame.
                 * 
                 * The CONTEXT is retrieved from the ICorDebugStackWalk.  As unwinding may only restore a subset of the 
                 * registers, such as only non-volatile registers, the context may not exactly match the register state at 
                 * the time of the actual call.
                 */
                HRESULT GetContext([in] ULONG32 contextFlags,
                                   [in] ULONG32 contextBufSize,
                                   [out] ULONG32* contextSize,
                                   [out, size_is(contextBufSize)] BYTE contextBuf[]);
            
                /* 
                 * Change the current context of this stack walk, allowing the
                 * debugger to move it to an arbitrary context. Does not actually
                 * alter the current context of the thread whose stack is being walked.
                 *
                 * The CONTEXT has to be a valid CONTEXT of a stack frame on the thread.
                 * If the CONTEXT is outside of the current thread's stack range, we'll
                 * return a failure HRESULT.  Otherwise, in the case of an invalid CONTEXT, 
                 * the result is undefined.
                 */
                HRESULT SetContext([in] CorDebugSetContextFlag flag,
                                   [in] ULONG32 contextSize,
                                   [in, size_is(contextSize)] BYTE context[]);
            
                /*
                 * Attempt to advance the stackwalk to the next frame.  
                 * If the current frame type is a native stack frame, Next() will not advance to the caller frame.
                 * Instead, Next() will advance to the next managed stack frame or the next internal frame marker.
                 *
                 * If a debugger wants to unwind unmanaged stack frames, it needs to start from the 
                 * native stack frame itself.  It can seed the unwind by calling GetContext().
                 *
                 * This function will return CORDBG_S_AT_END_OF_STACK when there are no more frames.
                 */
                HRESULT Next();
            
                /*
                 * Return the current frame.  If the stackwalker is stopped at a native stack frame, we will return S_FALSE
                 * and set pFrame to NULL.
                 */
                HRESULT GetFrame([out] ICorDebugFrame ** pFrame);
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStackWalk.GetContext(System.UInt32,System.UInt32,System.UInt32*,System.Byte*)">
            <summary>
            Get the current context of this stack frame.
            The CONTEXT is retrieved from the ICorDebugStackWalk.  As unwinding may only restore a subset of the
            registers, such as only non-volatile registers, the context may not exactly match the register state at
            the time of the actual call.
            </summary>
            <param name="contextFlags"><see cref="T:JetBrains.Debugger.CorApi.ComInterop.CorDebugSetContextFlag" /></param>
            <param name="contextBufSize"></param>
            <param name="contextSize"></param>
            <param name="contextBuf"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStackWalk.SetContext(JetBrains.Debugger.CorApi.ComInterop.CorDebugSetContextFlag,System.UInt32,System.Byte*)">
            <summary>
            Change the current context of this stack walk, allowing the
            debugger to move it to an arbitrary context. Does not actually
            alter the current context of the thread whose stack is being walked.
            The CONTEXT has to be a valid CONTEXT of a stack frame on the thread.
            If the CONTEXT is outside of the current thread's stack range, we'll
            return a failure HRESULT.  Otherwise, in the case of an invalid CONTEXT,
            the result is undefined.
            </summary>
            <param name="flag"></param>
            <param name="contextSize"></param>
            <param name="context"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStackWalk.Next">
            <summary>
            Attempt to advance the stackwalk to the next frame.
            If the current frame type is a native stack frame, Next() will not advance to the caller frame.
            Instead, Next() will advance to the next managed stack frame or the next internal frame marker.
            If a debugger wants to unwind unmanaged stack frames, it needs to start from the
            native stack frame itself.  It can seed the unwind by calling GetContext().
            This function will return CORDBG_S_AT_END_OF_STACK when there are no more frames.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStackWalk.GetFrame(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame@)">
            <summary>
            Return the current frame.  If the stackwalker is stopped at a native stack frame, we will return S_FALSE and set pFrame to NULL.
            </summary>
            <param name="pFrame"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper">
            <summary>
             A Stepper object represents a stepping operation being performed by
             the debugger.  Note that there can be more than one stepper per
             thread; for instance a breakpoint may be hit in the midst of a
             stepping over a function, and the user may wish to start a new
             stepping operation inside that function. (Note that it is up to the
             debugger how to handle this; it may want to cancel the original
             stepping operation, or nest them.  This API allows either behavior.)
             Also, a stepper may migrate between threads if a cross-thread
             marshalled call is made by the EE.
             This object serves several purposes.  Its serves as an identifer between a
             step command issued and the completion of that command. It also
             provides a central interface to encapsulate all of the stepping
             that can be performed.  Finally it provides a way to prematurely
             cancel a stepping operation.
            </summary>
            <example><code>
             /* ------------------------------------------------------------------------- *
             * Stepper interface
             * ------------------------------------------------------------------------- */
            
             /*
             * A Stepper object represents a stepping operation being performed by
             * the debugger.  Note that there can be more than one stepper per
             * thread; for instance a breakpoint may be hit in the midst of a
             * stepping over a function, and the user may wish to start a new
             * stepping operation inside that function. (Note that it is up to the
             * debugger how to handle this; it may want to cancel the original
             * stepping operation, or nest them.  This API allows either behavior.)
             *
             * Also, a stepper may migrate between threads if a cross-thread
             * marshalled call is made by the EE.
             *
             * This object serves several purposes.  Its serves as an identifer between a
             * step command issued and the completion of that command. It also
             * provides a central interface to encapsulate all of the stepping
             * that can be performed.  Finally it provides a way to prematurely
             * cancel a stepping operation.
             *
             */
            
            [
                object,
                local,
                uuid(CC7BCAEC-8A68-11d2-983C-0000F808342D),
                pointer_default(unique)
            ]
            interface ICorDebugStepper : IUnknown
            {
                /*
                 * IsActive returns whether or not the stepper is active, that is, whether
                 * it is currently stepping.
                 *
                 * Any step action remains active until StepComplete is called.  Note that
                 * this automatically deactivates the stepper.
                 *
                 * A stepper may also be deactivated prematurely by calling
                 * Deactivate before a callback condition is reached.
                 */
            
                HRESULT IsActive([out] BOOL *pbActive);
            
                /*
                 * Deactivate causes a stepper to cancel the last stepping command it
                 * received.  A new stepping command may then be issued.
                 */
            
                HRESULT Deactivate();
            
                /*
                 * SetInterceptMask controls which intercept code will be stepped
                 * into by the stepper. If the bit for an interceptor is set, the
                 * stepper will complete with reason STEPPER_INTERCEPT when the
                 * given type of intercept occurs.  If the bit is cleared, the
                 * intercepting code will be skipped.
                 *
                 * Note that SetInterceptMask may have unforeseen interactions
                 * with SetUnmappedStopMask (from the user's point of view).  For
                 * example, if the only visible (ie, non internal) portion of class
                 * init code lacks mapping info (STOP_NO_MAPPING_INFO) and
                 * STOP_NO_MAPPING_INFO isn't set, then we'll step over the class init.
                 *
                 * By default, only INTERCEPT_NONE will be used.
                 */
            
                typedef enum CorDebugIntercept
                {
                      INTERCEPT_NONE                = 0x0 ,
                      INTERCEPT_CLASS_INIT          = 0x01,
                      INTERCEPT_EXCEPTION_FILTER    = 0x02,
                      INTERCEPT_SECURITY            = 0x04,
                      INTERCEPT_CONTEXT_POLICY      = 0x08,
                      INTERCEPT_INTERCEPTION        = 0x10,
                      INTERCEPT_ALL                 = 0xffff
                } CorDebugIntercept;
            
                HRESULT SetInterceptMask([in] CorDebugIntercept mask);
            
                /*
                 * SetUnmappedStopMask controls whether the stepper
                 * will stop in jitted code which is not mapped to IL.
                 *
                 * If the given flag is set, then that type of unmapped code
                 * will be stopped in.  Otherwise stepping transparently continues.
                 *
                 * It should be noted that if one doesn't use a stepper to enter a
                 * method (for example, the main() method of C++), then one
                 * won't neccessarily step over prologs,etc.
                 *
                 * By default, STOP_OTHER_UNMAPPED will be used.
                 *
                 * STOP_UNMANAGED is only valid w/ interop debugging.
                 */
            
                typedef enum CorDebugUnmappedStop
                {
                    STOP_NONE               = 0x0,
                    STOP_PROLOG             = 0x01,
                    STOP_EPILOG             = 0x02,
                    STOP_NO_MAPPING_INFO    = 0x04,
                    STOP_OTHER_UNMAPPED     = 0x08,
                    STOP_UNMANAGED          = 0x10,
            
                    STOP_ALL                = 0xffff,
            
                } CorDebugUnmappedStop;
            
                HRESULT SetUnmappedStopMask([in] CorDebugUnmappedStop mask);
            
                /*
                 * Step is called when a thread is to be single stepped.  The step
                 * will complete at the next managed instruction executed by the
                 * EE in the stepper's frame.
                 *
                 * If bStepIn is TRUE, any function calls made during the step
                 * will be stepped into.  Otherwise they will be skipped.
                 *
                 * If Step is called on a stepper which is not in managed code,
                 * the step will complete when the next managed code is executed
                 * by the thread. (if bStepIn is FALSE, it will only complete
                 * when managed code is returned to, not when it is stepped into.)
                 */
            
                HRESULT Step([in] BOOL bStepIn);
            
                /*
                 * StepRange works just like Step, except it will not complete
                 * until code outside the given range is reached.  This can be
                 * more efficient than stepping one instruction at a time.
                 *
                 * Ranges are specified as a list of offset pairs [start, end)
                 * (note that end is exclusive) from the start of the stepper's
                 * frame's code.
                 *
                 * Ranges are in relative to the IL code of a method.  Call
                 * SetRangeIL(FALSE) to specify ranges relative to the native code
                 * of a method.
                 */
            
                typedef struct COR_DEBUG_STEP_RANGE
                {
                    ULONG32 startOffset, endOffset;
                } COR_DEBUG_STEP_RANGE;
            
                HRESULT StepRange([in] BOOL bStepIn,
                                  [in,size_is(cRangeCount)] COR_DEBUG_STEP_RANGE ranges[],
                                  [in] ULONG32 cRangeCount);
            
                /*
                 * A StepOut operation will complete after the current frame is
                 * returned from normally and the previous frame is reactivated.
                 *
                 * If this is called when in unmanaged code, the step will complete
                 * when the calling managed code is returned to.
                 *
                 * In v2.0, we explicitly forbid StepOut with the STOP_UNMANAGED mask
                 * and will fail that. Interop debuggers must do step-out-to-native
                 * themselves.
                 */
            
                HRESULT StepOut();
            
                /*
                 * SetRangeIL is used to set whether the ranges passed StepRange are
                 * relative to the IL code or the native code for the method being
                 * stepped in.
                 *
                 * By default the range is in IL.
                 */
            
                HRESULT SetRangeIL([in] BOOL bIL);
            };
            
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper.IsActive(System.Int32*)">
            <summary>
            IsActive returns whether or not the stepper is active, that is, whether
            it is currently stepping.
            Any step action remains active until StepComplete is called.  Note that
            this automatically deactivates the stepper.
            A stepper may also be deactivated prematurely by calling
            Deactivate before a callback condition is reached.
            </summary>
            <param name="pbActive"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper.Deactivate">
            <summary>
            Deactivate causes a stepper to cancel the last stepping command it
            received.  A new stepping command may then be issued.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper.SetInterceptMask(JetBrains.Debugger.CorApi.ComInterop.CorDebugIntercept)">
            <summary>
            SetInterceptMask controls which intercept code will be stepped
            into by the stepper. If the bit for an interceptor is set, the
            stepper will complete with reason STEPPER_INTERCEPT when the
            given type of intercept occurs.  If the bit is cleared, the
            intercepting code will be skipped.
            Note that SetInterceptMask may have unforeseen interactions
            with SetUnmappedStopMask (from the user's point of view).  For
            example, if the only visible (ie, non internal) portion of class
            init code lacks mapping info (STOP_NO_MAPPING_INFO) and
            STOP_NO_MAPPING_INFO isn't set, then we'll step over the class init.
            By default, only INTERCEPT_NONE will be used.
            </summary>
            <param name="mask"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper.SetUnmappedStopMask(JetBrains.Debugger.CorApi.ComInterop.CorDebugUnmappedStop)">
            <summary>
            SetUnmappedStopMask controls whether the stepper
            will stop in jitted code which is not mapped to IL.
            If the given flag is set, then that type of unmapped code
            will be stopped in.  Otherwise stepping transparently continues.
            It should be noted that if one doesn't use a stepper to enter a
            method (for example, the main() method of C++), then one
            won't neccessarily step over prologs,etc.
            By default, STOP_OTHER_UNMAPPED will be used.
            STOP_UNMANAGED is only valid w/ interop debugging.
            </summary>
            <param name="mask"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper.Step(System.Int32)">
            <summary>
            Step is called when a thread is to be single stepped.  The step
            will complete at the next managed instruction executed by the
            EE in the stepper's frame.
            If bStepIn is TRUE, any function calls made during the step
            will be stepped into.  Otherwise they will be skipped.
            If Step is called on a stepper which is not in managed code,
            the step will complete when the next managed code is executed
            by the thread. (if bStepIn is FALSE, it will only complete
            when managed code is returned to, not when it is stepped into.)
            </summary>
            <param name="bStepIn"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper.StepRange(System.Int32,JetBrains.Debugger.CorApi.ComInterop.COR_DEBUG_STEP_RANGE*,System.UInt32)">
            <summary>
            StepRange works just like Step, except it will not complete
            until code outside the given range is reached.  This can be
            more efficient than stepping one instruction at a time.
            Ranges are specified as a list of offset pairs [start, end)
            (note that end is exclusive) from the start of the stepper's
            frame's code.
            Ranges are in relative to the IL code of a method.  Call
            SetRangeIL(FALSE) to specify ranges relative to the native code
            of a method.
            </summary>
            <param name="bStepIn"></param>
            <param name="ranges"></param>
            <param name="cRangeCount"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper.StepOut">
            <summary>
            A StepOut operation will complete after the current frame is
            returned from normally and the previous frame is reactivated.
            If this is called when in unmanaged code, the step will complete
            when the calling managed code is returned to.
            In v2.0, we explicitly forbid StepOut with the STOP_UNMANAGED mask
            and will fail that. Interop debuggers must do step-out-to-native
            themselves.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper.SetRangeIL(System.Int32)">
            <summary>
            SetRangeIL is used to set whether the ranges passed StepRange are
            relative to the IL code or the native code for the method being
            stepped in.
            By default the range is in IL.
            </summary>
            <param name="bIL"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper2">
            <summary>
             ICorDebugStepper2 exposes JMC functionality.
            </summary>
            <example><code>
             /*
             * ICorDebugStepper2 exposes JMC functionality.
             */
            [
                object,
                local,
                uuid(C5B6E9C3-E7D1-4a8e-873B-7F047F0706F7),
                pointer_default(unique)
            ]
            interface ICorDebugStepper2 : IUnknown
            {
                HRESULT SetJMC([in] BOOL fIsJMCStepper);
            }
            
             </code></example>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepperEnum">
            <summary>
            </summary>
            <example><code>
            [
                object,
                local,
                uuid(CC7BCB04-8A68-11d2-983C-0000F808342D),
                pointer_default(unique)
            ]
            
            interface ICorDebugStepperEnum : ICorDebugEnum
            {
                /*
                 * Gets the next "celt" number of steppers in the enumeration.
                 * The actual number of steppers retrieved is returned in "pceltFetched".
                 * Returns S_FALSE if the actual number of steppers retrieved is smaller
                 * than the number of steppers requested.
                 */
                HRESULT Next([in] ULONG celt,
                             [out, size_is(celt), length_is(*pceltFetched)]
                                ICorDebugStepper *steppers[],
                             [out] ULONG *pceltFetched);
            }; </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepperEnum.Skip(System.UInt32)">
            <summary>
            Moves the current position forward the given number of elements.
            </summary>
            <param name="celt">the given number of elements</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepperEnum.Reset">
            <summary>
            Sets the position of the enumerator to the beginning of the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepperEnum.Clone(JetBrains.Debugger.CorApi.ComInterop.ICorDebugEnum@)">
            <summary>
            Creates another enumerator with the same current position as this one.
            </summary>
            <param name="ppEnum">another enumerator</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepperEnum.GetCount(System.UInt32*)">
            <summary>
            Gets the number of elements in the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepperEnum.Next(System.UInt32,System.Void**,System.UInt32*)">
            <summary>
            Gets the next "celt" number of steppers in the enumeration.
            The actual number of steppers retrieved is returned in "pceltFetched".
            Returns S_FALSE if the actual number of steppers retrieved is smaller than the number of steppers requested.
            </summary>
            <param name="celt"></param>
            <param name="steppers"></param>
            <param name="pceltFetched"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStringValue">
            <summary>
             ICorDebugStringValue is a subclass of ICorDebugValue which
             applies to values which contain a string.  This interface
             provides an easy way to get the string contents.
            </summary>
            <example><code>
             /*
             * ICorDebugStringValue is a subclass of ICorDebugValue which
             * applies to values which contain a string.  This interface
             * provides an easy way to get the string contents.
             */
            
            [
                object,
                local,
                uuid(CC7BCAFD-8A68-11d2-983C-0000F808342D),
                pointer_default(unique)
            ]
            interface ICorDebugStringValue : ICorDebugHeapValue
            {
                /*
                 * GetLength returns the number of characters in the string.
                 */
            
                HRESULT GetLength([out] ULONG32 *pcchString);
            
                /*
                 * GetString returns the contents of the string.
                 */
            
                HRESULT GetString([in] ULONG32 cchString,
                                  [out] ULONG32 *pcchString,
                                  [out, size_is(cchString),
                                  length_is(*pcchString)] WCHAR szString[]);
            };
            
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStringValue.GetType(JetBrains.Debugger.CorApi.ComInterop.CorElementType*)">
            <summary>
            GetType returns the simple type of the value.  If the object
            has a more complex runtime type, that type may be examined through the
            appropriate subclasses (e.g. ICorDebugObjectValue can get the class of
            an object.)
            </summary>
            <param name="elementType"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStringValue.GetSize(System.UInt32*)">
            <summary>
            GetSize returns the size of the value in bytes. Note that for reference
            types this will be the size of the pointer rather than the size of
            the object.
            </summary>
            <param name="pSize"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStringValue.GetAddress(System.UInt64*)">
            <summary>
            GetAddress returns the address of the value in the debugee
            process.  This might be useful information for the debugger to
            show.
            If the value is unavailable, 0 is returned. This could happen if
            it is at least partly in registers or stored in a GC Handle.
            </summary>
            <param name="pAddress"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStringValue.CreateBreakpoint(JetBrains.Debugger.CorApi.ComInterop.ICorDebugValueBreakpoint@)">
            <summary>
            NOT YET IMPLEMENTED
            </summary>
            <param name="ppBreakpoint"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStringValue.IsValid(System.Int32*)">
            <summary>
            DEPRECATED.
                * All objects are only valid until Continue is called, at which time they are neutered.
            </summary>
            <param name="pbValid"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStringValue.GetLength(System.UInt32*)">
            <summary>
            GetLength returns the number of characters in the string.
            </summary>
            <param name="pcchString"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugStringValue.GetString(System.UInt32,System.UInt32*,System.UInt16*)">
            <summary>
            GetString returns the contents of the string.
            </summary>
            <param name="cchString"></param>
            <param name="pcchString"></param>
            <param name="szString"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread">
             <summary>
             ICorDebugThread represents a thread in the process.  The lifetime of a thread object is equal to the lifetime of the thread it represents.
             </summary>
             <example><code>
             /*
             * ICorDebugThread represents a thread in the process.  The lifetime of a
             * thread object is equal to the lifetime of the thread it represents.
             */
            
            [
                object,
                local,
                uuid(938c6d66-7fb6-4f69-b389-425b8987329b),
                pointer_default(unique)
            ]
            interface ICorDebugThread : IUnknown
            {
                /*
                 * GetProcess returns the process of which this thread is a part.
                 */
            
                HRESULT GetProcess([out] ICorDebugProcess **ppProcess);
            
                /*
                 * GetID returns the current OS ID of the active part of the thread.
                 * Note that this may theoretically change as the process executes,
                 * and even be different for different parts of the thread.
                 */
            
                HRESULT GetID([out] DWORD *pdwThreadId);
            
                /*
                 * GetHandle returns the current Handle of the active part of the thread.
                 * Note that this may theoretically change as the process executes,
                 * and even be different for different parts of the thread.
                 *
                 * This handle is owned by the debugging API. The debugger should duplicate
                 * it before using it.
                 */
            
                HRESULT GetHandle([out] HTHREAD *phThreadHandle);
            
                /*
                 * GetAppDomain returns the app domain which the thread is currently
                 * executing in.
                 */
            
                HRESULT GetAppDomain([out] ICorDebugAppDomain **ppAppDomain);
            
                /*
                 * SetDebugState sets the current debug state of the thread.
                 * (The "current debug state"
                 * represents the debug state if the process were to be continued,
                 * not the actual current state.)
                 *
                 * The normal value for this is THREAD_RUNNING.  Only the debugger
                 * can affect the debug state of a thread.  Debug states do
                 * last across continues, so if you want to keep a thread
                 * THREAD_SUSPENDed over mulitple continues, you can set it once
                 * and thereafter not have to worry about it.
                 *
                 * Suspending threads and resuming the process can cause deadlocks, though it's
                 * usually unlikely. This is an intrinisc quality of threads and processes and is by-design.
                 * A debugger can async break and resume the threads to break the deadlock.
                 *
                 * If the thread's user state includes USER_UNSAFE_POINT, then the thread may block a GC.
                 * This means the suspended thread has a mcuh higher chance of causing a deadlock.
                 *
                 * This may not affect debug events already queued. Thus a debugger should drain the entire 
                 * event queue (via calling HasQueuedCallbacks) before suspending or resuming threads. Else it
                 * may get events on a thread that it believes it has already suspended.
                 *
                 */
            
                HRESULT SetDebugState([in] CorDebugThreadState state);
            
                /*
                 * GetDebugState returns the current debug state of the thread.
                 * (If the process is currently stopped, the "current debug state"
                 * represents the debug state if the process were to be continued,
                 * not the actual current state.)
                 */
            
                HRESULT GetDebugState([out] CorDebugThreadState *pState);
            
                /*
                 * GetUserState returns the user state of the thread, that is, the state
                 * which it has when the program being debugged examines it.
                 * A thread may have multiple state bits set.
                 */
            
                typedef enum CorDebugUserState
                {
                    USER_STOP_REQUESTED     = 0x01,
                    USER_SUSPEND_REQUESTED  = 0x02,
                    USER_BACKGROUND         = 0x04,
                    USER_UNSTARTED          = 0x08,
                    USER_STOPPED            = 0x10,
                    USER_WAIT_SLEEP_JOIN    = 0x20,
                    USER_SUSPENDED          = 0x40,
            
                    // An "unsafe point" is a place where the thread may block a Garbage Collection (GC).
                    // Debug events may be dispatched from unsafe points, but suspending a thread at
                    // an unsafe spot will very likely cause a deadlock (until the thread is resumed).
                    // This is a function of the thread's IP and the available GC info. The exact details
                    // of what is safe and unsafe is unspecified and highly determined by jit/gc implementation details.
                    USER_UNSAFE_POINT       = 0x80,
            
                    // indicates that this thread is a threadpool thread
                    USER_THREADPOOL         = 0x100,
                } CorDebugUserState;
            
                HRESULT GetUserState([out] CorDebugUserState *pState);
            
                /*
                 * GetCurrentException returns the exception object which is
                 * currently being thrown by the thread.  This will exist from the time the exception
                 * is thrown until the end of the catch block. That range will include filters
                 * and finallys.
                 *
                 * FuncEval will clear out the exception object on setup and restore it on completion.
                 *
                 * Exceptions can be nested (eg, if an exception is thrown in filter or a func-eval),
                 * so there may be multiple outstanding exceptions on a single thread.
                 * This returns the most current exception.
                 *
                 * The exception object and type may change throughout the life of the exception. For example, an
                 * exception of type X may be thrown, but then the CLR may run out of memory and promote
                 * that to an OutOfMemory exception.
                 */
            
                HRESULT GetCurrentException([out] ICorDebugValue **ppExceptionObject);
            
                /*
                 * This is not implemented.
                 */
            
                HRESULT ClearCurrentException();
            
                /*
                 * CreateStepper creates a stepper object which operates relative
                 * to the active frame in the given thread. (Note that this may be
                 * unmanaged code.)  The Stepper API must then be used to perform
                 * actual stepping.
                 *
                 */
            
                HRESULT CreateStepper([out] ICorDebugStepper **ppStepper);
            
                /*
                 * EnumerateChains returns an enum which will return all the stack
                 * chains in the thread, starting at the active (most recent) one.
                 * These chains represent the physical call stack for the thread.
                 *
                 * Chain boundaries occur for several reasons:
                 *   managed &lt;-&gt; unmanaged transitions
                 *   context switches
                 *   debugger hijacking of user threads
                 *
                 * Note that in the simple case for a thread running purely
                 * managed code in a single context there will be a one to one
                 * correspondence between threads &amp; chains.
                 *
                 * A debugger may want to rearrange the physical call
                 * stacks of all threads into logical call stacks. This would involve
                 * sorting all the threads' chains by their caller/callee
                 * relationships &amp; regrouping them.
                 *
                 */
            
                HRESULT EnumerateChains([out] ICorDebugChainEnum **ppChains);
            
                /*
                 * GetActiveChain is a convenience routine to return the
                 * active (most recent) chain on the thread, if any.
                 *
                 */
            
                HRESULT GetActiveChain([out] ICorDebugChain **ppChain);
            
                /*
                 * GetActiveFrame is a convenience routine to return the
                 * active (most recent) frame on the thread, if any.
                 * If there are no frames on the stack, ppFrame will point to NULL
                 * and the function still returns S_OK.
                 */
            
                HRESULT GetActiveFrame([out] ICorDebugFrame **ppFrame);
            
                /*
                 * GetRegisterSet returns the register set for the active part
                 * of the thread.
                 *
                 */
            
                HRESULT GetRegisterSet([out] ICorDebugRegisterSet **ppRegisters);
            
                /*
                 * CreateEval creates an evaluation object which operates on the
                 * given thread.  The Eval will push a new chain on the thread before
                 * doing its computation.
                 *
                 * Note that this interrupts the computation currently
                 * being performed on the thread until the eval completes.
                 *
                 */
            
                HRESULT CreateEval([out] ICorDebugEval **ppEval);
            
                /*
                 * Returns the runtime thread object.
                 */
            
                HRESULT GetObject([out] ICorDebugValue **ppObject);
            
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread.GetProcess(JetBrains.Debugger.CorApi.ComInterop.ICorDebugProcess@)">
            <summary>
            GetProcess returns the process of which this thread is a part.
            </summary>
            <param name="ppProcess"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread.GetID(System.UInt32*)">
            <summary>
            GetID returns the current OS ID of the active part of the thread.
            Note that this may theoretically change as the process executes,
            and even be different for different parts of the thread.
            </summary>
            <param name="pdwThreadId"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread.GetHandle(System.Void**)">
            <summary>
            GetHandle returns the current Handle of the active part of the thread.
            Note that this may theoretically change as the process executes,
            and even be different for different parts of the thread.
            
            This handle is owned by the debugging API. The debugger should duplicate
            it before using it.
            </summary>
            <param name="phThreadHandle"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread.GetAppDomain(JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain@)">
            <summary>
            GetAppDomain returns the app domain which the thread is currently executing in.
            </summary>
            <param name="ppAppDomain"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread.SetDebugState(JetBrains.Debugger.CorApi.ComInterop.CorDebugThreadState)">
            <summary>
            SetDebugState sets the current debug state of the thread.
            (The "current debug state"
            represents the debug state if the process were to be continued,
            not the actual current state.)
            
            The normal value for this is THREAD_RUNNING.  Only the debugger
            can affect the debug state of a thread.  Debug states do
            last across continues, so if you want to keep a thread
            THREAD_SUSPENDed over mulitple continues, you can set it once
            and thereafter not have to worry about it.
            
            Suspending threads and resuming the process can cause deadlocks, though it's
            usually unlikely. This is an intrinisc quality of threads and processes and is by-design.
            A debugger can async break and resume the threads to break the deadlock.
            
            If the thread's user state includes USER_UNSAFE_POINT, then the thread may block a GC.
            This means the suspended thread has a mcuh higher chance of causing a deadlock.
            
            This may not affect debug events already queued. Thus a debugger should drain the entire 
            event queue (via calling HasQueuedCallbacks) before suspending or resuming threads. Else it
            may get events on a thread that it believes it has already suspended.
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread.GetDebugState(JetBrains.Debugger.CorApi.ComInterop.CorDebugThreadState*)">
            <summary>
            GetDebugState returns the current debug state of the thread.
            (If the process is currently stopped, the "current debug state"
            represents the debug state if the process were to be continued,
            not the actual current state.)
            </summary>
            <param name="pState"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread.GetUserState(JetBrains.Debugger.CorApi.ComInterop.CorDebugUserState*)">
            <summary>
            GetUserState returns the user state of the thread, that is, the state
            which it has when the program being debugged examines it.
            A thread may have multiple state bits set.
            </summary>
            <param name="pState"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread.GetCurrentException(JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            GetCurrentException returns the exception object which is
            currently being thrown by the thread.  This will exist from the time the exception
            is thrown until the end of the catch block. That range will include filters
            and finallys.
            
            FuncEval will clear out the exception object on setup and restore it on completion.
            
            Exceptions can be nested (eg, if an exception is thrown in filter or a func-eval),
            so there may be multiple outstanding exceptions on a single thread.
            This returns the most current exception.
            
            The exception object and type may change throughout the life of the exception. For example, an
            exception of type X may be thrown, but then the CLR may run out of memory and promote
            that to an OutOfMemory exception.
            </summary>
            <param name="ppExceptionObject"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread.ClearCurrentException">
            <summary>
            This is not implemented.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread.CreateStepper(JetBrains.Debugger.CorApi.ComInterop.ICorDebugStepper@)">
            <summary>
            CreateStepper creates a stepper object which operates relative
            to the active frame in the given thread. (Note that this may be
            unmanaged code.)  The Stepper API must then be used to perform
            actual stepping.
            </summary>
            <param name="ppStepper"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread.EnumerateChains(JetBrains.Debugger.CorApi.ComInterop.ICorDebugChainEnum@)" -->
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread.GetActiveChain(JetBrains.Debugger.CorApi.ComInterop.ICorDebugChain@)">
            <summary>
            GetActiveChain is a convenience routine to return the
            active (most recent) chain on the thread, if any.
            </summary>
            <param name="ppChain"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread.GetActiveFrame(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame@)">
            <summary>
            GetActiveFrame is a convenience routine to return the
            active (most recent) frame on the thread, if any.
            If there are no frames on the stack, ppFrame will point to NULL
            and the function still returns S_OK.
            </summary>
            <param name="ppFrame"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread.GetRegisterSet(JetBrains.Debugger.CorApi.ComInterop.ICorDebugRegisterSet@)">
            <summary>
            GetRegisterSet returns the register set for the active part
            of the thread.
            </summary>
            <param name="ppRegisters"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread.CreateEval(JetBrains.Debugger.CorApi.ComInterop.ICorDebugEval@)">
            <summary>
            CreateEval creates an evaluation object which operates on the
            given thread.  The Eval will push a new chain on the thread before
            doing its computation.
            
            Note that this interrupts the computation currently
            being performed on the thread until the eval completes.
            </summary>
            <param name="ppEval"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread.GetObject(JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            Returns the runtime thread object.
            </summary>
            <param name="ppObject"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread2" -->
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread2.GetActiveFunctions(System.UInt32,System.UInt32*,JetBrains.Debugger.CorApi.ComInterop.COR_ACTIVE_FUNCTION*)">
            <summary>
            Retrieves the active functions for the given threads' frames. This
            includes AppDomain ID, Module ID, Funtion ID and IL offset for
            each active statement on the stack.  A flags field is also included
            for future information about the frame that might need to be conveyed.
            
            If pFunctions is NULL, returns only the number of functions that
            is on the stack in pcFunctions.
            </summary>
            <param name="cFunctions"></param>
            <param name="pcFunctions"></param>
            <param name="pFunctions"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread2.GetConnectionID(System.UInt32*)">
            <summary>
            Returns 0 if not part of a connection
            Maps to a SPID in SQL Server
            </summary>
            <param name="pdwConnectionId"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread2.GetTaskID(System.UInt64*)">
            <summary>
            Return the TASKID of this thread.
            </summary>
            <param name="pTaskId"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread2.GetVolatileOSThreadID(System.UInt32*)">
            <summary>
            Return the OS Thread ID
            </summary>
            <param name="pdwTid"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread2.InterceptCurrentException(JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame)">
            <summary>
            Allow the debugger to intercept the current exception on a thread.  It can be
            called between an Exception callback and the associated call to ICorDebugProcess::Continue.
            
            pFrame specifies where we should intercept the exception.  It must be a valid ICDFrame pointer,
            which can be obtained from a stackwalk.  However, you must not call Continue() between
            doing the stackwalk and calling this function.
            </summary>
            <param name="pFrame"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread3" -->
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread4">
            <summary>
             ICorDebugThread4 is a logical extension to ICorDebugThread.
            </summary>
            <example><code>
             /*
             * ICorDebugThread4 is a logical extension to ICorDebugThread.
             */
            [
                object,
                local,
                uuid(1A1F204B-1C66-4637-823F-3EE6C744A69C),
                pointer_default(unique)
            ]
            interface ICorDebugThread4 : IUnknown
            {
                /*
                 * Returns S_OK if ICorDebugThread::GetCurrentException() is non-NULL and the exception
                 * it refers to has completed the first pass of exception handling without locating 
                 * a catch clause.
                 * Returns S_FALSE if there is no exception, it hasn't completed first pass handling,
                 * or a catch handler was located
                 * Returns an appropriate error HRESULT when the answer can not be determined
                 */
                HRESULT HasUnhandledException();
            
                HRESULT GetBlockingObjects([out] ICorDebugBlockingObjectEnum **ppBlockingObjectEnum);
                /* 
                 * Gets the current CustomNotification object on the current thread. This could be NULL if no
                 * current notification object exists. If we aren't currently inside a CustomNotification callback,
                 * this will always return NULL.
                 * A debugger can examine this object to determine how to handle the notification. 
                 * See ICorDebugManagedCallback3::CustomNotification for more information about 
                 * custom notifications. 
                 */
                HRESULT GetCurrentCustomDebuggerNotification([out] ICorDebugValue ** ppNotificationObject);
            };
            
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread4.HasUnhandledException">
            <summary>
            Returns S_OK if ICorDebugThread::GetCurrentException() is non-NULL and the exception
            it refers to has completed the first pass of exception handling without locating
            a catch clause.
            Returns S_FALSE if there is no exception, it hasn't completed first pass handling,
            or a catch handler was located
            Returns an appropriate error HRESULT when the answer can not be determined
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread4.GetCurrentCustomDebuggerNotification(JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
             Gets the current CustomNotification object on the current thread. This could be NULL if no
             current notification object exists. If we aren't currently inside a CustomNotification callback,
             this will always return NULL.
             A debugger can examine this object to determine how to handle the notification.
             See ICorDebugManagedCallback3::CustomNotification for more information about
             custom notifications.
            </summary>
            <param name="ppNotificationObject"></param>
            <returns></returns>
            <seealso cref="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugManagedCallback3.CustomNotification(JetBrains.Debugger.CorApi.ComInterop.ICorDebugThread,JetBrains.Debugger.CorApi.ComInterop.ICorDebugAppDomain)"/>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThreadEnum">
             <summary>
             
             </summary>
             <example><code>
            [
                object,
                local,
                uuid(CC7BCB06-8A68-11d2-983C-0000F808342D),
                pointer_default(unique)
            ]
            interface ICorDebugThreadEnum : ICorDebugEnum
            {
                /*
                 * Gets the next "celt" number of threads in the enumeration.
                 * The actual number of threads retrieved is returned in "pceltFetched".
                 * Returns S_FALSE if the actual number of threads retrieved is smaller
                 * than the number of threads requested.
                 */
                HRESULT Next([in] ULONG celt,
                             [out, size_is(celt), length_is(*pceltFetched)]
                                ICorDebugThread *threads[],
                             [out] ULONG *pceltFetched);
            }; </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThreadEnum.Skip(System.UInt32)">
            <summary>
            Moves the current position forward the given number of elements.
            </summary>
            <param name="celt">the given number of elements</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThreadEnum.Reset">
            <summary>
            Sets the position of the enumerator to the beginning of the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThreadEnum.Clone(JetBrains.Debugger.CorApi.ComInterop.ICorDebugEnum@)">
            <summary>
            Creates another enumerator with the same current position as this one.
            </summary>
            <param name="ppEnum">another enumerator</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThreadEnum.GetCount(System.UInt32*)">
            <summary>
            Gets the number of elements in the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugThreadEnum.Next(System.UInt32,System.Void**,System.UInt32*)">
            <summary>
            Gets the next "celt" app domains in the enumeration
            </summary>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugType">
             <summary>
             ICorDebugType represents an instantiated type in the debugggee.
             Unlike ICorDebugClass, it can store type-parameter information and thus can
             represent instantiated generic types (Eg, List&lt;int&gt;)
             Use the metadata interfaces to get static (Compile-time) information about the type.
             
             A type (and all of its type parameters) lives in an single AppDomain and becomes 
             invalid once the containing ICorDebugAppDomain is unloaded.
             
             Types may be lazily loaded, so if the debugger queries for a type that hasn't been
             loaded yet, it may be unavailable. 
             </summary>
             <example><code>
             /*
             * ICorDebugType represents an instantiated type in the debugggee.
             * Unlike ICorDebugClass, it can store type-parameter information and thus can
             * represent instantiated generic types (Eg, List&lt;int&gt;)
             * Use the metadata interfaces to get static (Compile-time) information about the type.
             *
             * A type (and all of its type parameters) lives in an single AppDomain and becomes 
             * invalid once the containing ICorDebugAppDomain is unloaded.
             *
             * Types may be lazily loaded, so if the debugger queries for a type that hasn't been
             * loaded yet, it may be unavailable.
             */
            [
                object,
                local,
                uuid(D613F0BB-ACE1-4c19-BD72-E4C08D5DA7F5),
                pointer_default(unique)
            ]
            interface ICorDebugType : IUnknown
            {
                /*
                * GetType gets the basic type of the generic parameter.  This can be used to
                * determine if it is necessary to call GetClass to find the full information for the
                * generic type parameter.
                */
                HRESULT GetType([out] CorElementType *ty);
            
                /*
                * GetClass is used if the CorElementType returned by GetType is ELEMENT_TYPE_CLASS,
                * ELEMENT_TYPE_VALUETYPE.  If the type is a constructed type, e.g. List&lt;String&gt;,
                * then this will return the ICorDebugClass for the type constructor, i.e. "List&lt;T&gt;".
                *
                * GetClass should not be used if the element type is anything other than these two element
                * types.  In particular, it may not be used if the element type is ELEMENT_TYPE_STRING.
                */
                HRESULT GetClass([out] ICorDebugClass **ppClass);
            
                /*
                * EnumerateTypeParameters may be used if the CorElementType
                    * returned by GetType is one of ELEMENT_TYPE_CLASS,
                    * ELEMENT_TYPE_VALUETYPE, ELEMENT_TYPE_ARRAY, ELEMENT_TYPE_SZARRAY,
                * ELEMENT_TYPE_BYREF, ELEMENT_TYPE_PTR or ELEMENT_TYPE_FNPTR.
                    * It returns the parameters specifying further information about
                    * the type.  For example, if the type is "class Dict&lt;String,int32&gt;"
                * then EnumerateTypeParameters will return "String" and "int32"
                    * in sequence.
                *
                 */
                HRESULT EnumerateTypeParameters([out] ICorDebugTypeEnum **ppTyParEnum);
            
                /*
                * GetFirstTypeParameter can be used in those cases where the further
                    * information about the type involves at most one type
                * parameter.  You can determine this from the element type returned by
                    * GetType.  In particular it may be used with
                    * ELEMENT_TYPE_ARRAY, ELEMENT_TYPE_SZARRAY, ELEMENT_TYPE_BYREF
                    * or ELEMENT_TYPE_PTR.
                 * This can only be called if the type does indeed have a type-parameter.
                */
                HRESULT GetFirstTypeParameter([out] ICorDebugType **value);
            
                /*
                 * GetBase returns the ICorDebugType object for the base type of this type, if it
                 * has one, i.e. if the type is a class type.
                 * For example, if
                 *        class MyStringDict&lt;T&gt; : Dict&lt;String,T&gt;
                 * then the base type of "MyStringDict&lt;int32&gt;" will be "Dict&lt;String,int32&gt;".
                 *
                 * This is a helper function - you could compute this from EnumerateTypeParemeters,
                 * GetClass and the relevant metadata, but it is relatively painful: you would
                 * have to lookup the class, then the metadata of that class
                 * to find the "generic" base type, then instantiate this generic base type by
                 * looking up the type paramaters to the initial type,
                 * and then perform the appropriate instantiation in the case where the class
                 * happens to be either a generic class or a normal class with a constructed type
                 * as its parent.  Looking up the base types is useful to implement common
                 * debugger functionality, e.g. printing out all the fields of an object, including its
                 * superclasses.
                 *
                 */
            
                HRESULT GetBase([out] ICorDebugType **pBase);
            
                /*
                 * GetStaticFieldValue returns a value object (ICorDebugValue)
                     * for the given static field variable. For non-parameterized
                     * types, this is identical to calling GetStaticFieldValue on the
                     * ICorDebugClass object returned by ICorDebugType::GetClass.
                     * For parameterized types a static field value will be relative to a
                     * particular instantiation.  If in addition the static field could
                     * possibly be relative to either a thread, context, or appdomain, then pFrame
                     * will help the debugger determine the proper value.
                     *
                     * This may only be used when ICorDebugType::GetType returns
                     * ELEMENT_TYPE_CLASS or ELEMENT_TYPE_VALUETYPE.
                 */
                HRESULT GetStaticFieldValue([in] mdFieldDef fieldDef,
                                                [in] ICorDebugFrame *pFrame,
                                        [out] ICorDebugValue **ppValue);
            
            
                /*
                 * GetRank returns the number of dimensions in an array type
                 */
            
                HRESULT GetRank([out] ULONG32 *pnRank);
            
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugType.GetType(JetBrains.Debugger.CorApi.ComInterop.CorElementType@)">
            <summary>
            GetType gets the basic type of the generic parameter.  This can be used to
            determine if it is necessary to call GetClass to find the full information for the
            generic type parameter.
            </summary>
            <param name="ty"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugType.GetClass(JetBrains.Debugger.CorApi.ComInterop.ICorDebugClass@)">
            <summary>
            GetClass is used if the CorElementType returned by GetType is ELEMENT_TYPE_CLASS,
            ELEMENT_TYPE_VALUETYPE.  If the type is a constructed type, e.g. List&lt;String&gt;,
            then this will return the ICorDebugClass for the type constructor, i.e. "List&lt;T&gt;".
            
            GetClass should not be used if the element type is anything other than these two element
            types.  In particular, it may not be used if the element type is ELEMENT_TYPE_STRING.
            </summary>
            <param name="ppClass"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugType.EnumerateTypeParameters(JetBrains.Debugger.CorApi.ComInterop.ICorDebugTypeEnum@)">
            <summary>
                EnumerateTypeParameters may be used if the CorElementType
                    returned by GetType is one of ELEMENT_TYPE_CLASS,
                    ELEMENT_TYPE_VALUETYPE, ELEMENT_TYPE_ARRAY, ELEMENT_TYPE_SZARRAY,
                ELEMENT_TYPE_BYREF, ELEMENT_TYPE_PTR or ELEMENT_TYPE_FNPTR.
                    It returns the parameters specifying further information about
                    the type.  For example, if the type is "class Dict&lt;String,int32&gt;"
                then EnumerateTypeParameters will return "String" and "int32"
                    in sequence.
            </summary>
            <param name="ppTyParEnum"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugType.GetFirstTypeParameter(JetBrains.Debugger.CorApi.ComInterop.ICorDebugType@)">
            <summary>
             GetFirstTypeParameter can be used in those cases where the further
                information about the type involves at most one type
             parameter.  You can determine this from the element type returned by
                GetType.  In particular it may be used with
                ELEMENT_TYPE_ARRAY, ELEMENT_TYPE_SZARRAY, ELEMENT_TYPE_BYREF
                or ELEMENT_TYPE_PTR.
             This can only be called if the type does indeed have a type-parameter.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugType.GetBase(JetBrains.Debugger.CorApi.ComInterop.ICorDebugType@)">
            <summary>
            GetBase returns the ICorDebugType object for the base type of this type, if it
            has one, i.e. if the type is a class type.
            For example, if
                   class MyStringDict&lt;T&gt; : Dict&lt;String,T&gt;
            then the base type of "MyStringDict&lt;int32&gt;" will be "Dict&lt;String,int32&gt;".
            
            This is a helper function - you could compute this from EnumerateTypeParemeters,
            GetClass and the relevant metadata, but it is relatively painful: you would
            have to lookup the class, then the metadata of that class
            to find the "generic" base type, then instantiate this generic base type by
            looking up the type paramaters to the initial type,
            and then perform the appropriate instantiation in the case where the class
            happens to be either a generic class or a normal class with a constructed type
            as its parent.  Looking up the base types is useful to implement common
            debugger functionality, e.g. printing out all the fields of an object, including its
            superclasses.
            </summary>
            <param name="pBase"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugType.GetStaticFieldValue(System.UInt32,JetBrains.Debugger.CorApi.ComInterop.ICorDebugFrame,JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            GetStaticFieldValue returns a value object (ICorDebugValue)
            for the given static field variable. For non-parameterized
            types, this is identical to calling GetStaticFieldValue on the
            ICorDebugClass object returned by ICorDebugType::GetClass.
            For parameterized types a static field value will be relative to a
            particular instantiation.  If in addition the static field could
            possibly be relative to either a thread, context, or appdomain, then pFrame
            will help the debugger determine the proper value.
            
            This may only be used when ICorDebugType::GetType returns
            ELEMENT_TYPE_CLASS or ELEMENT_TYPE_VALUETYPE. 
            </summary>
            <param name="fieldDef"></param>
            <param name="pFrame"></param>
            <param name="ppValue"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugType.GetRank(System.UInt32*)">
            <summary>
            GetRank returns the number of dimensions in an array type.
            </summary>
            <param name="pnRank"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugType2">
            <summary>
            Extends the ICorDebugType interface to retrieve the type identifier of a base type or complex (user-defined) type.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugType2.GetTypeID(JetBrains.Debugger.CorApi.ComInterop.COR_TYPEID*)">
            <summary>
            Gets a COR_TYPEID for this type.
            </summary>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugTypeEnum">
            <summary>
            </summary>
            <example><code>
            [
                object,
                local,
                uuid(10F27499-9DF2-43ce-8333-A321D7C99CB4),
                pointer_default(unique)
            ]
            interface ICorDebugTypeEnum : ICorDebugEnum
            {
                /*
                 * Gets the next "celt" number of types in the enumeration.
                 * The actual number of types retrieved is returned in "pceltFetched".
                 * Returns S_FALSE if the actual number of types retrieved is smaller
                 * than the number of types requested.
                 */
                HRESULT Next([in] ULONG celt,
                             [out, size_is(celt), length_is(*pceltFetched)]
                                ICorDebugType *values[],
                             [out] ULONG *pceltFetched);
            }; </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugTypeEnum.Skip(System.UInt32)">
            <summary>
            Moves the current position forward the given number of elements.
            </summary>
            <param name="celt">the given number of elements</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugTypeEnum.Reset">
            <summary>
            Sets the position of the enumerator to the beginning of the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugTypeEnum.Clone(JetBrains.Debugger.CorApi.ComInterop.ICorDebugEnum@)">
            <summary>
            Creates another enumerator with the same current position as this one.
            </summary>
            <param name="ppEnum">another enumerator</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugTypeEnum.GetCount(System.UInt32*)">
            <summary>
            Gets the number of elements in the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugTypeEnum.Next(System.UInt32,System.Void**,System.UInt32*)">
            <summary>
            Gets the next "celt" number of types in the enumeration.
            The actual number of types retrieved is returned in "pceltFetched".
            Returns S_FALSE if the actual number of types retrieved is smaller than the number of types requested.
            </summary>
            <param name="celt"></param>
            <param name="values"></param>
            <param name="pceltFetched"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugUnmanagedCallback">
             <summary>
             
             </summary>
             <example><code>
             [
                object,
                local,
                uuid(5263E909-8CB5-11d3-BD2F-0000F80849BD),
                pointer_default(unique)
            ]
            interface ICorDebugUnmanagedCallback : IUnknown
            {
                /*
                 * DebugEvent is called when a DEBUG_EVENT is received which is
                 * not directly related to the Common Language Runtime.
                 *
                 * DO NOT USE any parts of the debugging API from the Win32 Event
                 * Thread. Only ICorDebugController::Continue() can be called on
                 * the Win32 Event Thread, and only when continuing from an out-of-band
                 * event.
                 *
                 * This callback is an exception to the rules about callbacks.
                 * When this callback is called, the process will be in the "raw"
                 * OS debug stopped state. The process will not be synchronized.
                 * The process will automatically enter the synchronized state when
                 * necessary to satisfy certain requests for information about
                 * managed code. (Note that this may result in other nested
                 * DebugEvent callbacks.)
                 *
                 * Call ClearCurrentException on the process to ignore an
                 * exception event before continuing the process. (Causes
                 * DBG_CONTINUE to be sent on continue rather than
                 * DBG_EXCEPTION_NOT_HANDLED)
                 * Out-of-band Breakpoint and single-step exceptions are automatically cleared.
                 *
                 * fOutOfBand will be FALSE if the debugging services support
                 * interaction with the process's managed state while the process
                 * is stopped due to this event. fOutOfBand will be TRUE if
                 * interaction with the process's managed state is impossible until
                 * the unmanaged event is continued from.
                 *
                 * Out-Of-Band events can come at anytime; even when there debuggee appears stopped
                 * and even when there's already an outstanding inband event.
                 *
                 * In v2.0, it is strongly recommended that the debugger just immediately
                 * continues OOB breakpoint events. The debugger should be using the ICorDebugProcess2
                 * SetUnmanagedBreakpoint and ClearUnmanagedBreakpoint APIs to add/remove breakpoints.
                 * Those APIs will already skip over any OOB breakpoints automatically. Thus the only
                 * oob breakpoints that get dispatched should be raw breakpoints already in the
                 * instruction stream (eg, like a call to kernel32!DebugBreak). In these cases,
                 * just continuing past the breakpoint is the correct thing to do. Do not try to use
                 * any other portion of the API like ClearCurrentException or Get/SetThreadContext.
                 *
                 */
            
                HRESULT DebugEvent([in] LPDEBUG_EVENT pDebugEvent,
                                   [in] BOOL fOutOfBand);
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugUnmanagedCallback.DebugEvent(System.Void*,System.Int32)">
            <summary>
            DebugEvent is called when a DEBUG_EVENT is received which is
            not directly related to the Common Language Runtime.
            
            DO NOT USE any parts of the debugging API from the Win32 Event
            Thread. Only ICorDebugController::Continue() can be called on
            the Win32 Event Thread, and only when continuing from an out-of-band
            event.
            
            This callback is an exception to the rules about callbacks.
            When this callback is called, the process will be in the "raw"
            OS debug stopped state. The process will not be synchronized.
            The process will automatically enter the synchronized state when
            necessary to satisfy certain requests for information about
            managed code. (Note that this may result in other nested
            DebugEvent callbacks.)
            
            Call ClearCurrentException on the process to ignore an
            exception event before continuing the process. (Causes
            DBG_CONTINUE to be sent on continue rather than
            DBG_EXCEPTION_NOT_HANDLED)
            Out-of-band Breakpoint and single-step exceptions are automatically cleared.
            
            fOutOfBand will be FALSE if the debugging services support
            interaction with the process's managed state while the process
            is stopped due to this event. fOutOfBand will be TRUE if
            interaction with the process's managed state is impossible until
            the unmanaged event is continued from.
            
            Out-Of-Band events can come at anytime; even when there debuggee appears stopped
            and even when there's already an outstanding inband event.
            
            In v2.0, it is strongly recommended that the debugger just immediately
            continues OOB breakpoint events. The debugger should be using the ICorDebugProcess2
            SetUnmanagedBreakpoint and ClearUnmanagedBreakpoint APIs to add/remove breakpoints.
            Those APIs will already skip over any OOB breakpoints automatically. Thus the only
            oob breakpoints that get dispatched should be raw breakpoints already in the
            instruction stream (eg, like a call to kernel32!DebugBreak). In these cases,
            just continuing past the breakpoint is the correct thing to do. Do not try to use
            any other portion of the API like ClearCurrentException or Get/SetThreadContext.
            </summary>
            <param name="pDebugEvent"></param>
            <param name="fOutOfBand"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue" -->
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue.GetType(JetBrains.Debugger.CorApi.ComInterop.CorElementType*)">
            <summary>
            GetType returns the simple type of the value.  If the object
            has a more complex runtime type, that type may be examined through the
            appropriate subclasses (e.g. ICorDebugObjectValue can get the class of
            an object.) 
            </summary>
            <param name="elementType"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue.GetSize(System.UInt32*)">
            <summary>
            GetSize returns the size of the value in bytes. Note that for reference
            types this will be the size of the pointer rather than the size of
            the object.
            </summary>
            <param name="pSize"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue.GetAddress(System.UInt64*)">
            <summary>
            GetAddress returns the address of the value in the debugee
            process.  This might be useful information for the debugger to
            show.
            
            If the value is unavailable, 0 is returned. This could happen if
            it is at least partly in registers or stored in a GC Handle. 
            </summary>
            <param name="pAddress"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue.CreateBreakpoint(JetBrains.Debugger.CorApi.ComInterop.ICorDebugValueBreakpoint@)">
            <summary>
            NOT YET IMPLEMENTED
            </summary>
            <param name="ppBreakpoint"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue2">
             <summary>
             
             </summary>
             <example><code>
             [
                object,
                local,
                uuid(5E0B54E7-D88A-4626-9420-A691E0A78B49),
                pointer_default(unique)
            ]
            interface ICorDebugValue2 : IUnknown
            {
                /*
                 * GetExactType returns the runtime type of the object in the value.
                 */
            
                HRESULT GetExactType([out] ICorDebugType **ppType);
            
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue2.GetExactType(JetBrains.Debugger.CorApi.ComInterop.ICorDebugType@)">
            <summary>
            GetExactType returns the runtime type of the object in the value.
            </summary>
            <param name="ppType"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugValueBreakpoint">
             <summary>
             
             </summary>
             <example><code>
             [
                object,
                local,
                uuid(CC7BCAEB-8A68-11d2-983C-0000F808342D),
                pointer_default(unique)
            ]
            interface ICorDebugValueBreakpoint : ICorDebugBreakpoint
            {
                /*
                 * Gets the value on which this breakpoint is set.
                 */
                HRESULT GetValue([out] ICorDebugValue **ppValue);
            };
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugValueBreakpoint.Activate(System.Int32)">
            <summary>
            Sets the active state of the breakpoint.
            </summary>
            <param name="bActive"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugValueBreakpoint.IsActive(System.Int32*)">
            <summary>
            Returns whether the breakpoint is active.
            </summary>
            <param name="pbActive"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugValueBreakpoint.GetValue(JetBrains.Debugger.CorApi.ComInterop.ICorDebugValue@)">
            <summary>
            Gets the value on which this breakpoint is set.
            </summary>
            <param name="ppValue"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ICorDebugValueEnum">
            <summary>
            </summary>
            <example><code>
            [
                object,
                local,
                uuid(CC7BCB0A-8A68-11d2-983C-0000F808342D),
                pointer_default(unique)
            ]
            interface ICorDebugValueEnum : ICorDebugEnum
            {
                /*
                 * Gets the next "celt" number of values in the enumeration.
                 * The actual number of values retrieved is returned in "pceltFetched".
                 * Returns S_FALSE if the actual number of values retrieved is smaller
                 * than the number of values requested.
                 */
                HRESULT Next([in] ULONG celt,
                             [out, size_is(celt), length_is(*pceltFetched)]
                                ICorDebugValue *values[],
                             [out] ULONG *pceltFetched);
            }; </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugValueEnum.Skip(System.UInt32)">
            <summary>
            Moves the current position forward the given number of elements.
            </summary>
            <param name="celt">the given number of elements</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugValueEnum.Reset">
            <summary>
            Sets the position of the enumerator to the beginning of the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugValueEnum.Clone(JetBrains.Debugger.CorApi.ComInterop.ICorDebugEnum@)">
            <summary>
            Creates another enumerator with the same current position as this one.
            </summary>
            <param name="ppEnum">another enumerator</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugValueEnum.GetCount(System.UInt32*)">
            <summary>
            Gets the number of elements in the enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ICorDebugValueEnum.Next(System.UInt32,System.Void**,System.UInt32*)">
            <summary>
            Gets the next "celt" number of values in the enumeration.
            The actual number of values retrieved is returned in "pceltFetched".
            Returns S_FALSE if the actual number of values retrieved is smaller than the number of values requested.
            </summary>
            <param name="celt"></param>
            <param name="values"></param>
            <param name="pceltFetched"></param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.IEnumUnknown">
            <summary>
              Enumerates objects with the IUnknown interface. It can be used to enumerate through the objects in a component containing multiple objects.
            </summary>
            <example><code>
              [
                object,
                uuid(00000100-0000-0000-C000-000000000046),
                pointer_default(unique)
            ]
            
            interface IEnumUnknown : IUnknown
            {
            
                typedef [unique] IEnumUnknown *LPENUMUNKNOWN;
            
                [local]
                HRESULT Next(
                    [in, annotation("_In_")] ULONG celt,
                    [out, annotation("_Out_writes_to_(celt,*pceltFetched)")] IUnknown **rgelt,
                    [out, annotation("_Out_opt_")] ULONG *pceltFetched);
            
                [call_as(Next)]
                HRESULT RemoteNext(
                    [in] ULONG celt,
                    [out, size_is(celt), length_is(*pceltFetched)] IUnknown **rgelt,
                    [out] ULONG *pceltFetched);
            
                HRESULT Skip(
                    [in] ULONG celt);
            
                HRESULT Reset();
            
                HRESULT Clone(
                    [out] IEnumUnknown **ppenum);
            }  
              </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.IEnumUnknown.Next(System.UInt32,System.Object[],System.UInt32@)">
            <summary>
            Retrieves the specified number of items in the enumeration sequence.
            </summary>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.ISequentialStream">
            <summary>
            
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ISequentialStream.RemoteRead(System.Void*,System.UInt32,System.UInt32*)">
             <summary>
                 [local]
                HRESULT Read(
                    [annotation("_Out_writes_bytes_to_(cb, *pcbRead)")]
                    void *pv,
                    [in, annotation("_In_")] ULONG cb,
                    [annotation("_Out_opt_")] ULONG *pcbRead);
            
                [call_as(Read)]
                HRESULT RemoteRead(
                    [out, size_is(cb), length_is(*pcbRead)]
                    byte *pv,
                    [in] ULONG cb,
                    [out] ULONG *pcbRead);
             </summary>
             <param name="pv"></param>
             <param name="cb"></param>
             <param name="pcbRead"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.ISequentialStream.RemoteWrite(System.Void*,System.UInt32,System.UInt32*)">
             <summary>
                 [local]
                HRESULT Write(
                    [annotation("_In_reads_bytes_(cb)")] void const *pv,
                    [in, annotation("_In_")] ULONG cb,
                    [annotation("_Out_opt_")] ULONG *pcbWritten);
            
                [call_as(Write)]
                HRESULT RemoteWrite(
                    [in, size_is(cb)] byte const *pv,
                    [in] ULONG cb,
                    [out] ULONG *pcbWritten);
             </summary>
             <param name="pv"></param>
             <param name="cb"></param>
             <param name="pcbWritten"></param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.IStream.RemoteRead(System.Void*,System.UInt32,System.UInt32*)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ISequentialStream.RemoteRead(System.Void*,System.UInt32,System.UInt32*)" />
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.IStream.RemoteWrite(System.Void*,System.UInt32,System.UInt32*)">
            <inheritdoc cref="M:JetBrains.Debugger.CorApi.ComInterop.ISequentialStream.RemoteWrite(System.Void*,System.UInt32,System.UInt32*)" />
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.IStream.RemoteSeek(JetBrains.Interop.WinApi.LARGE_INTEGER,System.UInt32,JetBrains.Interop.WinApi.ULARGE_INTEGER*)">
             <summary>
             
             </summary>
             <param name="dlibMove"></param>
             <param name="dwOrigin"><see cref="T:JetBrains.Interop.WinApi.Declarations.Constants.STREAM_SEEK"/></param>
             <param name="plibNewPosition"></param>
             <example><code>    [local]
                HRESULT Seek(
                    [in] LARGE_INTEGER dlibMove,
                    [in] DWORD dwOrigin,
                    [annotation("_Out_opt_")] ULARGE_INTEGER *plibNewPosition);
            
                [call_as(Seek)]
                HRESULT RemoteSeek(
                    [in] LARGE_INTEGER dlibMove,
                    [in] DWORD dwOrigin,
                    [out] ULARGE_INTEGER *plibNewPosition);</code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.IStream.SetSize(JetBrains.Interop.WinApi.ULARGE_INTEGER)">
            <summary>
            
            </summary>
            <param name="libNewSize"></param>
            <example><code>
                HRESULT SetSize(
                   [in] ULARGE_INTEGER libNewSize);
            </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.IStream.RemoteCopyTo(JetBrains.Debugger.CorApi.ComInterop.IStream,JetBrains.Interop.WinApi.ULARGE_INTEGER,JetBrains.Interop.WinApi.ULARGE_INTEGER*,JetBrains.Interop.WinApi.ULARGE_INTEGER*)">
             <summary>
             
             </summary>
             <param name="pstm"></param>
             <param name="cb"></param>
             <param name="pcbRead"></param>
             <param name="pcbWritten"></param>
             <example><code>
                 [local]
                HRESULT CopyTo(
                    [in, unique, annotation("_In_")] IStream *pstm,
                    [in] ULARGE_INTEGER cb,
                    [annotation("_Out_opt_")] ULARGE_INTEGER *pcbRead,
                    [annotation("_Out_opt_")] ULARGE_INTEGER *pcbWritten);
            
                [call_as(CopyTo)]
                HRESULT RemoteCopyTo(
                    [in, unique] IStream *pstm,
                    [in] ULARGE_INTEGER cb,
                    [out] ULARGE_INTEGER *pcbRead,
                    [out] ULARGE_INTEGER *pcbWritten);
            </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.IStream.Commit(System.UInt32)">
             <summary>
             
             </summary>
             <param name="grfCommitFlags"></param>
             <example><code>
                 HRESULT Commit(
                    [in] DWORD grfCommitFlags);
            </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.IStream.Revert">
            <summary>
            
            </summary>
            <example><code>
                HRESULT Revert();
            </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.IStream.LockRegion(JetBrains.Interop.WinApi.ULARGE_INTEGER,JetBrains.Interop.WinApi.ULARGE_INTEGER,System.UInt32)">
            <summary>
            
            </summary>
            <param name="libOffset"></param>
            <param name="cb"></param>
            <param name="dwLockType"></param>
            <example><code>
               HRESULT LockRegion(
                   [in] ULARGE_INTEGER libOffset,
                   [in] ULARGE_INTEGER cb,
                   [in] DWORD dwLockType);
            </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.IStream.UnlockRegion(JetBrains.Interop.WinApi.ULARGE_INTEGER,JetBrains.Interop.WinApi.ULARGE_INTEGER,System.UInt32)">
            <summary>
            
            </summary>
            <param name="libOffset"></param>
            <param name="cb"></param>
            <param name="dwLockType"></param>
            <example><code>
               HRESULT UnlockRegion(
                   [in] ULARGE_INTEGER libOffset,
                   [in] ULARGE_INTEGER cb,
                   [in] DWORD dwLockType);
            </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.IStream.Stat(JetBrains.Interop.WinApi.Declarations.Structures.STATSTG*,System.UInt32)">
            <summary>
            
            </summary>
            <param name="pstatstg"></param>
            <param name="grfStatFlag"></param>
            <example><code>
               HRESULT Stat(
                   [out] STATSTG *pstatstg,
                   [in] DWORD grfStatFlag);
            </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.ComInterop.IStream.Clone(JetBrains.Debugger.CorApi.ComInterop.IStream@)">
            <summary>
            
            </summary>
            <param name="ppstm"></param>
            <example><code>
               HRESULT Clone(
                   [out] IStream **ppstm);
            </code></example>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.LoggingLevelEnum">
            <summary>
            Enum defining log message LoggingLevels
            </summary>
            <example><code>
                /*
                * Enum defining log message LoggingLevels
                */
               typedef enum LoggingLevelEnum
               {
                   LTraceLevel0 = 0,
                   LTraceLevel1,
                   LTraceLevel2,
                   LTraceLevel3,
                   LTraceLevel4,
                   LStatusLevel0 = 20,
                   LStatusLevel1,
                   LStatusLevel2,
                   LStatusLevel3,
                   LStatusLevel4,
                   LWarningLevel = 40,
                   LErrorLevel = 50,
                   LPanicLevel = 100
               } LoggingLevelEnum;
            </code></example>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.ComInterop.LogSwitchCallReason">
             <summary>
             
             </summary>
             <example><code>
                 typedef enum LogSwitchCallReason
                {
                    SWITCH_CREATE,
                    SWITCH_MODIFY,
                    SWITCH_DELETE
                } LogSwitchCallReason;
            
             </code></example>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.Pinvoke.NetClrDebuggerUtil">
            <summary>Helper methods for .NET Framework debugging.</summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.Pinvoke.NetClrDebuggerUtil.WaitForClrInitialization(System.UInt32,System.UInt32,System.Action,System.TimeSpan)">
            <summary>Waits for CLR loading in the target process.</summary>
            <param name="processId">Target process identifier.</param>
            <param name="threadId">Main thread identifier of the target process.</param>
            <param name="onInitializationSuspended">Callback that will be called while the process is suspended in debugger immediately after runtime was loaded. Debugged thread is suspended during the callback and will be auto-resumed after the callback.</param>
            <param name="timeout">Timeout after which the process will be </param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="P:JetBrains.Debugger.CorApi.Pinvoke.CoreClrDebugFiles.CoreRunExecutable">
            <summary>
            The executable file which should be started as a new process to run a NetCore DLL.
            Would be an attach-only session if this path is not known.
            </summary>
        </member>
        <member name="P:JetBrains.Debugger.CorApi.Pinvoke.CoreClrDebugFiles.DbgShimLibrary">
            <summary>
            The library shim file which should be loaded into the debugger process to control the debugging.
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.Pinvoke.CoreClrDebugFiles.FromShimDirectory(JetBrains.Util.FileSystemPath)">
            <summary>
            Tries to locate the files required for run and run/attach in the given directory which supposedly has the CoreCLR files.
            NOTE this must be the directory with DLLs rather than the root distro dir.
            </summary>
            <param name="shimDirectory">Path to runtime internals dir that contains dbgshim.dll/libdbgshim.so/dylib. Usually dotnet/shared/Microsoft.NETCore.App/[version]/</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.Pinvoke.CoreClrDebugFiles.WithRuntimeExe(JetBrains.Util.FileSystemPath)">
            <param name="runtimeExe">Path to root dotnet.exe. In some cases it may be useful to pass corehost.exe/corerun.exe etc.</param>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.Pinvoke.CoreClrDebugFiles.ToString">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Debugger.CorApi.Pinvoke.CoreClrDebuggerUtil.StartProcessWithDebugger_CreateProcessForLaunch(JetBrains.Debugger.CorApi.Pinvoke.DbgShimInterop,JetBrains.Util.FileSystemPath,JetBrains.Util.CommandLineBuilderJet,JetBrains.Util.FileSystemPath,System.Collections.Generic.IDictionary{System.String,System.String},System.TimeSpan,System.Action{JetBrains.Debugger.CorApi.Pinvoke.CoreClrDebuggerUtil.CorDebugAndPid})">
            <summary>
            Calls the CreateProcessForLaunch API.
            Has problems with passing env variables (it's an OS-dependent BLOB in Windows 95 format, so not all of the WinNT properties fit in).
            Does not support IO streams redirection.
            Works on any OS.
            </summary>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.Pinvoke.DbgShimInterop.CreateProcessForLaunchDelegate">
            <summary>
            HRESULT CreateProcessForLaunch(
            __in LPWSTR lpCommandLine,
            __in BOOL bSuspendProcess,
            __in LPVOID lpEnvironment,
            __in LPCWSTR lpCurrentDirectory,
            __out PDWORD pProcessId,
            __out HANDLE *pResumeHandle)
            </summary>
            <param name="lpCommandLine">lpCommandLine</param>
            <param name="bSuspendProcess">bSuspendProcess</param>
            <param name="lpEnvironment">lpEnvironment</param>
            <param name="lpCurrentDirectory">lpCurrentDirectory</param>
            <param name="pProcessId">pProcessId</param>
            <param name="pResumeHandle">pResumeHandle</param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.Pinvoke.DbgShimInterop.PSTARTUP_CALLBACK">
            <summary>
            typedef VOID (*PSTARTUP_CALLBACK)(IUnknown *pCordb, PVOID parameter, HRESULT hr);
            </summary>
            <param name="pCordb">pCordb</param>
            <param name="parameter">parameter</param>
            <param name="hr">hr</param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.Pinvoke.DbgShimInterop.RegisterForRuntimeStartupDelegate">
            <summary>
            HRESULT
            RegisterForRuntimeStartup(
              __in DWORD dwProcessId,
              __in PSTARTUP_CALLBACK pfnCallback,
              __in PVOID parameter,
              __out PVOID *ppUnregisterToken)
            </summary>
            <param name="dwProcessId">dwProcessId</param>
            <param name="callback">callback</param>
            <param name="parameter">parameter</param>
            <param name="ppUnregisterToken">ppUnregisterToken</param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.Pinvoke.DbgShimInterop.UnregisterForRuntimeStartupDelegate">
            <summary>
             UnregisterForRuntimeStartup -- stops/cancels runtime startup notification. Needs
                  to be called during the debugger's shutdown to cleanup the internal data.
                This API can be called in the startup callback. Otherwise, it will block until
                the callback thread finishes and no more callbacks will be initiated after this
                API returns.
            </summary>
            <param name="pUnregisterToken">unregister token from RegisterForRuntimeStartup or NULL</param>
            <returns></returns>
            <example><code>
            HRESULT
            UnregisterForRuntimeStartup(
                __in PVOID pUnregisterToken)
            
             </code></example>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.Pinvoke.DbgShimInterop.ResumeProcessDelegate">
            <summary>
            HRESULT
            ResumeProcess(
              __in HANDLE hResumeHandle)
            </summary>
            <param name="hResumeHandle">hResumeHandle</param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.Pinvoke.DbgShimInterop.CloseResumeHandleDelegate">
            <summary>
            HRESULT
            CloseResumeHandle(
              __in HANDLE hResumeHandle)
            </summary>
            <param name="hResumeHandle">hResumeHandle</param>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.Pinvoke.DbgShimInterop.CLRCreateInstanceDelegate">
            <summary>
            HRESULT 
            CLRCreateInstance(
                REFCLSID clsid,
                REFIID riid, 
                LPVOID *ppInterface)
            </summary>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.Pinvoke.MscoreeDll.CLRCreateInstance(System.Guid*,System.Guid*,System.Void**)">
            <summary>
             This should be the only flat public API exposed from mscoree going forward.
             The returned interface is likely to be implemented in a separate versioned DLL
             (mscorhst.dll living in the versioned directory for instance). Acceptable values
             for riid in v4.0 are IID_ICLRMetaHost, IID_ICLRMetaHostPolicy and
             IID_ICLRDebugging.
            </summary>
            <example><code>
             /**************************************************************************************
             ** This should be the only flat public API exposed from mscoree going forward.      **
             ** The returned interface is likely to be implemented in a separate versioned DLL   **
             ** (mscorhst.dll living in the versioned directory for instance). Acceptable values **
             ** for riid in v4.0 are IID_ICLRMetaHost, IID_ICLRMetaHostPolicy and                **
             ** IID_ICLRDebugging.                                                               **
             **************************************************************************************/
            cpp_quote("STDAPI CLRCreateInstance(REFCLSID clsid, REFIID riid, /*iid_is(riid)*/ LPVOID *ppInterface);")
            
             </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.Pinvoke.MscoreeDll.CreateDebuggingInterfaceFromVersion(System.Int32,System.UInt16*,System.Void**)">
            <summary>
            </summary>
            <example><code>
            #pragma midl_echo("DEPRECATED_CLR_STDAPI CreateDebuggingInterfaceFromVersion(int iDebuggerVersion, LPCWSTR szDebuggeeVersion, IUnknown ** ppCordb);")
            </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.Pinvoke.MscoreeDll.GetCORVersion(System.UInt16*,System.UInt32,System.UInt32*)">
            <summary>
            </summary>
            <example><code>
            #pragma midl_echo("DEPRECATED_CLR_STDAPI GetCORVersion(_Out_writes_to_(cchBuffer, *dwLength) LPWSTR pbBuffer, DWORD cchBuffer, DWORD* dwLength);")
            </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.Pinvoke.MscoreeDll.GetRequestedRuntimeVersion(System.UInt16*,System.UInt16*,System.UInt32,System.UInt32*)">
            <summary>
            </summary>
            <example><code>
            #pragma midl_echo("DEPRECATED_CLR_STDAPI GetRequestedRuntimeVersion(_In_ LPWSTR pExe, _Out_writes_to_(cchBuffer, *dwLength) LPWSTR pVersion, DWORD cchBuffer, _Out_ DWORD* dwLength);")
            </code></example>
        </member>
        <member name="M:JetBrains.Debugger.CorApi.Pinvoke.MscoreeDll.GetVersionFromProcess(System.Void*,System.UInt16*,System.UInt32,System.UInt32*)">
            <summary>
            </summary>
            <example><code>
            #pragma midl_echo("DEPRECATED_CLR_STDAPI GetVersionFromProcess(HANDLE hProcess, _Out_writes_to_(cchBuffer, *dwLength) LPWSTR pVersion, DWORD cchBuffer, _Out_ DWORD* dwLength);")
            </code></example>
        </member>
        <member name="T:JetBrains.Debugger.CorApi.Pinvoke.MscoreeDll.CLSID_CLRMetaHost">
            <example><code>
             // CLSID_CLRMetaHost : uuid(9280188D-0E8E-4867-B30C-7FA83884E8DE)
            cpp_quote("EXTERN_GUID(CLSID_CLRMetaHost, 0x9280188d, 0xe8e, 0x4867, 0xb3, 0xc, 0x7f, 0xa8, 0x38, 0x84, 0xe8, 0xde);")
             </code></example>
        </member>
    </members>
</doc>
